<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>proxy</title>
      <link href="/2022/11/26/proxy/"/>
      <url>/2022/11/26/proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h1><hr><p>代理将数据和逻辑分开，分别保存在不同合约中，代理合约和逻辑合约</p><p>对外暴露的是代理合约的地址，用户在进行交互是实际在于代理合约交互，代理合约把数据传给逻辑合约，逻辑合约执行后返回给代理合约，代理合约进一步返回给用户。<br>此方式可以对逻辑合约进行升级，只需把代理合约指向的目标合约进行替换。</p><p>代理合约的实现需要solidity内联汇编，开发者需要熟悉每个步骤的含义<br>代理合约如何实现逻辑合约的函数调用？<br>主要是回调函数，当调用合约中不存在的函数会触发合约中的回调函数，回调函数中将calldata储存并用delegatecall调用目标合约<br>比如</p><pre><code>fallback() external payable &#123;address _implementation = implementation;    assembly &#123;        // 将msg.data拷贝到内存里        // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度        calldatacopy(0, 0, calldatasize())        // 利用delegatecall调用implementation合约        // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度        // output area起始位置和长度位置，所以设为0        // delegatecall成功返回1，失败返回0        let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)        // 将return data拷贝到内存        // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度        returndatacopy(0, 0, returndatasize())        switch result        // 如果delegate call失败，revert        case 0 &#123;            revert(0, returndatasize())        &#125;        // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）        default &#123;            return(0, returndatasize())        &#125;    &#125;&#125;</code></pre><hr><h2 id="openzepplin代理-核心"><a href="#openzepplin代理-核心" class="headerlink" title="openzepplin代理 核心"></a>openzepplin代理 核心</h2><p>1.<strong>proxy</strong><br>此抽象合约提供了一个回退函数，该函数使用 EVM 将所有调用委托给另一个合约指令，第二个合约的实现必须通过覆盖虚拟_implementation函数来指定<br>2.<strong>ERC1967Proxy</strong><br>此协定实现可升级的代理。它是可升级的，因为调用被委托给可以更改的实现地址</p><pre><code>contract ERC1967Proxy is Proxy, ERC1967Upgrade &#123;    constructor(address _logic, bytes memory _data) payable &#123;        _upgradeToAndCall(_logic, _data, false);    &#125;    function _implementation() internal view virtual override returns (address impl) &#123;        return ERC1967Upgrade._getImplementation();    &#125;&#125;</code></pre><p>3.<strong>ERC1967Upgrade</strong><br>整理下其中的函数和事件<br>首先是回调函数：</p><pre><code> function _upgradeBeaconToAndCall(        address newBeacon,        bytes memory data,        bool forceCall    ) internal &#123;        _setBeacon(newBeacon);        emit BeaconUpgraded(newBeacon);        if (data.length &gt; 0 || forceCall) &#123;            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);        &#125;    &#125;&#125;</code></pre><p>它将调用数据传给目标合约<br>三个事件：</p><pre><code>event AdminChanged(address previousAdmin, address newAdmin);//更改管理员时触发event Upgraded(address indexed implementation);//升级时触发event BeaconUpgraded(address indexed beacon)；//升级信标时触发</code></pre><p>获得当前管理：</p><pre><code> function _getAdmin() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;&#125;</code></pre><p>更改管理：</p><pre><code>function _changeAdmin(address newAdmin) internal &#123;    emit AdminChanged(_getAdmin(), newAdmin);    _setAdmin(newAdmin);&#125;function _setAdmin(address newAdmin) private &#123;    require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;);    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;&#125;</code></pre><p>返回信标：</p><pre><code> function _getBeacon() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_BEACON_SLOT).value;&#125;</code></pre><p>设置一个新信标在EIP1967 beacon solt：</p><pre><code> function _setBeacon(address newBeacon) private &#123;    require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;);    require(        Address.isContract(IBeacon(newBeacon).implementation()),        &quot;ERC1967: beacon implementation is not a contract&quot;    );    StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;&#125;</code></pre><p>获得当前目标地址：</p><pre><code> function _getImplementation() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;&#125;</code></pre><p>更新目标地址：</p><pre><code> function _upgradeTo(address newImplementation) internal &#123;    _setImplementation(newImplementation);    emit Upgraded(newImplementation);&#125;function _setImplementation(address newImplementation) private &#123;    require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;&#125;</code></pre><p>更改并调用：</p><pre><code> function _upgradeToAndCall(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    _upgradeTo(newImplementation);    if (data.length &gt; 0 || forceCall) &#123;        Address.functionDelegateCall(newImplementation, data);    &#125;&#125;  function _upgradeToAndCallUUPS(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123;        _setImplementation(newImplementation);    &#125; else &#123;        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123;            require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;);        &#125; catch &#123;            revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;);        &#125;        _upgradeToAndCall(newImplementation, data, forceCall);    &#125;&#125;</code></pre><hr><h2 id="Contract-Initializable"><a href="#Contract-Initializable" class="headerlink" title="Contract Initializable"></a>Contract Initializable</h2><p>用于帮助编写可升级的合约或将要部署的任何类型的合约部署在代理后面</p><p>初始化函数使用版本号。一旦使用了版本号，它就会被使用，并且不能 重用。此机制可防止重新执行每个“步骤”</p><pre><code>function isConstructor() private view returns (bool) &#123;    address self = address(this);    uint256 cs;    assembly &#123; cs := extcodesize(self) &#125; //检查当前地址代码量    return cs == 0;&#125;</code></pre><p>修饰符：</p><pre><code> modifier initializer() &#123;    require(initializing || isConstructor() || !initialized, &quot;Contract instance has already been initialized&quot;);    bool isTopLevelCall = !initializing;    if (isTopLevelCall) &#123;    initializing = true;    initialized = true;    &#125;    _;  //执行完函数体 initializing状态改变    if (isTopLevelCall) &#123;    initializing = false;    &#125;&#125;</code></pre><h2 id="abstract-contract-Initializable"><a href="#abstract-contract-Initializable" class="headerlink" title="abstract contract Initializable"></a>abstract contract Initializable</h2><p>三个修饰符<br>1.只在进行中</p><pre><code> modifier onlyInitializing() &#123;    require(_initializing, &quot;Initializable: contract is not initializing&quot;);    _;&#125;</code></pre><p>2.更新版本</p><pre><code>modifier reinitializer(uint8 version) &#123;    require(!_initializing &amp;&amp; _initialized &lt; version, &quot;Initializable: contract is already initialized&quot;);    _initialized = version;    _initializing = true;    _;    _initializing = false;    emit Initialized(version);&#125;</code></pre><p>3.初始化</p><pre><code>modifier initializer() &#123;    bool isTopLevelCall = !_initializing;    require(        (isTopLevelCall &amp;&amp; _initialized &lt; 1) || (!Address.isContract(address(this)) &amp;&amp; _initialized == 1),        &quot;Initializable: contract is already initialized&quot;    );    //需要从来没有初始化，或者更新版本为1    _initialized = 1;    if (isTopLevelCall) &#123;        _initializing = true;    &#125;    _;    if (isTopLevelCall) &#123;        _initializing = false;        emit Initialized(1);    &#125;&#125;</code></pre><p>函数：报废</p><pre><code>function _disableInitializers() internal virtual &#123;    require(!_initializing, &quot;Initializable: contract is initializing&quot;);    if (_initialized != type(uint8).max) &#123;        _initialized = type(uint8).max;        emit Initialized(type(uint8).max);    &#125;&#125;</code></pre><hr><h2 id="OpenZepplin的UUPS代理模式"><a href="#OpenZepplin的UUPS代理模式" class="headerlink" title="OpenZepplin的UUPS代理模式"></a>OpenZepplin的UUPS代理模式</h2><p>轻量级又通用<br>UUPS 代理中，升级由实现处理，最终可以删除<br>UUPS 代理是使用ERC1967Proxy。实现的作用是，除了合约的逻辑之外，还包括更新存储在代理存储空间中特定插槽中的实现地址所需的所有代码。</p>]]></content>
      
      
      <categories>
          
          <category> text </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>argument encoding</title>
      <link href="/2022/11/26/Argument-Encoding/"/>
      <url>/2022/11/26/Argument-Encoding/</url>
      
        <content type="html"><![CDATA[<h1 id="关于函数选择器中的argument-encodeing"><a href="#关于函数选择器中的argument-encodeing" class="headerlink" title="关于函数选择器中的argument encodeing"></a>关于函数选择器中的argument encodeing</h1><p><strong>规则</strong><br>先将函数参数按顺序储存，如果是定长数据类型，直接储存其data，如果是变长数据类型，先储存其offset<br>    <em>对于第一个变长数据</em>：offset = 0x20<em>num（num为函数参数的个数）    </em>对于其后的变长数据<em>：offset = offset——pre + 0x20</em>num（offset——pre为上一个变长数据储存占用的大小，num为上一个变长数据元素的个数）<br>储存完offset 接着储存length和data</p><p>例如</p><pre><code>function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter/*data of first parameter: uint定长类型，直接存储其dataoffset of second parameter: uint32[]动态数组，先存储其offset=0x20*4 (4代表函数参数的个数) data of third parameter: bytes10定长类型，直接存储其dataoffset of forth parameter: bytes变长类型，先存储其offset=0x80+0x20*3=0xe0 (0x80是前一个变长类型的offset，3是前一个变长类型存储其长度和两个元素占用的插槽个数)length of second parameter: 存储完data或者offset后，便开始存储变长数据的length和data，这里是第二个参数的长度first data of second parameter: 第二个参数的第一个数据second data of second parameter: 第二个参数的第二个数据length of forth parameter: 上面就把第二个变长数据存储完成，这里就是存储下一个变长数据的长度data of forth parameter: 第四个参数的数据*/</code></pre><p>对于较复杂的结构  可以由内向外拆分</p><pre><code>struct Test &#123;        string name;        string policies;        uint num;    &#125;function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;设结构体数组有两个结构体第一个结构体内*注：结构体内部编码形式可以看作一个函数offset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1对于第二个结构体内offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p><em>由于是结构体</em><br>还需要</p><pre><code>offset of [name1, policies1,num1]offset of [name2, policies2,num2]</code></pre><p>由于是结构体数组<br>还需要</p><pre><code>offset of[name1, policies1,num1][name2,policies2,num2]count of it</code></pre><p>因此 结果为</p><pre><code>data of first parameteroffset of[name1, policies1,num1][name2,policies2,num2]count of itoffset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p>源文章：<a href="https://hitcxy.com/2021/argument-encoding/">https://hitcxy.com/2021/argument-encoding/</a></p>]]></content>
      
      
      <categories>
          
          <category> text </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
