<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>argument encoding</title>
      <link href="/2022/11/26/Argument-Encoding/"/>
      <url>/2022/11/26/Argument-Encoding/</url>
      
        <content type="html"><![CDATA[<h1 id="关于函数选择器中的argument-encodeing"><a href="#关于函数选择器中的argument-encodeing" class="headerlink" title="关于函数选择器中的argument encodeing"></a>关于函数选择器中的argument encodeing</h1><p><strong>规则</strong><br>先将函数参数按顺序储存，如果是定长数据类型，直接储存其data，如果是变长数据类型，先储存其offset<br>    <em>对于第一个变长数据</em>：offset = 0x20<em>num（num为函数参数的个数）    </em>对于其后的变长数据<em>：offset = offset——pre + 0x20</em>num（offset——pre为上一个变长数据储存占用的大小，num为上一个变长数据元素的个数）<br>储存完offset 接着储存length和data</p><p>例如</p><pre><code>function test4(uint, uint32[] memory, bytes10, bytes memory) public &#123; x = 1; &#125;0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter/*data of first parameter: uint定长类型，直接存储其dataoffset of second parameter: uint32[]动态数组，先存储其offset=0x20*4 (4代表函数参数的个数) data of third parameter: bytes10定长类型，直接存储其dataoffset of forth parameter: bytes变长类型，先存储其offset=0x80+0x20*3=0xe0 (0x80是前一个变长类型的offset，3是前一个变长类型存储其长度和两个元素占用的插槽个数)length of second parameter: 存储完data或者offset后，便开始存储变长数据的length和data，这里是第二个参数的长度first data of second parameter: 第二个参数的第一个数据second data of second parameter: 第二个参数的第二个数据length of forth parameter: 上面就把第二个变长数据存储完成，这里就是存储下一个变长数据的长度data of forth parameter: 第四个参数的数据*/</code></pre><p>对于较复杂的结构  可以由内向外拆分</p><pre><code>struct Test &#123;        string name;        string policies;        uint num;    &#125;function test6(uint, Test[] memory tests) public &#123; x = 1; &#125;设结构体数组有两个结构体第一个结构体内*注：结构体内部编码形式可以看作一个函数offset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1对于第二个结构体内offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p><em>由于是结构体</em><br>还需要</p><pre><code>offset of [name1, policies1,num1]offset of [name2, policies2,num2]</code></pre><p>由于是结构体数组<br>还需要</p><pre><code>offset of[name1, policies1,num1][name2,policies2,num2]count of it</code></pre><p>因此 结果为</p><pre><code>data of first parameteroffset of[name1, policies1,num1][name2,policies2,num2]count of itoffset of name1offset of policies1data of num1length of name1ecoding of name1length of policies1ecoding of policies1offset of name2offset of policies2data of num2length of name2ecoding of name2length of policies2ecoding of policies2</code></pre><p>源文章：<a href="https://hitcxy.com/2021/argument-encoding/">https://hitcxy.com/2021/argument-encoding/</a></p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy</title>
      <link href="/2022/11/26/proxy/"/>
      <url>/2022/11/26/proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h1><hr><p>代理将数据和逻辑分开，分别保存在不同合约中，代理合约和逻辑合约</p><p>对外暴露的是代理合约的地址，用户在进行交互是实际在于代理合约交互，代理合约把数据传给逻辑合约，逻辑合约执行后返回给代理合约，代理合约进一步返回给用户。<br>此方式可以对逻辑合约进行升级，只需把代理合约指向的目标合约进行替换。</p><p>代理合约的实现需要solidity内联汇编，开发者需要熟悉每个步骤的含义<br>代理合约如何实现逻辑合约的函数调用？<br>主要是回调函数，当调用合约中不存在的函数会触发合约中的回调函数，回调函数中将calldata储存并用delegatecall调用目标合约<br>比如</p><pre><code>fallback() external payable &#123;address _implementation = implementation;    assembly &#123;        // 将msg.data拷贝到内存里        // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度        calldatacopy(0, 0, calldatasize())        // 利用delegatecall调用implementation合约        // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度        // output area起始位置和长度位置，所以设为0        // delegatecall成功返回1，失败返回0        let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)        // 将return data拷贝到内存        // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度        returndatacopy(0, 0, returndatasize())        switch result        // 如果delegate call失败，revert        case 0 &#123;            revert(0, returndatasize())        &#125;        // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）        default &#123;            return(0, returndatasize())        &#125;    &#125;&#125;</code></pre><hr><h2 id="openzepplin代理-核心"><a href="#openzepplin代理-核心" class="headerlink" title="openzepplin代理 核心"></a>openzepplin代理 核心</h2><p>1.<strong>proxy</strong><br>此抽象合约提供了一个回退函数，该函数使用 EVM 将所有调用委托给另一个合约指令，第二个合约的实现必须通过覆盖虚拟_implementation函数来指定<br>2.<strong>ERC1967Proxy</strong><br>此协定实现可升级的代理。它是可升级的，因为调用被委托给可以更改的实现地址</p><pre><code>contract ERC1967Proxy is Proxy, ERC1967Upgrade &#123;    constructor(address _logic, bytes memory _data) payable &#123;        _upgradeToAndCall(_logic, _data, false);    &#125;    function _implementation() internal view virtual override returns (address impl) &#123;        return ERC1967Upgrade._getImplementation();    &#125;&#125;</code></pre><p>3.<strong>ERC1967Upgrade</strong><br>整理下其中的函数和事件<br>首先是回调函数：</p><pre><code> function _upgradeBeaconToAndCall(        address newBeacon,        bytes memory data,        bool forceCall    ) internal &#123;        _setBeacon(newBeacon);        emit BeaconUpgraded(newBeacon);        if (data.length &gt; 0 || forceCall) &#123;            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);        &#125;    &#125;&#125;</code></pre><p>它将调用数据传给目标合约<br>三个事件：</p><pre><code>event AdminChanged(address previousAdmin, address newAdmin);//更改管理员时触发event Upgraded(address indexed implementation);//升级时触发event BeaconUpgraded(address indexed beacon)；//升级信标时触发</code></pre><p>获得当前管理：</p><pre><code> function _getAdmin() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;&#125;</code></pre><p>更改管理：</p><pre><code>function _changeAdmin(address newAdmin) internal &#123;    emit AdminChanged(_getAdmin(), newAdmin);    _setAdmin(newAdmin);&#125;function _setAdmin(address newAdmin) private &#123;    require(newAdmin != address(0), &quot;ERC1967: new admin is the zero address&quot;);    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;&#125;</code></pre><p>返回信标：</p><pre><code> function _getBeacon() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_BEACON_SLOT).value;&#125;</code></pre><p>设置一个新信标在EIP1967 beacon solt：</p><pre><code> function _setBeacon(address newBeacon) private &#123;    require(Address.isContract(newBeacon), &quot;ERC1967: new beacon is not a contract&quot;);    require(        Address.isContract(IBeacon(newBeacon).implementation()),        &quot;ERC1967: beacon implementation is not a contract&quot;    );    StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;&#125;</code></pre><p>获得当前目标地址：</p><pre><code> function _getImplementation() internal view returns (address) &#123;    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;&#125;</code></pre><p>更新目标地址：</p><pre><code> function _upgradeTo(address newImplementation) internal &#123;    _setImplementation(newImplementation);    emit Upgraded(newImplementation);&#125;function _setImplementation(address newImplementation) private &#123;    require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;&#125;</code></pre><p>更改并调用：</p><pre><code> function _upgradeToAndCall(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    _upgradeTo(newImplementation);    if (data.length &gt; 0 || forceCall) &#123;        Address.functionDelegateCall(newImplementation, data);    &#125;&#125;  function _upgradeToAndCallUUPS(    address newImplementation,    bytes memory data,    bool forceCall) internal &#123;    if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) &#123;        _setImplementation(newImplementation);    &#125; else &#123;        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) &#123;            require(slot == _IMPLEMENTATION_SLOT, &quot;ERC1967Upgrade: unsupported proxiableUUID&quot;);        &#125; catch &#123;            revert(&quot;ERC1967Upgrade: new implementation is not UUPS&quot;);        &#125;        _upgradeToAndCall(newImplementation, data, forceCall);    &#125;&#125;</code></pre><hr><h2 id="Contract-Initializable"><a href="#Contract-Initializable" class="headerlink" title="Contract Initializable"></a>Contract Initializable</h2><p>用于帮助编写可升级的合约或将要部署的任何类型的合约部署在代理后面</p><p>初始化函数使用版本号。一旦使用了版本号，它就会被使用，并且不能 重用。此机制可防止重新执行每个“步骤”</p><pre><code>function isConstructor() private view returns (bool) &#123;    address self = address(this);    uint256 cs;    assembly &#123; cs := extcodesize(self) &#125; //检查当前地址代码量    return cs == 0;&#125;</code></pre><p>修饰符：</p><pre><code> modifier initializer() &#123;    require(initializing || isConstructor() || !initialized, &quot;Contract instance has already been initialized&quot;);    bool isTopLevelCall = !initializing;    if (isTopLevelCall) &#123;    initializing = true;    initialized = true;    &#125;    _;  //执行完函数体 initializing状态改变    if (isTopLevelCall) &#123;    initializing = false;    &#125;&#125;</code></pre><h2 id="abstract-contract-Initializable"><a href="#abstract-contract-Initializable" class="headerlink" title="abstract contract Initializable"></a>abstract contract Initializable</h2><p>三个修饰符<br>1.只在进行中</p><pre><code> modifier onlyInitializing() &#123;    require(_initializing, &quot;Initializable: contract is not initializing&quot;);    _;&#125;</code></pre><p>2.更新版本</p><pre><code>modifier reinitializer(uint8 version) &#123;    require(!_initializing &amp;&amp; _initialized &lt; version, &quot;Initializable: contract is already initialized&quot;);    _initialized = version;    _initializing = true;    _;    _initializing = false;    emit Initialized(version);&#125;</code></pre><p>3.初始化</p><pre><code>modifier initializer() &#123;    bool isTopLevelCall = !_initializing;    require(        (isTopLevelCall &amp;&amp; _initialized &lt; 1) || (!Address.isContract(address(this)) &amp;&amp; _initialized == 1),        &quot;Initializable: contract is already initialized&quot;    );    //需要从来没有初始化，或者更新版本为1    _initialized = 1;    if (isTopLevelCall) &#123;        _initializing = true;    &#125;    _;    if (isTopLevelCall) &#123;        _initializing = false;        emit Initialized(1);    &#125;&#125;</code></pre><p>函数：报废</p><pre><code>function _disableInitializers() internal virtual &#123;    require(!_initializing, &quot;Initializable: contract is initializing&quot;);    if (_initialized != type(uint8).max) &#123;        _initialized = type(uint8).max;        emit Initialized(type(uint8).max);    &#125;&#125;</code></pre><hr><h2 id="OpenZepplin的UUPS代理模式"><a href="#OpenZepplin的UUPS代理模式" class="headerlink" title="OpenZepplin的UUPS代理模式"></a>OpenZepplin的UUPS代理模式</h2><p>轻量级又通用<br>UUPS 代理中，升级由实现处理，最终可以删除<br>UUPS 代理是使用ERC1967Proxy。实现的作用是，除了合约的逻辑之外，还包括更新存储在代理存储空间中特定插槽中的实现地址所需的所有代码。</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点</title>
      <link href="/2022/11/26/knowledge/"/>
      <url>/2022/11/26/knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><hr><h2 id="合同间的调用函数"><a href="#合同间的调用函数" class="headerlink" title="合同间的调用函数"></a>合同间的调用函数</h2><h3 id="call-delegatecall-callcode区别"><a href="#call-delegatecall-callcode区别" class="headerlink" title="call||delegatecall||callcode区别"></a>call||delegatecall||callcode区别</h3><p><strong>call</strong>：调用后内置变量msg的值会修改为调用者 执行环境为<em>被调用者</em>的环境<br>A调B B委托调C 此时msg.sender为B<br><strong>地址.call{value：}（bytes（keccak256（函数标识符）））</strong></p><p><strong>delegatecall</strong>： 调用后内置变量msg的值<em>不会</em>改为调用者 执行环境为<em>调用者</em> 的运行环境<br>如A调B B委托调用C 此时msg.sender为A</p><p><strong>callcode</strong>： 调用后内置变量msg的值会改为调用者，但执行环境为<em>调用者</em>的运行环境</p><hr><h2 id="通过selfdestruct发送ETH到不可接收合约"><a href="#通过selfdestruct发送ETH到不可接收合约" class="headerlink" title="通过selfdestruct发送ETH到不可接收合约"></a>通过selfdestruct发送ETH到不可接收合约</h2><p>合约自毁，把合约剩余balancs转到指定地址 不管有没有payable<br>selfdestruct(payable(address))</p><hr><h2 id="msg-sender-与tx-origin"><a href="#msg-sender-与tx-origin" class="headerlink" title="msg.sender 与tx.origin"></a>msg.sender 与tx.origin</h2><p> msg.sender为函数直接调用方  tx.origin是交易原始发起方<br> 如用户通过合约A调用合约B<br> 对于合约A tx.origin和msg.sender均为用户<br> 对于合约B tx.origin为用户 msg.sender为合约A</p><hr><p>private属性的数据在可以通过外部访问<br>web3.eth.getStorageAt（’合约地址’，序号）；</p><hr><p> extcodesize（地址）<br> 用来检查是用户地址还是合约地址<br> 如果extcodesize为0 则为用户地址</p><p> 隐患  当合约未创建时 代码长度检测为零 所以如果把攻击函数写在构造函数中，就可以绕过认证</p><hr><p>bytes uint 转换<br>bytes8 bytes32都是定长字节组 他们转换为16进制储存 位数为16 ，64… （一个字节（十六进制）两位）<br>bytes8转换可转换为uint64  bytes32 转换为uint256</p><hr><h1 id="solidity中的内联汇编"><a href="#solidity中的内联汇编" class="headerlink" title="solidity中的内联汇编"></a>solidity中的内联汇编</h1><p>汇编：可用汇编器转换为机器代码的低级编程语言。<br>操作码：为了解决实际问题，基于栈结构机器需要实现一些额外的指令，执行指令时先从堆栈弹出一个或多个值作为参数，再将执行结果压回堆栈</p><h2 id="为什么solidity要使用汇编？"><a href="#为什么solidity要使用汇编？" class="headerlink" title="为什么solidity要使用汇编？"></a>为什么solidity要使用汇编？</h2><p>1.可以直接用操作码与EVM交互 对操作进行更加精准的操控<br>2.更少的gas消耗<br>3.更强的功能</p><h2 id="solidity中两种类型的汇编："><a href="#solidity中两种类型的汇编：" class="headerlink" title="solidity中两种类型的汇编："></a>solidity中两种类型的汇编：</h2><p>1.内联汇编2.独立汇编</p><h2 id="基本汇编语法"><a href="#基本汇编语法" class="headerlink" title="基本汇编语法"></a>基本汇编语法</h2><p><strong>引入汇编</strong><br>assembly{</p><p>}<br><em>用assembly嵌入汇编代码块</em><br><strong>注</strong>：汇编代码块之间不能通信 一个代码块里的的变量，在另一个汇编语言中不可以访问<br>例子：</p><pre><code>function addition（uint x, uint y）public pure returns(uint)&#123;    assemble&#123;        //创建一个变量result        //-&gt;使用add操作码计算x+y        //-&gt;将计算结果赋值给result        let result := add(x,y) //x+y        //使用mstore操作码        // -&gt; result变量的值存入内存        // -&gt; 指定内存地址0x0        mstore(0x0,result)        //结果存入内存        //从内存地址返回0x返回32字节        return(0x0, 32)        &#125;&#125;</code></pre><h2 id="solidity汇编中变量的定义与赋值"><a href="#solidity汇编中变量的定义与赋值" class="headerlink" title="solidity汇编中变量的定义与赋值"></a>solidity汇编中变量的定义与赋值</h2><p>let关键字定义<br>：=赋值<br>assembly{<br>    let x ：= 2<br>}<br>如不赋值初始化为0；</p><p><em>let运行机制</em><br>创建一个新的堆栈槽位<br>为变量保持槽位<br>代码块结束自动销毁该槽位</p><h4 id="汇编的注释"><a href="#汇编的注释" class="headerlink" title="汇编的注释"></a>汇编的注释</h4><p>//<br>/<em> </em>/</p><h4 id="块与作用域"><a href="#块与作用域" class="headerlink" title="块与作用域"></a>块与作用域</h4><p>一个块的范围使用一对大括号标识</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>assembly{</p><pre><code>for&#123; let i := 0 &#125;//初始化 lt(i,n)//执行条件 &#123; i := add(i,1) &#125;&#123;    value := mul(2, value)&#125;mstore(0x0, value)return(0x0, 32)</code></pre><p>}</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>assemble {<br>    let x := 0;<br>    let i := 0;<br>    for {} lt(i,0x100){ }{<br>        x:=add(x,mload(i))<br>        i:=add(i,0x20)<br>    }<br>}</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>assemble{<br>    if slt(x,0) { x := sub( 0, x) }<br>    if eq{value, 0} revert(0,0)<br>    //无else<br>}</p><h2 id="汇编的函数"><a href="#汇编的函数" class="headerlink" title="汇编的函数"></a>汇编的函数</h2><h2 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h2><p>stop()    -                                                F    stop execution, identical to return(0, 0)<br>add(x, y)                                                 F    x + y<br>sub(x, y)                                                 F    x - y<br>mul(x, y)                                                 F    x <em> y<br>div(x, y)                                                 F    x / y or 0 if y == 0<br>sdiv(x, y)                                                 F    x / y, for signed numbers in two’s complement, 0 if y == 0<br>mod(x, y)                                                 F    x % y, 0 if y == 0<br>smod(x, y)                                                 F    x % y, for signed numbers in two’s complement, 0 if y == 0<br>exp(x, y)                                                 F    x to the power of y<br>not(x)                                                     F    bitwise “not” of x (every bit of x is negated)<br>lt(x, y)                                                 F    1 if x &lt; y, 0 otherwise<br>gt(x, y)                                                 F    1 if x &gt; y, 0 otherwise<br>slt(x, y)                                                 F    1 if x &lt; y, 0 otherwise, for signed numbers in two’s complement<br>sgt(x, y)                                                 F    1 if x &gt; y, 0 otherwise, for signed numbers in two’s complement<br>eq(x, y)                                                 F    1 if x == y, 0 otherwise<br>iszero(x)                                                 F    1 if x == 0, 0 otherwise<br>and(x, y)                                                 F    bitwise “and” of x and y<br>or(x, y)                                                 F    bitwise “or” of x and y<br>xor(x, y)                                                 F    bitwise “xor” of x and y<br>byte(n, x)                                                 F    nth byte of x, where the most significant byte is the 0th byte<br>shl(x, y)                                                 C    logical shift left y by x bits<br>shr(x, y)                                                 C    logical shift right y by x bits<br>sar(x, y)                                                 C    signed arithmetic shift right y by x bits<br>addmod(x, y, m)                                             F    (x + y) % m with arbitrary precision arithmetic, 0 if m == 0<br>mulmod(x, y, m)                                             F    (x </em> y) % m with arbitrary precision arithmetic, 0 if m == 0<br>signextend(i, x)                                         F    sign extend from (i*8+7)th bit counting from least significant<br>keccak256(p, n)                                             F    keccak(mem[p…(p+n)))<br>pc()                                                     F    current position in code<br>pop(x)    -                                                F    discard value x<br>mload(p)                                                 F    mem[p…(p+32))<br>mstore(p, v)    -                                        F    mem[p…(p+32)) := v<br>mstore8(p, v)    -                                        F    mem[p] := v &amp; 0xff (only modifies a single byte)<br>sload(p)                                                 F    storage[p]<br>sstore(p, v)    -                                        F    storage[p] := v<br>msize()                                                     F    size of memory, i.e. largest accessed memory index<br>gas()                                                     F    gas still available to execution<br>address()                                                 F    address of the current contract / execution context<br>balance(a)                                                 F    wei balance at address a<br>selfbalance()                                             I    equivalent to balance(address()), but cheaper<br>caller()                                                 F    call sender (excluding delegatecall)<br>callvalue()                                                 F    wei sent together with the current call<br>calldataload(p)                                             F    call data starting from position p (32 bytes)<br>calldatasize()                                             F    size of call data in bytes<br>calldatacopy(t, f, s)                                    F    copy s bytes from calldata at position f to mem at position t<br>codesize()                                                 F    size of the code of the current contract / execution context<br>codecopy(t, f, s)    -                                    F    copy s bytes from code at position f to mem at position t<br>extcodesize(a)                                             F    size of the code at address a<br>extcodecopy(a, t, f, s)    -                                F    like codecopy(t, f, s) but take code at address a<br>returndatasize()                                         B    size of the last returndata<br>returndatacopy(t, f, s)    -                                B    copy s bytes from returndata at position f to mem at position t<br>extcodehash(a)                                             C    code hash of address a<br>create(v, p, n)                                             F    create new contract with code mem[p…(p+n)) and send v wei and return the new address<br>create2(v, p, n, s)                                         C    create new contract with code mem[p…(p+n)) at address keccak256(0xff . this . s . keccak256(mem[p…(p+n))) and send v wei and         return the new address, where 0xff is a 1 byte value, this is the current contract’s address as a 20 byte value and s is a big-endian 256-bit value<br>call(g, a, v, in, insize, out, outsize)                     F    call contract at address a with input mem[in…(in+insize)) providing g gas and v wei and output area mem[out…(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success<br>callcode(g, a, v, in, insize, out, outsize)                 F    identical to call but only use the code from a and stay in the context of the current contract otherwise<br>delegatecall(g, a, in, insize, out, outsize)             H    identical to callcode but also keep caller and callvalue<br>staticcall(g, a, in, insize, out, outsize)                 B    identical to call(g, a, 0, in, insize, out, outsize) but do not allow state modifications<br>return(p, s)    -                                        F    end execution, return data mem[p…(p+s))<br>revert(p, s)    -                                        B    end execution, revert state changes, return data mem[p…(p+s))<br>selfdestruct(a)    -                                        F    end execution, destroy current contract and send funds to a<br>invalid()    -                                            F    end execution with invalid instruction<br>log0(p, s)    -                                            F    log without topics and data mem[p…(p+s))<br>log1(p, s, t1)    -                                        F    log with topic t1 and data mem[p…(p+s))<br>log2(p, s, t1, t2)    -                                    F    log with topics t1, t2 and data mem[p…(p+s))<br>log3(p, s, t1, t2, t3)    -                                F    log with topics t1, t2, t3 and data mem[p…(p+s))<br>log4(p, s, t1, t2, t3, t4)    -                            F    log with topics t1, t2, t3, t4 and data mem[p…(p+s))<br>chainid()                                                 I    ID of the executing chain (EIP 1344)<br>origin()                                                 F    transaction sender<br>gasprice()                                                 F    gas price of the transaction<br>blockhash(b)                                             F    hash of block nr b - only for last 256 blocks excluding current<br>coinbase()                                                 F    current mining beneficiary<br>timestamp()                                                 F    timestamp of the current block in seconds since the epoch<br>number()                                                 F    current block number<br>difficulty()                                             F    difficulty of the current block<br>gaslimit()                                                 F    block gas limit of the current block</p><hr><p>delegatecall 调用其他合约函数 如果改变变量 改变的其实是调用合约 相应插槽的值 而不是被调用合约的值</p><hr><p>Storage</p>]]></content>
      
      
      <categories>
          
          <category> solidity learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
